From 1ae154c0e3425e42b404f3793557313dff491988 Mon Sep 17 00:00:00 2001
From: yumingyang <yumingyang@xiaomi.com>
Date: Fri, 15 Mar 2013 17:57:29 +0800
Subject: [PATCH 10/10] update android src of [jellybean]

Change-Id: I6b586053e39cedb0c0522abe71e6fb02784f75eb

Signed-off-by: santajin <zj1860263@163.com>
---
 .../base/core/java/android/app/ActionBar.java      |  964 --
 .../base/core/java/android/app/Dialog.java         | 1237 +++
 .../base/core/java/android/app/ListActivity.java   |  322 -
 .../base/core/java/android/app/ProgressDialog.java |  360 +
 .../base/core/java/android/app/SearchDialog.java   |  717 ++
 .../core/java/android/app/StatusBarManager.java    |  165 +
 .../java/android/content/ClipboardManager.java     |  233 +
 .../core/java/android/net/ConnectivityManager.java |  883 ++
 .../android/preference/PreferenceFrameLayout.java  |  149 +
 .../core/java/android/speech/tts/TextToSpeech.java | 1386 +++
 .../base/core/java/android/text/SpanSet.java       |  111 +
 .../base/core/java/android/util/TypedValue.java    |  494 +
 .../core/java/android/view/LayoutInflater.java     |  932 ++
 .../core/java/android/view/ViewConfiguration.java  |  705 ++
 .../core/java/android/widget/CompoundButton.java   |  349 +
 .../base/core/java/android/widget/EdgeEffect.java  |  441 +
 .../core/java/android/widget/NumberPicker.java     | 2569 +++++
 .../base/core/java/android/widget/PopupWindow.java | 1607 ++++
 .../base/core/java/android/widget/ProgressBar.java | 1235 +++
 .../base/core/java/android/widget/SearchView.java  | 1751 ++++
 .../com/android/internal/statusbar/IStatusBar.aidl |   41 +
 .../internal/statusbar/IStatusBarService.aidl      |   52 +
 .../internal/view/menu/ListMenuItemView.java       |  272 +
 .../android/internal/view/menu/MenuBuilder.java    | 1270 +++
 .../internal/widget/ActionBarContextView.java      |  538 ++
 .../graphics/drawable/AnimatedRotateDrawable.java  |  356 +
 .../java/android/graphics/drawable/Drawable.java   |  986 ++
 .../android/systemui/statusbar/CommandQueue.java   |  322 +
 .../android/server/InputMethodManagerService.java  | 3827 ++++++++
 .../android/server/StatusBarManagerService.java    |  616 ++
 .../java/com/android/server/am/ProcessList.java    |  221 +
 .../com/android/server/am/UsageStatsService.java   | 1082 +++
 .../java/com/android/server/pm/Installer.java      |  402 +
 .../java/com/android/server/pm/UserManager.java    |  465 +
 .../android/server/wm/WindowManagerService.java    |10154 ++++++++++++++++++++
 35 files changed, 35928 insertions(+), 1286 deletions(-)
 delete mode 100644 src/frameworks/base/core/java/android/app/ActionBar.java
 create mode 100644 src/frameworks/base/core/java/android/app/Dialog.java
 delete mode 100644 src/frameworks/base/core/java/android/app/ListActivity.java
 create mode 100644 src/frameworks/base/core/java/android/app/ProgressDialog.java
 create mode 100644 src/frameworks/base/core/java/android/app/SearchDialog.java
 create mode 100644 src/frameworks/base/core/java/android/app/StatusBarManager.java
 create mode 100644 src/frameworks/base/core/java/android/content/ClipboardManager.java
 create mode 100644 src/frameworks/base/core/java/android/net/ConnectivityManager.java
 create mode 100644 src/frameworks/base/core/java/android/preference/PreferenceFrameLayout.java
 create mode 100755 src/frameworks/base/core/java/android/speech/tts/TextToSpeech.java
 create mode 100644 src/frameworks/base/core/java/android/text/SpanSet.java
 create mode 100644 src/frameworks/base/core/java/android/util/TypedValue.java
 create mode 100644 src/frameworks/base/core/java/android/view/LayoutInflater.java
 create mode 100644 src/frameworks/base/core/java/android/view/ViewConfiguration.java
 create mode 100644 src/frameworks/base/core/java/android/widget/CompoundButton.java
 create mode 100644 src/frameworks/base/core/java/android/widget/EdgeEffect.java
 create mode 100644 src/frameworks/base/core/java/android/widget/NumberPicker.java
 create mode 100644 src/frameworks/base/core/java/android/widget/PopupWindow.java
 create mode 100644 src/frameworks/base/core/java/android/widget/ProgressBar.java
 create mode 100644 src/frameworks/base/core/java/android/widget/SearchView.java
 create mode 100644 src/frameworks/base/core/java/com/android/internal/statusbar/IStatusBar.aidl
 create mode 100644 src/frameworks/base/core/java/com/android/internal/statusbar/IStatusBarService.aidl
 create mode 100644 src/frameworks/base/core/java/com/android/internal/view/menu/ListMenuItemView.java
 create mode 100644 src/frameworks/base/core/java/com/android/internal/view/menu/MenuBuilder.java
 create mode 100644 src/frameworks/base/core/java/com/android/internal/widget/ActionBarContextView.java
 create mode 100644 src/frameworks/base/graphics/java/android/graphics/drawable/AnimatedRotateDrawable.java
 create mode 100644 src/frameworks/base/graphics/java/android/graphics/drawable/Drawable.java
 create mode 100644 src/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/CommandQueue.java
 create mode 100644 src/frameworks/base/services/java/com/android/server/InputMethodManagerService.java
 create mode 100644 src/frameworks/base/services/java/com/android/server/StatusBarManagerService.java
 create mode 100644 src/frameworks/base/services/java/com/android/server/am/ProcessList.java
 create mode 100644 src/frameworks/base/services/java/com/android/server/am/UsageStatsService.java
 create mode 100644 src/frameworks/base/services/java/com/android/server/pm/Installer.java
 create mode 100644 src/frameworks/base/services/java/com/android/server/pm/UserManager.java
 create mode 100755 src/frameworks/base/services/java/com/android/server/wm/WindowManagerService.java

diff --git a/src/frameworks/base/core/java/android/app/ActionBar.java b/src/frameworks/base/core/java/android/app/ActionBar.java
deleted file mode 100644
index cff16ff..0000000
--- a/src/frameworks/base/core/java/android/app/ActionBar.java
+++ /dev/null
@@ -1,964 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.app;
-
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.graphics.drawable.Drawable;
-import android.util.AttributeSet;
-import android.view.Gravity;
-import android.view.View;
-import android.view.ViewDebug;
-import android.view.ViewGroup;
-import android.view.ViewGroup.MarginLayoutParams;
-import android.view.Window;
-import android.widget.SpinnerAdapter;
-
-/**
- * A window feature at the top of the activity that may display the activity title, navigation
- * modes, and other interactive items.
- * <p>Beginning with Android 3.0 (API level 11), the action bar appears at the top of an
- * activity's window when the activity uses the system's {@link
- * android.R.style#Theme_Holo Holo} theme (or one of its descendant themes), which is the default.
- * You may otherwise add the action bar by calling {@link
- * android.view.Window#requestFeature requestFeature(FEATURE_ACTION_BAR)} or by declaring it in a
- * custom theme with the {@link android.R.styleable#Theme_windowActionBar windowActionBar} property.
- * <p>By default, the action bar shows the application icon on
- * the left, followed by the activity title. If your activity has an options menu, you can make
- * select items accessible directly from the action bar as "action items". You can also
- * modify various characteristics of the action bar or remove it completely.</p>
- * <p>From your activity, you can retrieve an instance of {@link ActionBar} by calling {@link
- * android.app.Activity#getActionBar getActionBar()}.</p>
- * <p>In some cases, the action bar may be overlayed by another bar that enables contextual actions,
- * using an {@link android.view.ActionMode}. For example, when the user selects one or more items in
- * your activity, you can enable an action mode that offers actions specific to the selected
- * items, with a UI that temporarily replaces the action bar. Although the UI may occupy the
- * same space, the {@link android.view.ActionMode} APIs are distinct and independent from those for
- * {@link ActionBar}.
- * <div class="special reference">
- * <h3>Developer Guides</h3>
- * <p>For information about how to use the action bar, including how to add action items, navigation
- * modes and more, read the <a href="{@docRoot}guide/topics/ui/actionbar.html">Action
- * Bar</a> developer guide.</p>
- * </div>
- */
-public abstract class ActionBar {
-    /**
-     * Standard navigation mode. Consists of either a logo or icon
-     * and title text with an optional subtitle. Clicking any of these elements
-     * will dispatch onOptionsItemSelected to the host Activity with
-     * a MenuItem with item ID android.R.id.home.
-     */
-    public static final int NAVIGATION_MODE_STANDARD = 0;
-    
-    /**
-     * List navigation mode. Instead of static title text this mode
-     * presents a list menu for navigation within the activity.
-     * e.g. this might be presented to the user as a dropdown list.
-     */
-    public static final int NAVIGATION_MODE_LIST = 1;
-    
-    /**
-     * Tab navigation mode. Instead of static title text this mode
-     * presents a series of tabs for navigation within the activity.
-     */
-    public static final int NAVIGATION_MODE_TABS = 2;
-
-    /**
-     * Use logo instead of icon if available. This flag will cause appropriate
-     * navigation modes to use a wider logo in place of the standard icon.
-     *
-     * @see #setDisplayOptions(int)
-     * @see #setDisplayOptions(int, int)
-     */
-    public static final int DISPLAY_USE_LOGO = 0x1;
-    
-    /**
-     * Show 'home' elements in this action bar, leaving more space for other
-     * navigation elements. This includes logo and icon.
-     *
-     * @see #setDisplayOptions(int)
-     * @see #setDisplayOptions(int, int)
-     */
-    public static final int DISPLAY_SHOW_HOME = 0x2;
-
-    /**
-     * Display the 'home' element such that it appears as an 'up' affordance.
-     * e.g. show an arrow to the left indicating the action that will be taken.
-     *
-     * Set this flag if selecting the 'home' button in the action bar to return
-     * up by a single level in your UI rather than back to the top level or front page.
-     *
-     * <p>Setting this option will implicitly enable interaction with the home/up
-     * button. See {@link #setHomeButtonEnabled(boolean)}.
-     *
-     * @see #setDisplayOptions(int)
-     * @see #setDisplayOptions(int, int)
-     */
-    public static final int DISPLAY_HOME_AS_UP = 0x4;
-
-    /**
-     * Show the activity title and subtitle, if present.
-     *
-     * @see #setTitle(CharSequence)
-     * @see #setTitle(int)
-     * @see #setSubtitle(CharSequence)
-     * @see #setSubtitle(int)
-     * @see #setDisplayOptions(int)
-     * @see #setDisplayOptions(int, int)
-     */
-    public static final int DISPLAY_SHOW_TITLE = 0x8;
-
-    /**
-     * Show the custom view if one has been set.
-     * @see #setCustomView(View)
-     * @see #setDisplayOptions(int)
-     * @see #setDisplayOptions(int, int)
-     */
-    public static final int DISPLAY_SHOW_CUSTOM = 0x10;
-
-    /**
-     * Set the action bar into custom navigation mode, supplying a view
-     * for custom navigation.
-     *
-     * Custom navigation views appear between the application icon and
-     * any action buttons and may use any space available there. Common
-     * use cases for custom navigation views might include an auto-suggesting
-     * address bar for a browser or other navigation mechanisms that do not
-     * translate well to provided navigation modes.
-     *
-     * @param view Custom navigation view to place in the ActionBar.
-     */
-    public abstract void setCustomView(View view);
-
-    /**
-     * Set the action bar into custom navigation mode, supplying a view
-     * for custom navigation.
-     * 
-     * <p>Custom navigation views appear between the application icon and
-     * any action buttons and may use any space available there. Common
-     * use cases for custom navigation views might include an auto-suggesting
-     * address bar for a browser or other navigation mechanisms that do not
-     * translate well to provided navigation modes.</p>
-     *
-     * <p>The display option {@link #DISPLAY_SHOW_CUSTOM} must be set for
-     * the custom view to be displayed.</p>
-     * 
-     * @param view Custom navigation view to place in the ActionBar.
-     * @param layoutParams How this custom view should layout in the bar.
-     *
-     * @see #setDisplayOptions(int, int)
-     */
-    public abstract void setCustomView(View view, LayoutParams layoutParams);
-
-    /**
-     * Set the action bar into custom navigation mode, supplying a view
-     * for custom navigation.
-     *
-     * <p>Custom navigation views appear between the application icon and
-     * any action buttons and may use any space available there. Common
-     * use cases for custom navigation views might include an auto-suggesting
-     * address bar for a browser or other navigation mechanisms that do not
-     * translate well to provided navigation modes.</p>
-     *
-     * <p>The display option {@link #DISPLAY_SHOW_CUSTOM} must be set for
-     * the custom view to be displayed.</p>
-     *
-     * @param resId Resource ID of a layout to inflate into the ActionBar.
-     *
-     * @see #setDisplayOptions(int, int)
-     */
-    public abstract void setCustomView(int resId);
-
-    /**
-     * Set the icon to display in the 'home' section of the action bar.
-     * The action bar will use an icon specified by its style or the
-     * activity icon by default.
-     *
-     * Whether the home section shows an icon or logo is controlled
-     * by the display option {@link #DISPLAY_USE_LOGO}.
-     *
-     * @param resId Resource ID of a drawable to show as an icon.
-     *
-     * @see #setDisplayUseLogoEnabled(boolean)
-     * @see #setDisplayShowHomeEnabled(boolean)
-     */
-    public abstract void setIcon(int resId);
-
-    /**
-     * Set the icon to display in the 'home' section of the action bar.
-     * The action bar will use an icon specified by its style or the
-     * activity icon by default.
-     *
-     * Whether the home section shows an icon or logo is controlled
-     * by the display option {@link #DISPLAY_USE_LOGO}.
-     *
-     * @param icon Drawable to show as an icon.
-     *
-     * @see #setDisplayUseLogoEnabled(boolean)
-     * @see #setDisplayShowHomeEnabled(boolean)
-     */
-    public abstract void setIcon(Drawable icon);
-
-    /**
-     * Set the logo to display in the 'home' section of the action bar.
-     * The action bar will use a logo specified by its style or the
-     * activity logo by default.
-     *
-     * Whether the home section shows an icon or logo is controlled
-     * by the display option {@link #DISPLAY_USE_LOGO}.
-     *
-     * @param resId Resource ID of a drawable to show as a logo.
-     *
-     * @see #setDisplayUseLogoEnabled(boolean)
-     * @see #setDisplayShowHomeEnabled(boolean)
-     */
-    public abstract void setLogo(int resId);
-
-    /**
-     * Set the logo to display in the 'home' section of the action bar.
-     * The action bar will use a logo specified by its style or the
-     * activity logo by default.
-     *
-     * Whether the home section shows an icon or logo is controlled
-     * by the display option {@link #DISPLAY_USE_LOGO}.
-     *
-     * @param logo Drawable to show as a logo.
-     *
-     * @see #setDisplayUseLogoEnabled(boolean)
-     * @see #setDisplayShowHomeEnabled(boolean)
-     */
-    public abstract void setLogo(Drawable logo);
-
-    /**
-     * Set the adapter and navigation callback for list navigation mode.
-     *
-     * The supplied adapter will provide views for the expanded list as well as
-     * the currently selected item. (These may be displayed differently.)
-     *
-     * The supplied OnNavigationListener will alert the application when the user
-     * changes the current list selection.
-     *
-     * @param adapter An adapter that will provide views both to display
-     *                the current navigation selection and populate views
-     *                within the dropdown navigation menu.
-     * @param callback An OnNavigationListener that will receive events when the user
-     *                 selects a navigation item.
-     */
-    public abstract void setListNavigationCallbacks(SpinnerAdapter adapter,
-            OnNavigationListener callback);
-
-    /**
-     * Set the selected navigation item in list or tabbed navigation modes.
-     *
-     * @param position Position of the item to select.
-     */
-    public abstract void setSelectedNavigationItem(int position);
-
-    /**
-     * Get the position of the selected navigation item in list or tabbed navigation modes.
-     *
-     * @return Position of the selected item.
-     */
-    public abstract int getSelectedNavigationIndex();
-
-    /**
-     * Get the number of navigation items present in the current navigation mode.
-     *
-     * @return Number of navigation items.
-     */
-    public abstract int getNavigationItemCount();
-
-    /**
-     * Set the action bar's title. This will only be displayed if
-     * {@link #DISPLAY_SHOW_TITLE} is set.
-     *
-     * @param title Title to set
-     *
-     * @see #setTitle(int)
-     * @see #setDisplayOptions(int, int)
-     */
-    public abstract void setTitle(CharSequence title);
-
-    /**
-     * Set the action bar's title. This will only be displayed if
-     * {@link #DISPLAY_SHOW_TITLE} is set.
-     *
-     * @param resId Resource ID of title string to set
-     *
-     * @see #setTitle(CharSequence)
-     * @see #setDisplayOptions(int, int)
-     */
-    public abstract void setTitle(int resId);
-
-    /**
-     * Set the action bar's subtitle. This will only be displayed if
-     * {@link #DISPLAY_SHOW_TITLE} is set. Set to null to disable the
-     * subtitle entirely.
-     *
-     * @param subtitle Subtitle to set
-     *
-     * @see #setSubtitle(int)
-     * @see #setDisplayOptions(int, int)
-     */
-    public abstract void setSubtitle(CharSequence subtitle);
-
-    /**
-     * Set the action bar's subtitle. This will only be displayed if
-     * {@link #DISPLAY_SHOW_TITLE} is set.
-     *
-     * @param resId Resource ID of subtitle string to set
-     *
-     * @see #setSubtitle(CharSequence)
-     * @see #setDisplayOptions(int, int)
-     */
-    public abstract void setSubtitle(int resId);
-
-    /**
-     * Set display options. This changes all display option bits at once. To change
-     * a limited subset of display options, see {@link #setDisplayOptions(int, int)}.
-     * 
-     * @param options A combination of the bits defined by the DISPLAY_ constants
-     *                defined in ActionBar.
-     */
-    public abstract void setDisplayOptions(int options);
-    
-    /**
-     * Set selected display options. Only the options specified by mask will be changed.
-     * To change all display option bits at once, see {@link #setDisplayOptions(int)}.
-     * 
-     * <p>Example: setDisplayOptions(0, DISPLAY_SHOW_HOME) will disable the
-     * {@link #DISPLAY_SHOW_HOME} option.
-     * setDisplayOptions(DISPLAY_SHOW_HOME, DISPLAY_SHOW_HOME | DISPLAY_USE_LOGO)
-     * will enable {@link #DISPLAY_SHOW_HOME} and disable {@link #DISPLAY_USE_LOGO}.
-     * 
-     * @param options A combination of the bits defined by the DISPLAY_ constants
-     *                defined in ActionBar.
-     * @param mask A bit mask declaring which display options should be changed.
-     */
-    public abstract void setDisplayOptions(int options, int mask);
-
-    /**
-     * Set whether to display the activity logo rather than the activity icon.
-     * A logo is often a wider, more detailed image.
-     *
-     * <p>To set several display options at once, see the setDisplayOptions methods.
-     *
-     * @param useLogo true to use the activity logo, false to use the activity icon.
-     *
-     * @see #setDisplayOptions(int)
-     * @see #setDisplayOptions(int, int)
-     */
-    public abstract void setDisplayUseLogoEnabled(boolean useLogo);
-
-    /**
-     * Set whether to include the application home affordance in the action bar.
-     * Home is presented as either an activity icon or logo.
-     *
-     * <p>To set several display options at once, see the setDisplayOptions methods.
-     *
-     * @param showHome true to show home, false otherwise.
-     *
-     * @see #setDisplayOptions(int)
-     * @see #setDisplayOptions(int, int)
-     */
-    public abstract void setDisplayShowHomeEnabled(boolean showHome);
-
-    /**
-     * Set whether home should be displayed as an "up" affordance.
-     * Set this to true if selecting "home" returns up by a single level in your UI
-     * rather than back to the top level or front page.
-     *
-     * <p>To set several display options at once, see the setDisplayOptions methods.
-     *
-     * @param showHomeAsUp true to show the user that selecting home will return one
-     *                     level up rather than to the top level of the app.
-     *
-     * @see #setDisplayOptions(int)
-     * @see #setDisplayOptions(int, int)
-     */
-    public abstract void setDisplayHomeAsUpEnabled(boolean showHomeAsUp);
-
-    /**
-     * Set whether an activity title/subtitle should be displayed.
-     *
-     * <p>To set several display options at once, see the setDisplayOptions methods.
-     *
-     * @param showTitle true to display a title/subtitle if present.
-     *
-     * @see #setDisplayOptions(int)
-     * @see #setDisplayOptions(int, int)
-     */
-    public abstract void setDisplayShowTitleEnabled(boolean showTitle);
-
-    /**
-     * Set whether a custom view should be displayed, if set.
-     *
-     * <p>To set several display options at once, see the setDisplayOptions methods.
-     *
-     * @param showCustom true if the currently set custom view should be displayed, false otherwise.
-     *
-     * @see #setDisplayOptions(int)
-     * @see #setDisplayOptions(int, int)
-     */
-    public abstract void setDisplayShowCustomEnabled(boolean showCustom);
-
-    /**
-     * Set the ActionBar's background. This will be used for the primary
-     * action bar.
-     * 
-     * @param d Background drawable
-     * @see #setStackedBackgroundDrawable(Drawable)
-     * @see #setSplitBackgroundDrawable(Drawable)
-     */
-    public abstract void setBackgroundDrawable(Drawable d);
-
-    /**
-     * Set the ActionBar's stacked background. This will appear
-     * in the second row/stacked bar on some devices and configurations.
-     *
-     * @param d Background drawable for the stacked row
-     */
-    public void setStackedBackgroundDrawable(Drawable d) { }
-
-    /**
-     * Set the ActionBar's split background. This will appear in
-     * the split action bar containing menu-provided action buttons
-     * on some devices and configurations.
-     * <p>You can enable split action bar with {@link android.R.attr#uiOptions}
-     *
-     * @param d Background drawable for the split bar
-     */
-    public void setSplitBackgroundDrawable(Drawable d) { }
-
-    /**
-     * @return The current custom view.
-     */
-    public abstract View getCustomView();
-
-    /**
-     * Returns the current ActionBar title in standard mode.
-     * Returns null if {@link #getNavigationMode()} would not return
-     * {@link #NAVIGATION_MODE_STANDARD}. 
-     *
-     * @return The current ActionBar title or null.
-     */
-    public abstract CharSequence getTitle();
-    
-    /**
-     * Returns the current ActionBar subtitle in standard mode.
-     * Returns null if {@link #getNavigationMode()} would not return
-     * {@link #NAVIGATION_MODE_STANDARD}. 
-     *
-     * @return The current ActionBar subtitle or null.
-     */
-    public abstract CharSequence getSubtitle();
-    
-    /**
-     * Returns the current navigation mode. The result will be one of:
-     * <ul>
-     * <li>{@link #NAVIGATION_MODE_STANDARD}</li>
-     * <li>{@link #NAVIGATION_MODE_LIST}</li>
-     * <li>{@link #NAVIGATION_MODE_TABS}</li>
-     * </ul>
-     *
-     * @return The current navigation mode.
-     */
-    public abstract int getNavigationMode();
-
-    /**
-     * Set the current navigation mode.
-     *
-     * @param mode The new mode to set.
-     * @see #NAVIGATION_MODE_STANDARD
-     * @see #NAVIGATION_MODE_LIST
-     * @see #NAVIGATION_MODE_TABS
-     */
-    public abstract void setNavigationMode(int mode);
-
-    /**
-     * @return The current set of display options. 
-     */
-    public abstract int getDisplayOptions();
-
-    /**
-     * Create and return a new {@link Tab}.
-     * This tab will not be included in the action bar until it is added.
-     *
-     * <p>Very often tabs will be used to switch between {@link Fragment}
-     * objects.  Here is a typical implementation of such tabs:</p>
-     *
-     * {@sample development/samples/ApiDemos/src/com/example/android/apis/app/FragmentTabs.java
-     *      complete}
-     *
-     * @return A new Tab
-     *
-     * @see #addTab(Tab)
-     */
-    public abstract Tab newTab();
-
-    /**
-     * Add a tab for use in tabbed navigation mode. The tab will be added at the end of the list.
-     * If this is the first tab to be added it will become the selected tab.
-     *
-     * @param tab Tab to add
-     */
-    public abstract void addTab(Tab tab);
-
-    /**
-     * Add a tab for use in tabbed navigation mode. The tab will be added at the end of the list.
-     *
-     * @param tab Tab to add
-     * @param setSelected True if the added tab should become the selected tab.
-     */
-    public abstract void addTab(Tab tab, boolean setSelected);
-
-    /**
-     * Add a tab for use in tabbed navigation mode. The tab will be inserted at
-     * <code>position</code>. If this is the first tab to be added it will become
-     * the selected tab.
-     *
-     * @param tab The tab to add
-     * @param position The new position of the tab
-     */
-    public abstract void addTab(Tab tab, int position);
-
-    /**
-     * Add a tab for use in tabbed navigation mode. The tab will be insterted at
-     * <code>position</code>.
-     *
-     * @param tab The tab to add
-     * @param position The new position of the tab
-     * @param setSelected True if the added tab should become the selected tab.
-     */
-    public abstract void addTab(Tab tab, int position, boolean setSelected);
-
-    /**
-     * Remove a tab from the action bar. If the removed tab was selected it will be deselected
-     * and another tab will be selected if present.
-     *
-     * @param tab The tab to remove
-     */
-    public abstract void removeTab(Tab tab);
-
-    /**
-     * Remove a tab from the action bar. If the removed tab was selected it will be deselected
-     * and another tab will be selected if present.
-     *
-     * @param position Position of the tab to remove
-     */
-    public abstract void removeTabAt(int position);
-
-    /**
-     * Remove all tabs from the action bar and deselect the current tab.
-     */
-    public abstract void removeAllTabs();
-
-    /**
-     * Select the specified tab. If it is not a child of this action bar it will be added.
-     *
-     * <p>Note: If you want to select by index, use {@link #setSelectedNavigationItem(int)}.</p>
-     *
-     * @param tab Tab to select
-     */
-    public abstract void selectTab(Tab tab);
-
-    /**
-     * Returns the currently selected tab if in tabbed navigation mode and there is at least
-     * one tab present.
-     *
-     * @return The currently selected tab or null
-     */
-    public abstract Tab getSelectedTab();
-
-    /**
-     * Returns the tab at the specified index.
-     *
-     * @param index Index value in the range 0-get
-     * @return
-     */
-    public abstract Tab getTabAt(int index);
-
-    /**
-     * Returns the number of tabs currently registered with the action bar.
-     * @return Tab count
-     */
-    public abstract int getTabCount();
-
-    /**
-     * Retrieve the current height of the ActionBar.
-     *
-     * @return The ActionBar's height
-     */
-    public abstract int getHeight();
-
-    /**
-     * Show the ActionBar if it is not currently showing.
-     * If the window hosting the ActionBar does not have the feature
-     * {@link Window#FEATURE_ACTION_BAR_OVERLAY} it will resize application
-     * content to fit the new space available.
-     *
-     * <p>If you are hiding the ActionBar through
-     * {@link View#SYSTEM_UI_FLAG_FULLSCREEN View.SYSTEM_UI_FLAG_FULLSCREEN},
-     * you should not call this function directly.
-     */
-    public abstract void show();
-
-    /**
-     * Hide the ActionBar if it is currently showing.
-     * If the window hosting the ActionBar does not have the feature
-     * {@link Window#FEATURE_ACTION_BAR_OVERLAY} it will resize application
-     * content to fit the new space available.
-     *
-     * <p>Instead of calling this function directly, you can also cause an
-     * ActionBar using the overlay feature to hide through
-     * {@link View#SYSTEM_UI_FLAG_FULLSCREEN View.SYSTEM_UI_FLAG_FULLSCREEN}.
-     * Hiding the ActionBar through this system UI flag allows you to more
-     * seamlessly hide it in conjunction with other screen decorations.
-     */
-    public abstract void hide();
-
-    /**
-     * @return <code>true</code> if the ActionBar is showing, <code>false</code> otherwise.
-     */
-    public abstract boolean isShowing();
-
-    /**
-     * Add a listener that will respond to menu visibility change events.
-     *
-     * @param listener The new listener to add
-     */
-    public abstract void addOnMenuVisibilityListener(OnMenuVisibilityListener listener);
-
-    /**
-     * Remove a menu visibility listener. This listener will no longer receive menu
-     * visibility change events.
-     *
-     * @param listener A listener to remove that was previously added
-     */
-    public abstract void removeOnMenuVisibilityListener(OnMenuVisibilityListener listener);
-
-    /**
-     * Enable or disable the "home" button in the corner of the action bar. (Note that this
-     * is the application home/up affordance on the action bar, not the systemwide home
-     * button.)
-     *
-     * <p>This defaults to true for packages targeting &lt; API 14. For packages targeting
-     * API 14 or greater, the application should call this method to enable interaction
-     * with the home/up affordance.
-     *
-     * <p>Setting the {@link #DISPLAY_HOME_AS_UP} display option will automatically enable
-     * the home button.
-     *
-     * @param enabled true to enable the home button, false to disable the home button.
-     */
-    public void setHomeButtonEnabled(boolean enabled) { }
-
-    /**
-     * Returns a {@link Context} with an appropriate theme for creating views that
-     * will appear in the action bar. If you are inflating or instantiating custom views
-     * that will appear in an action bar, you should use the Context returned by this method.
-     * (This includes adapters used for list navigation mode.)
-     * This will ensure that views contrast properly against the action bar.
-     *
-     * @return A themed Context for creating views
-     */
-    public Context getThemedContext() { return null; }
-
-    /**
-     * Listener interface for ActionBar navigation events.
-     */
-    public interface OnNavigationListener {
-        /**
-         * This method is called whenever a navigation item in your action bar
-         * is selected.
-         *    
-         * @param itemPosition Position of the item clicked.
-         * @param itemId ID of the item clicked.
-         * @return True if the event was handled, false otherwise.
-         */
-        public boolean onNavigationItemSelected(int itemPosition, long itemId);
-    }
-
-    /**
-     * Listener for receiving events when action bar menus are shown or hidden.
-     */
-    public interface OnMenuVisibilityListener {
-        /**
-         * Called when an action bar menu is shown or hidden. Applications may want to use
-         * this to tune auto-hiding behavior for the action bar or pause/resume video playback,
-         * gameplay, or other activity within the main content area.
-         *
-         * @param isVisible True if an action bar menu is now visible, false if no action bar
-         *                  menus are visible.
-         */
-        public void onMenuVisibilityChanged(boolean isVisible);
-    }
-
-    /**
-     * A tab in the action bar.
-     *
-     * <p>Tabs manage the hiding and showing of {@link Fragment}s.
-     */
-    public static abstract class Tab {
-        /**
-         * An invalid position for a tab.
-         *
-         * @see #getPosition()
-         */
-        public static final int INVALID_POSITION = -1;
-
-        /**
-         * Return the current position of this tab in the action bar.
-         *
-         * @return Current position, or {@link #INVALID_POSITION} if this tab is not currently in
-         *         the action bar.
-         */
-        public abstract int getPosition();
-
-        /**
-         * Return the icon associated with this tab.
-         *
-         * @return The tab's icon
-         */
-        public abstract Drawable getIcon();
-
-        /**
-         * Return the text of this tab.
-         *
-         * @return The tab's text
-         */
-        public abstract CharSequence getText();
-
-        /**
-         * Set the icon displayed on this tab.
-         *
-         * @param icon The drawable to use as an icon
-         * @return The current instance for call chaining
-         */
-        public abstract Tab setIcon(Drawable icon);
-
-        /**
-         * Set the icon displayed on this tab.
-         *
-         * @param resId Resource ID referring to the drawable to use as an icon
-         * @return The current instance for call chaining
-         */
-        public abstract Tab setIcon(int resId);
-
-        /**
-         * Set the text displayed on this tab. Text may be truncated if there is not
-         * room to display the entire string.
-         *
-         * @param text The text to display
-         * @return The current instance for call chaining
-         */
-        public abstract Tab setText(CharSequence text);
-
-        /**
-         * Set the text displayed on this tab. Text may be truncated if there is not
-         * room to display the entire string.
-         *
-         * @param resId A resource ID referring to the text that should be displayed
-         * @return The current instance for call chaining
-         */
-        public abstract Tab setText(int resId);
-
-        /**
-         * Set a custom view to be used for this tab. This overrides values set by
-         * {@link #setText(CharSequence)} and {@link #setIcon(Drawable)}.
-         *
-         * @param view Custom view to be used as a tab.
-         * @return The current instance for call chaining
-         */
-        public abstract Tab setCustomView(View view);
-
-        /**
-         * Set a custom view to be used for this tab. This overrides values set by
-         * {@link #setText(CharSequence)} and {@link #setIcon(Drawable)}.
-         *
-         * @param layoutResId A layout resource to inflate and use as a custom tab view
-         * @return The current instance for call chaining
-         */
-        public abstract Tab setCustomView(int layoutResId);
-
-        /**
-         * Retrieve a previously set custom view for this tab.
-         *
-         * @return The custom view set by {@link #setCustomView(View)}.
-         */
-        public abstract View getCustomView();
-
-        /**
-         * Give this Tab an arbitrary object to hold for later use.
-         *
-         * @param obj Object to store
-         * @return The current instance for call chaining
-         */
-        public abstract Tab setTag(Object obj);
-
-        /**
-         * @return This Tab's tag object.
-         */
-        public abstract Object getTag();
-
-        /**
-         * Set the {@link TabListener} that will handle switching to and from this tab.
-         * All tabs must have a TabListener set before being added to the ActionBar.
-         *
-         * @param listener Listener to handle tab selection events
-         * @return The current instance for call chaining
-         */
-        public abstract Tab setTabListener(TabListener listener);
-
-        /**
-         * Select this tab. Only valid if the tab has been added to the action bar.
-         */
-        public abstract void select();
-
-        /**
-         * Set a description of this tab's content for use in accessibility support.
-         * If no content description is provided the title will be used.
-         *
-         * @param resId A resource ID referring to the description text
-         * @return The current instance for call chaining
-         * @see #setContentDescription(CharSequence)
-         * @see #getContentDescription()
-         */
-        public abstract Tab setContentDescription(int resId);
-
-        /**
-         * Set a description of this tab's content for use in accessibility support.
-         * If no content description is provided the title will be used.
-         *
-         * @param contentDesc Description of this tab's content
-         * @return The current instance for call chaining
-         * @see #setContentDescription(int)
-         * @see #getContentDescription()
-         */
-        public abstract Tab setContentDescription(CharSequence contentDesc);
-
-        /**
-         * Gets a brief description of this tab's content for use in accessibility support.
-         *
-         * @return Description of this tab's content
-         * @see #setContentDescription(CharSequence)
-         * @see #setContentDescription(int)
-         */
-        public abstract CharSequence getContentDescription();
-    }
-
-    /**
-     * Callback interface invoked when a tab is focused, unfocused, added, or removed.
-     */
-    public interface TabListener {
-        /**
-         * Called when a tab enters the selected state.
-         *
-         * @param tab The tab that was selected
-         * @param ft A {@link FragmentTransaction} for queuing fragment operations to execute
-         *        during a tab switch. The previous tab's unselect and this tab's select will be
-         *        executed in a single transaction. This FragmentTransaction does not support
-         *        being added to the back stack.
-         */
-        public void onTabSelected(Tab tab, FragmentTransaction ft);
-
-        /**
-         * Called when a tab exits the selected state.
-         *
-         * @param tab The tab that was unselected
-         * @param ft A {@link FragmentTransaction} for queuing fragment operations to execute
-         *        during a tab switch. This tab's unselect and the newly selected tab's select
-         *        will be executed in a single transaction. This FragmentTransaction does not
-         *        support being added to the back stack.
-         */
-        public void onTabUnselected(Tab tab, FragmentTransaction ft);
-
-        /**
-         * Called when a tab that is already selected is chosen again by the user.
-         * Some applications may use this action to return to the top level of a category.
-         *
-         * @param tab The tab that was reselected.
-         * @param ft A {@link FragmentTransaction} for queuing fragment operations to execute
-         *        once this method returns. This FragmentTransaction does not support
-         *        being added to the back stack.
-         */
-        public void onTabReselected(Tab tab, FragmentTransaction ft);
-    }
-
-    /**
-     * Per-child layout information associated with action bar custom views.
-     *
-     * @attr ref android.R.styleable#ActionBar_LayoutParams_layout_gravity
-     */
-    public static class LayoutParams extends MarginLayoutParams {
-        /**
-         * Gravity for the view associated with these LayoutParams.
-         *
-         * @see android.view.Gravity
-         */
-        @ViewDebug.ExportedProperty(category = "layout", mapping = {
-            @ViewDebug.IntToString(from =  -1,                       to = "NONE"),
-            @ViewDebug.IntToString(from = Gravity.NO_GRAVITY,        to = "NONE"),
-            @ViewDebug.IntToString(from = Gravity.TOP,               to = "TOP"),
-            @ViewDebug.IntToString(from = Gravity.BOTTOM,            to = "BOTTOM"),
-            @ViewDebug.IntToString(from = Gravity.LEFT,              to = "LEFT"),
-            @ViewDebug.IntToString(from = Gravity.RIGHT,             to = "RIGHT"),
-            @ViewDebug.IntToString(from = Gravity.CENTER_VERTICAL,   to = "CENTER_VERTICAL"),
-            @ViewDebug.IntToString(from = Gravity.FILL_VERTICAL,     to = "FILL_VERTICAL"),
-            @ViewDebug.IntToString(from = Gravity.CENTER_HORIZONTAL, to = "CENTER_HORIZONTAL"),
-            @ViewDebug.IntToString(from = Gravity.FILL_HORIZONTAL,   to = "FILL_HORIZONTAL"),
-            @ViewDebug.IntToString(from = Gravity.CENTER,            to = "CENTER"),
-            @ViewDebug.IntToString(from = Gravity.FILL,              to = "FILL")
-        })
-        public int gravity = -1;
-
-        public LayoutParams(Context c, AttributeSet attrs) {
-            super(c, attrs);
-
-            TypedArray a = c.obtainStyledAttributes(attrs,
-                    com.android.internal.R.styleable.ActionBar_LayoutParams);
-            gravity = a.getInt(
-                    com.android.internal.R.styleable.ActionBar_LayoutParams_layout_gravity, -1);
-            a.recycle();
-        }
-
-        public LayoutParams(int width, int height) {
-            super(width, height);
-            this.gravity = Gravity.CENTER_VERTICAL | Gravity.LEFT;
-        }
-
-        public LayoutParams(int width, int height, int gravity) {
-            super(width, height);
-            this.gravity = gravity;
-        }
-
-        public LayoutParams(int gravity) {
-            this(WRAP_CONTENT, MATCH_PARENT, gravity);
-        }
-
-        public LayoutParams(LayoutParams source) {
-            super(source);
-
-            this.gravity = source.gravity;
-        }
-
-        public LayoutParams(ViewGroup.LayoutParams source) {
-            super(source);
-        }
-    }
-}
diff --git a/src/frameworks/base/core/java/android/app/Dialog.java b/src/frameworks/base/core/java/android/app/Dialog.java
new file mode 100644
index 0000000..2cc3b02
--- /dev/null
+++ b/src/frameworks/base/core/java/android/app/Dialog.java
@@ -0,0 +1,1237 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+import com.android.internal.app.ActionBarImpl;
+import com.android.internal.policy.PolicyManager;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.content.DialogInterface;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.util.Log;
+import android.util.TypedValue;
+import android.view.ActionMode;
+import android.view.ContextMenu;
+import android.view.ContextMenu.ContextMenuInfo;
+import android.view.ContextThemeWrapper;
+import android.view.Gravity;
+import android.view.KeyEvent;
+import android.view.LayoutInflater;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.View.OnCreateContextMenuListener;
+import android.view.ViewGroup;
+import android.view.ViewGroup.LayoutParams;
+import android.view.Window;
+import android.view.WindowManager;
+import android.view.accessibility.AccessibilityEvent;
+
+import java.lang.ref.WeakReference;
+
+/**
+ * Base class for Dialogs.
+ * 
+ * <p>Note: Activities provide a facility to manage the creation, saving and
+ * restoring of dialogs. See {@link Activity#onCreateDialog(int)},
+ * {@link Activity#onPrepareDialog(int, Dialog)},
+ * {@link Activity#showDialog(int)}, and {@link Activity#dismissDialog(int)}. If
+ * these methods are used, {@link #getOwnerActivity()} will return the Activity
+ * that managed this dialog.
+ * 
+ * <p>Often you will want to have a Dialog display on top of the current
+ * input method, because there is no reason for it to accept text.  You can
+ * do this by setting the {@link WindowManager.LayoutParams#FLAG_ALT_FOCUSABLE_IM
+ * WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM} window flag (assuming
+ * your Dialog takes input focus, as it the default) with the following code:
+ * 
+ * <pre>
+ * getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,
+ *         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);</pre>
+ *
+ * <div class="special reference">
+ * <h3>Developer Guides</h3>
+ * <p>For more information about creating dialogs, read the
+ * <a href="{@docRoot}guide/topics/ui/dialogs.html">Dialogs</a> developer guide.</p>
+ * </div>
+ */
+public class Dialog implements DialogInterface, Window.Callback,
+        KeyEvent.Callback, OnCreateContextMenuListener {
+    private static final String TAG = "Dialog";
+    private Activity mOwnerActivity;
+    
+    final Context mContext;
+    final WindowManager mWindowManager;
+    Window mWindow;
+    View mDecor;
+    private ActionBarImpl mActionBar;
+    /**
+     * This field should be made private, so it is hidden from the SDK.
+     * {@hide}
+     */
+    protected boolean mCancelable = true;
+
+    private String mCancelAndDismissTaken;
+    private Message mCancelMessage;
+    private Message mDismissMessage;
+    private Message mShowMessage;
+
+    private OnKeyListener mOnKeyListener;
+
+    private boolean mCreated = false;
+    private boolean mShowing = false;
+    private boolean mCanceled = false;
+
+    private final Handler mHandler = new Handler();
+
+    private static final int DISMISS = 0x43;
+    private static final int CANCEL = 0x44;
+    private static final int SHOW = 0x45;
+
+    private Handler mListenersHandler;
+
+    private ActionMode mActionMode;
+
+    private final Runnable mDismissAction = new Runnable() {
+        public void run() {
+            dismissDialog();
+        }
+    };
+
+    /**
+     * Create a Dialog window that uses the default dialog frame style.
+     * 
+     * @param context The Context the Dialog is to run it.  In particular, it
+     *                uses the window manager and theme in this context to
+     *                present its UI.
+     */
+    public Dialog(Context context) {
+        this(context, 0, true);
+    }
+
+    /**
+     * Create a Dialog window that uses a custom dialog style.
+     * 
+     * @param context The Context in which the Dialog should run. In particular, it
+     *                uses the window manager and theme from this context to
+     *                present its UI.
+     * @param theme A style resource describing the theme to use for the 
+     * window. See <a href="{@docRoot}guide/topics/resources/available-resources.html#stylesandthemes">Style 
+     * and Theme Resources</a> for more information about defining and using 
+     * styles.  This theme is applied on top of the current theme in 
+     * <var>context</var>.  If 0, the default dialog theme will be used.
+     */
+    public Dialog(Context context, int theme) {
+        this(context, theme, true);
+    }
+
+    Dialog(Context context, int theme, boolean createContextWrapper) {
+        if (theme == 0) {
+            TypedValue outValue = new TypedValue();
+            context.getTheme().resolveAttribute(com.android.internal.R.attr.dialogTheme,
+                    outValue, true);
+            theme = outValue.resourceId;
+        }
+
+        mContext = createContextWrapper ? new ContextThemeWrapper(context, theme) : context;
+        mWindowManager = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
+        Window w = PolicyManager.makeNewWindow(mContext);
+        mWindow = w;
+        w.setCallback(this);
+        w.setWindowManager(mWindowManager, null, null);
+        w.setGravity(Gravity.CENTER);
+        mListenersHandler = new ListenersHandler(this);
+    }
+    
+    /**
+     * @deprecated
+     * @hide
+     */
+    @Deprecated
+    protected Dialog(Context context, boolean cancelable,
+            Message cancelCallback) {
+        this(context);
+        mCancelable = cancelable;
+        mCancelMessage = cancelCallback;
+    }
+
+    protected Dialog(Context context, boolean cancelable,
+            OnCancelListener cancelListener) {
+        this(context);
+        mCancelable = cancelable;
+        setOnCancelListener(cancelListener);
+    }
+
+    /**
+     * Retrieve the Context this Dialog is running in.
+     * 
+     * @return Context The Context used by the Dialog.
+     */
+    public final Context getContext() {
+        return mContext;
+    }
+
+    /**
+     * Retrieve the {@link ActionBar} attached to this dialog, if present.
+     *
+     * @return The ActionBar attached to the dialog or null if no ActionBar is present.
+     */
+    public ActionBar getActionBar() {
+        return mActionBar;
+    }
+
+    /**
+     * Sets the Activity that owns this dialog. An example use: This Dialog will
+     * use the suggested volume control stream of the Activity.
+     * 
+     * @param activity The Activity that owns this dialog.
+     */
+    public final void setOwnerActivity(Activity activity) {
+        mOwnerActivity = activity;
+        
+        getWindow().setVolumeControlStream(mOwnerActivity.getVolumeControlStream());
+    }
+
+    /**
+     * Returns the Activity that owns this Dialog. For example, if
+     * {@link Activity#showDialog(int)} is used to show this Dialog, that
+     * Activity will be the owner (by default). Depending on how this dialog was
+     * created, this may return null.
+     * 
+     * @return The Activity that owns this Dialog.
+     */
+    public final Activity getOwnerActivity() {
+        return mOwnerActivity;
+    }
+    
+    /**
+     * @return Whether the dialog is currently showing.
+     */
+    public boolean isShowing() {
+        return mShowing;
+    }
+
+    /**
+     * Start the dialog and display it on screen.  The window is placed in the
+     * application layer and opaque.  Note that you should not override this
+     * method to do initialization when the dialog is shown, instead implement
+     * that in {@link #onStart}.
+     */
+    public void show() {
+        if (mShowing) {
+            if (mDecor != null) {
+                if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
+                    mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);
+                }
+                mDecor.setVisibility(View.VISIBLE);
+            }
+            return;
+        }
+
+        mCanceled = false;
+        
+        if (!mCreated) {
+            dispatchOnCreate(null);
+        }
+
+        onStart();
+        mDecor = mWindow.getDecorView();
+
+        if (mActionBar == null && mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
+            mActionBar = new ActionBarImpl(this);
+        }
+
+        WindowManager.LayoutParams l = mWindow.getAttributes();
+        if ((l.softInputMode
+                & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {
+            WindowManager.LayoutParams nl = new WindowManager.LayoutParams();
+            nl.copyFrom(l);
+            nl.softInputMode |=
+                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
+            l = nl;
+        }
+
+        try {
+            mWindowManager.addView(mDecor, l);
+            mShowing = true;
+    
+            sendShowMessage();
+        } finally {
+        }
+    }
+    
+    /**
+     * Hide the dialog, but do not dismiss it.
+     */
+    public void hide() {
+        if (mDecor != null) {
+            mDecor.setVisibility(View.GONE);
+        }
+    }
+
+    /**
+     * Dismiss this dialog, removing it from the screen. This method can be
+     * invoked safely from any thread.  Note that you should not override this
+     * method to do cleanup when the dialog is dismissed, instead implement
+     * that in {@link #onStop}.
+     */
+    public void dismiss() {
+        if (Looper.myLooper() == mHandler.getLooper()) {
+            dismissDialog();
+        } else {
+            mHandler.post(mDismissAction);
+        }
+    }
+
+    void dismissDialog() {
+        if (mDecor == null || !mShowing) {
+            return;
+        }
+
+        if (mWindow.isDestroyed()) {
+            Log.e(TAG, "Tried to dismissDialog() but the Dialog's window was already destroyed!");
+            return;
+        }
+
+        try {
+            mWindowManager.removeView(mDecor);
+        } finally {
+            if (mActionMode != null) {
+                mActionMode.finish();
+            }
+            mDecor = null;
+            mWindow.closeAllPanels();
+            onStop();
+            mShowing = false;
+            
+            sendDismissMessage();
+        }
+    }
+
+    private void sendDismissMessage() {
+        if (mDismissMessage != null) {
+            // Obtain a new message so this dialog can be re-used
+            Message.obtain(mDismissMessage).sendToTarget();
+        }
+    }
+
+    private void sendShowMessage() {
+        if (mShowMessage != null) {
+            // Obtain a new message so this dialog can be re-used
+            Message.obtain(mShowMessage).sendToTarget();
+        }
+    }
+
+    // internal method to make sure mcreated is set properly without requiring
+    // users to call through to super in onCreate
+    void dispatchOnCreate(Bundle savedInstanceState) {
+        if (!mCreated) {
+            onCreate(savedInstanceState);
+            mCreated = true;
+        }
+    }
+
+    /**
+     * Similar to {@link Activity#onCreate}, you should initialize your dialog
+     * in this method, including calling {@link #setContentView}.
+     * @param savedInstanceState If this dialog is being reinitalized after a
+     *     the hosting activity was previously shut down, holds the result from
+     *     the most recent call to {@link #onSaveInstanceState}, or null if this
+     *     is the first time.
+     */
+    protected void onCreate(Bundle savedInstanceState) {
+    }
+
+    /**
+     * Called when the dialog is starting.
+     */
+    protected void onStart() {
+        if (mActionBar != null) mActionBar.setShowHideAnimationEnabled(true);
+    }
+
+    /**
+     * Called to tell you that you're stopping.
+     */
+    protected void onStop() {
+        if (mActionBar != null) mActionBar.setShowHideAnimationEnabled(false);
+    }
+
+    private static final String DIALOG_SHOWING_TAG = "android:dialogShowing";
+    private static final String DIALOG_HIERARCHY_TAG = "android:dialogHierarchy";
+
+    /**
+     * Saves the state of the dialog into a bundle.
+     *
+     * The default implementation saves the state of its view hierarchy, so you'll
+     * likely want to call through to super if you override this to save additional
+     * state.
+     * @return A bundle with the state of the dialog.
+     */
+    public Bundle onSaveInstanceState() {
+        Bundle bundle = new Bundle();
+        bundle.putBoolean(DIALOG_SHOWING_TAG, mShowing);
+        if (mCreated) {
+            bundle.putBundle(DIALOG_HIERARCHY_TAG, mWindow.saveHierarchyState());
+        }
+        return bundle;
+    }
+
+    /**
+     * Restore the state of the dialog from a previously saved bundle.
+     *
+     * The default implementation restores the state of the dialog's view
+     * hierarchy that was saved in the default implementation of {@link #onSaveInstanceState()},
+     * so be sure to call through to super when overriding unless you want to
+     * do all restoring of state yourself.
+     * @param savedInstanceState The state of the dialog previously saved by
+     *     {@link #onSaveInstanceState()}.
+     */
+    public void onRestoreInstanceState(Bundle savedInstanceState) {
+        final Bundle dialogHierarchyState = savedInstanceState.getBundle(DIALOG_HIERARCHY_TAG);
+        if (dialogHierarchyState == null) {
+            // dialog has never been shown, or onCreated, nothing to restore.
+            return;
+        }
+        dispatchOnCreate(savedInstanceState);
+        mWindow.restoreHierarchyState(dialogHierarchyState);
+        if (savedInstanceState.getBoolean(DIALOG_SHOWING_TAG)) {
+            show();
+        }
+    }
+
+    /**
+     * Retrieve the current Window for the activity.  This can be used to
+     * directly access parts of the Window API that are not available
+     * through Activity/Screen.
+     * 
+     * @return Window The current window, or null if the activity is not
+     *         visual.
+     */
+    public Window getWindow() {
+        return mWindow;
+    }
+
+    /**
+     * Call {@link android.view.Window#getCurrentFocus} on the
+     * Window if this Activity to return the currently focused view.
+     * 
+     * @return View The current View with focus or null.
+     * 
+     * @see #getWindow
+     * @see android.view.Window#getCurrentFocus
+     */
+    public View getCurrentFocus() {
+        return mWindow != null ? mWindow.getCurrentFocus() : null;
+    }
+
+    /**
+     * Finds a view that was identified by the id attribute from the XML that
+     * was processed in {@link #onStart}.
+     *
+     * @param id the identifier of the view to find
+     * @return The view if found or null otherwise.
+     */
+    public View findViewById(int id) {
+        return mWindow.findViewById(id);
+    }
+
+    /**
+     * Set the screen content from a layout resource.  The resource will be
+     * inflated, adding all top-level views to the screen.
+     * 
+     * @param layoutResID Resource ID to be inflated.
+     */
+    public void setContentView(int layoutResID) {
+        mWindow.setContentView(layoutResID);
+    }
+
+    /**
+     * Set the screen content to an explicit view.  This view is placed
+     * directly into the screen's view hierarchy.  It can itself be a complex
+     * view hierarhcy.
+     * 
+     * @param view The desired content to display.
+     */
+    public void setContentView(View view) {
+        mWindow.setContentView(view);
+    }
+
+    /**
+     * Set the screen content to an explicit view.  This view is placed
+     * directly into the screen's view hierarchy.  It can itself be a complex
+     * view hierarhcy.
+     * 
+     * @param view The desired content to display.
+     * @param params Layout parameters for the view.
+     */
+    public void setContentView(View view, ViewGroup.LayoutParams params) {
+        mWindow.setContentView(view, params);
+    }
+
+    /**
+     * Add an additional content view to the screen.  Added after any existing
+     * ones in the screen -- existing views are NOT removed.
+     * 
+     * @param view The desired content to display.
+     * @param params Layout parameters for the view.
+     */
+    public void addContentView(View view, ViewGroup.LayoutParams params) {
+        mWindow.addContentView(view, params);
+    }
+
+    /**
+     * Set the title text for this dialog's window.
+     * 
+     * @param title The new text to display in the title.
+     */
+    public void setTitle(CharSequence title) {
+        mWindow.setTitle(title);
+        mWindow.getAttributes().setTitle(title);
+    }
+
+    /**
+     * Set the title text for this dialog's window. The text is retrieved
+     * from the resources with the supplied identifier.
+     *
+     * @param titleId the title's text resource identifier
+     */
+    public void setTitle(int titleId) {
+        setTitle(mContext.getText(titleId));
+    }
+
+    /**
+     * A key was pressed down.
+     * 
+     * <p>If the focused view didn't want this event, this method is called.
+     *
+     * <p>The default implementation consumed the KEYCODE_BACK to later
+     * handle it in {@link #onKeyUp}.
+     *
+     * @see #onKeyUp
+     * @see android.view.KeyEvent
+     */
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+        if (keyCode == KeyEvent.KEYCODE_BACK) {
+            event.startTracking();
+            return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * Default implementation of {@link KeyEvent.Callback#onKeyLongPress(int, KeyEvent)
+     * KeyEvent.Callback.onKeyLongPress()}: always returns false (doesn't handle
+     * the event).
+     */
+    public boolean onKeyLongPress(int keyCode, KeyEvent event) {
+        return false;
+    }
+
+    /**
+     * A key was released.
+     * 
+     * <p>The default implementation handles KEYCODE_BACK to close the
+     * dialog.
+     *
+     * @see #onKeyDown
+     * @see KeyEvent
+     */
+    public boolean onKeyUp(int keyCode, KeyEvent event) {
+        if (keyCode == KeyEvent.KEYCODE_BACK && event.isTracking()
+                && !event.isCanceled()) {
+            onBackPressed();
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Default implementation of {@link KeyEvent.Callback#onKeyMultiple(int, int, KeyEvent)
+     * KeyEvent.Callback.onKeyMultiple()}: always returns false (doesn't handle
+     * the event).
+     */
+    public boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event) {
+        return false;
+    }
+    
+    /**
+     * Called when the dialog has detected the user's press of the back
+     * key.  The default implementation simply cancels the dialog (only if
+     * it is cancelable), but you can override this to do whatever you want.
+     */
+    public void onBackPressed() {
+        if (mCancelable) {
+            cancel();
+        }
+    }
+
+    /**
+     * Called when a key shortcut event is not handled by any of the views in the Dialog.
+     * Override this method to implement global key shortcuts for the Dialog.
+     * Key shortcuts can also be implemented by setting the
+     * {@link MenuItem#setShortcut(char, char) shortcut} property of menu items.
+     *
+     * @param keyCode The value in event.getKeyCode().
+     * @param event Description of the key event.
+     * @return True if the key shortcut was handled.
+     */
+    public boolean onKeyShortcut(int keyCode, KeyEvent event) {
+        return false;
+    }
+
+    /**
+     * Called when a touch screen event was not handled by any of the views
+     * under it. This is most useful to process touch events that happen outside
+     * of your window bounds, where there is no view to receive it.
+     * 
+     * @param event The touch screen event being processed.
+     * @return Return true if you have consumed the event, false if you haven't.
+     *         The default implementation will cancel the dialog when a touch
+     *         happens outside of the window bounds.
+     */
+    public boolean onTouchEvent(MotionEvent event) {
+        if (mCancelable && mShowing && mWindow.shouldCloseOnTouch(mContext, event)) {
+            cancel();
+            return true;
+        }
+        
+        return false;
+    }
+
+    /**
+     * Called when the trackball was moved and not handled by any of the
+     * views inside of the activity.  So, for example, if the trackball moves
+     * while focus is on a button, you will receive a call here because
+     * buttons do not normally do anything with trackball events.  The call
+     * here happens <em>before</em> trackball movements are converted to
+     * DPAD key events, which then get sent back to the view hierarchy, and
+     * will be processed at the point for things like focus navigation.
+     * 
+     * @param event The trackball event being processed.
+     * 
+     * @return Return true if you have consumed the event, false if you haven't.
+     * The default implementation always returns false.
+     */
+    public boolean onTrackballEvent(MotionEvent event) {
+        return false;
+    }
+
+    /**
+     * Called when a generic motion event was not handled by any of the
+     * views inside of the dialog.
+     * <p>
+     * Generic motion events describe joystick movements, mouse hovers, track pad
+     * touches, scroll wheel movements and other input events.  The
+     * {@link MotionEvent#getSource() source} of the motion event specifies
+     * the class of input that was received.  Implementations of this method
+     * must examine the bits in the source before processing the event.
+     * The following code example shows how this is done.
+     * </p><p>
+     * Generic motion events with source class
+     * {@link android.view.InputDevice#SOURCE_CLASS_POINTER}
+     * are delivered to the view under the pointer.  All other generic motion events are
+     * delivered to the focused view.
+     * </p><p>
+     * See {@link View#onGenericMotionEvent(MotionEvent)} for an example of how to
+     * handle this event.
+     * </p>
+     *
+     * @param event The generic motion event being processed.
+     *
+     * @return Return true if you have consumed the event, false if you haven't.
+     * The default implementation always returns false.
+     */
+    public boolean onGenericMotionEvent(MotionEvent event) {
+        return false;
+    }
+
+    public void onWindowAttributesChanged(WindowManager.LayoutParams params) {
+        if (mDecor != null) {
+            mWindowManager.updateViewLayout(mDecor, params);
+        }
+    }
+
+    public void onContentChanged() {
+    }
+    
+    public void onWindowFocusChanged(boolean hasFocus) {
+    }
+
+    public void onAttachedToWindow() {
+    }
+    
+    public void onDetachedFromWindow() {
+    }
+    
+    /**
+     * Called to process key events.  You can override this to intercept all 
+     * key events before they are dispatched to the window.  Be sure to call 
+     * this implementation for key events that should be handled normally.
+     * 
+     * @param event The key event.
+     * 
+     * @return boolean Return true if this event was consumed.
+     */
+    public boolean dispatchKeyEvent(KeyEvent event) {
+        if ((mOnKeyListener != null) && (mOnKeyListener.onKey(this, event.getKeyCode(), event))) {
+            return true;
+        }
+        if (mWindow.superDispatchKeyEvent(event)) {
+            return true;
+        }
+        return event.dispatch(this, mDecor != null
+                ? mDecor.getKeyDispatcherState() : null, this);
+    }
+
+    /**
+     * Called to process a key shortcut event.
+     * You can override this to intercept all key shortcut events before they are
+     * dispatched to the window.  Be sure to call this implementation for key shortcut
+     * events that should be handled normally.
+     *
+     * @param event The key shortcut event.
+     * @return True if this event was consumed.
+     */
+    public boolean dispatchKeyShortcutEvent(KeyEvent event) {
+        if (mWindow.superDispatchKeyShortcutEvent(event)) {
+            return true;
+        }
+        return onKeyShortcut(event.getKeyCode(), event);
+    }
+
+    /**
+     * Called to process touch screen events.  You can override this to
+     * intercept all touch screen events before they are dispatched to the
+     * window.  Be sure to call this implementation for touch screen events
+     * that should be handled normally.
+     * 
+     * @param ev The touch screen event.
+     * 
+     * @return boolean Return true if this event was consumed.
+     */
+    public boolean dispatchTouchEvent(MotionEvent ev) {
+        if (mWindow.superDispatchTouchEvent(ev)) {
+            return true;
+        }
+        return onTouchEvent(ev);
+    }
+    
+    /**
+     * Called to process trackball events.  You can override this to
+     * intercept all trackball events before they are dispatched to the
+     * window.  Be sure to call this implementation for trackball events
+     * that should be handled normally.
+     * 
+     * @param ev The trackball event.
+     * 
+     * @return boolean Return true if this event was consumed.
+     */
+    public boolean dispatchTrackballEvent(MotionEvent ev) {
+        if (mWindow.superDispatchTrackballEvent(ev)) {
+            return true;
+        }
+        return onTrackballEvent(ev);
+    }
+
+    /**
+     * Called to process generic motion events.  You can override this to
+     * intercept all generic motion events before they are dispatched to the
+     * window.  Be sure to call this implementation for generic motion events
+     * that should be handled normally.
+     *
+     * @param ev The generic motion event.
+     *
+     * @return boolean Return true if this event was consumed.
+     */
+    public boolean dispatchGenericMotionEvent(MotionEvent ev) {
+        if (mWindow.superDispatchGenericMotionEvent(ev)) {
+            return true;
+        }
+        return onGenericMotionEvent(ev);
+    }
+
+    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
+        event.setClassName(getClass().getName());
+        event.setPackageName(mContext.getPackageName());
+
+        LayoutParams params = getWindow().getAttributes();
+        boolean isFullScreen = (params.width == LayoutParams.MATCH_PARENT) &&
+            (params.height == LayoutParams.MATCH_PARENT);
+        event.setFullScreen(isFullScreen);
+
+        return false;
+    }
+
+    /**
+     * @see Activity#onCreatePanelView(int)
+     */
+    public View onCreatePanelView(int featureId) {
+        return null;
+    }
+
+    /**
+     * @see Activity#onCreatePanelMenu(int, Menu)
+     */
+    public boolean onCreatePanelMenu(int featureId, Menu menu) {
+        if (featureId == Window.FEATURE_OPTIONS_PANEL) {
+            return onCreateOptionsMenu(menu);
+        }
+        
+        return false;
+    }
+
+    /**
+     * @see Activity#onPreparePanel(int, View, Menu)
+     */
+    public boolean onPreparePanel(int featureId, View view, Menu menu) {
+        if (featureId == Window.FEATURE_OPTIONS_PANEL && menu != null) {
+            boolean goforit = onPrepareOptionsMenu(menu);
+            return goforit && menu.hasVisibleItems();
+        }
+        return true;
+    }
+
+    /**
+     * @see Activity#onMenuOpened(int, Menu)
+     */
+    public boolean onMenuOpened(int featureId, Menu menu) {
+        if (featureId == Window.FEATURE_ACTION_BAR) {
+            mActionBar.dispatchMenuVisibilityChanged(true);
+        }
+        return true;
+    }
+
+    /**
+     * @see Activity#onMenuItemSelected(int, MenuItem)
+     */
+    public boolean onMenuItemSelected(int featureId, MenuItem item) {
+        return false;
+    }
+
+    /**
+     * @see Activity#onPanelClosed(int, Menu)
+     */
+    public void onPanelClosed(int featureId, Menu menu) {
+        if (featureId == Window.FEATURE_ACTION_BAR) {
+            mActionBar.dispatchMenuVisibilityChanged(false);
+        }
+    }
+
+    /**
+     * It is usually safe to proxy this call to the owner activity's
+     * {@link Activity#onCreateOptionsMenu(Menu)} if the client desires the same
+     * menu for this Dialog.
+     * 
+     * @see Activity#onCreateOptionsMenu(Menu)
+     * @see #getOwnerActivity()
+     */
+    public boolean onCreateOptionsMenu(Menu menu) {
+        return true;
+    }
+
+    /**
+     * It is usually safe to proxy this call to the owner activity's
+     * {@link Activity#onPrepareOptionsMenu(Menu)} if the client desires the
+     * same menu for this Dialog.
+     * 
+     * @see Activity#onPrepareOptionsMenu(Menu)
+     * @see #getOwnerActivity()
+     */
+    public boolean onPrepareOptionsMenu(Menu menu) {
+        return true;
+    }
+
+    /**
+     * @see Activity#onOptionsItemSelected(MenuItem)
+     */
+    public boolean onOptionsItemSelected(MenuItem item) {
+        return false;
+    }
+
+    /**
+     * @see Activity#onOptionsMenuClosed(Menu)
+     */
+    public void onOptionsMenuClosed(Menu menu) {
+    }
+
+    /**
+     * @see Activity#openOptionsMenu()
+     */
+    public void openOptionsMenu() {
+        mWindow.openPanel(Window.FEATURE_OPTIONS_PANEL, null);
+    }
+    
+    /**
+     * @see Activity#closeOptionsMenu()
+     */
+    public void closeOptionsMenu() {
+        mWindow.closePanel(Window.FEATURE_OPTIONS_PANEL);
+    }
+
+    /**
+     * @see Activity#invalidateOptionsMenu()
+     */
+    public void invalidateOptionsMenu() {
+        mWindow.invalidatePanelMenu(Window.FEATURE_OPTIONS_PANEL);
+    }
+
+    /**
+     * @see Activity#onCreateContextMenu(ContextMenu, View, ContextMenuInfo)
+     */
+    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
+    }
+
+    /**
+     * @see Activity#registerForContextMenu(View)
+     */
+    public void registerForContextMenu(View view) {
+        view.setOnCreateContextMenuListener(this);
+    }
+    
+    /**
+     * @see Activity#unregisterForContextMenu(View)
+     */
+    public void unregisterForContextMenu(View view) {
+        view.setOnCreateContextMenuListener(null);
+    }
+    
+    /**
+     * @see Activity#openContextMenu(View)
+     */
+    public void openContextMenu(View view) {
+        view.showContextMenu();
+    }
+
+    /**
+     * @see Activity#onContextItemSelected(MenuItem)
+     */
+    public boolean onContextItemSelected(MenuItem item) {
+        return false;
+    }
+    
+    /**
+     * @see Activity#onContextMenuClosed(Menu)
+     */
+    public void onContextMenuClosed(Menu menu) {
+    }
+    
+    /**
+     * This hook is called when the user signals the desire to start a search.
+     */
+    public boolean onSearchRequested() {
+        final SearchManager searchManager = (SearchManager) mContext
+                .getSystemService(Context.SEARCH_SERVICE);
+
+        // associate search with owner activity
+        final ComponentName appName = getAssociatedActivity();
+        if (appName != null && searchManager.getSearchableInfo(appName) != null) {
+            searchManager.startSearch(null, false, appName, null, false);
+            dismiss();
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public ActionMode onWindowStartingActionMode(ActionMode.Callback callback) {
+        if (mActionBar != null) {
+            return mActionBar.startActionMode(callback);
+        }
+        return null;
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * Note that if you override this method you should always call through
+     * to the superclass implementation by calling super.onActionModeStarted(mode).
+     */
+    public void onActionModeStarted(ActionMode mode) {
+        mActionMode = mode;
+    }
+
+    /**
+     * {@inheritDoc}
+     *
+     * Note that if you override this method you should always call through
+     * to the superclass implementation by calling super.onActionModeFinished(mode).
+     */
+    public void onActionModeFinished(ActionMode mode) {
+        if (mode == mActionMode) {
+            mActionMode = null;
+        }
+    }
+
+    /**
+     * @return The activity associated with this dialog, or null if there is no associated activity.
+     */
+    private ComponentName getAssociatedActivity() {
+        Activity activity = mOwnerActivity;
+        Context context = getContext();
+        while (activity == null && context != null) {
+            if (context instanceof Activity) {
+                activity = (Activity) context;  // found it!
+            } else {
+                context = (context instanceof ContextWrapper) ?
+                        ((ContextWrapper) context).getBaseContext() : // unwrap one level
+                        null;                                         // done
+            }
+        }
+        return activity == null ? null : activity.getComponentName();
+    }
+
+
+    /**
+     * Request that key events come to this dialog. Use this if your
+     * dialog has no views with focus, but the dialog still wants
+     * a chance to process key events.
+     * 
+     * @param get true if the dialog should receive key events, false otherwise
+     * @see android.view.Window#takeKeyEvents
+     */
+    public void takeKeyEvents(boolean get) {
+        mWindow.takeKeyEvents(get);
+    }
+
+    /**
+     * Enable extended window features.  This is a convenience for calling
+     * {@link android.view.Window#requestFeature getWindow().requestFeature()}.
+     * 
+     * @param featureId The desired feature as defined in
+     *                  {@link android.view.Window}.
+     * @return Returns true if the requested feature is supported and now
+     *         enabled.
+     * 
+     * @see android.view.Window#requestFeature
+     */
+    public final boolean requestWindowFeature(int featureId) {
+        return getWindow().requestFeature(featureId);
+    }
+
+    /**
+     * Convenience for calling
+     * {@link android.view.Window#setFeatureDrawableResource}.
+     */
+    public final void setFeatureDrawableResource(int featureId, int resId) {
+        getWindow().setFeatureDrawableResource(featureId, resId);
+    }
+
+    /**
+     * Convenience for calling
+     * {@link android.view.Window#setFeatureDrawableUri}.
+     */
+    public final void setFeatureDrawableUri(int featureId, Uri uri) {
+        getWindow().setFeatureDrawableUri(featureId, uri);
+    }
+
+    /**
+     * Convenience for calling
+     * {@link android.view.Window#setFeatureDrawable(int, Drawable)}.
+     */
+    public final void setFeatureDrawable(int featureId, Drawable drawable) {
+        getWindow().setFeatureDrawable(featureId, drawable);
+    }
+
+    /**
+     * Convenience for calling
+     * {@link android.view.Window#setFeatureDrawableAlpha}.
+     */
+    public final void setFeatureDrawableAlpha(int featureId, int alpha) {
+        getWindow().setFeatureDrawableAlpha(featureId, alpha);
+    }
+
+    public LayoutInflater getLayoutInflater() {
+        return getWindow().getLayoutInflater();
+    }
+
+    /**
+     * Sets whether this dialog is cancelable with the
+     * {@link KeyEvent#KEYCODE_BACK BACK} key.
+     */
+    public void setCancelable(boolean flag) {
+        mCancelable = flag;
+    }
+
+    /**
+     * Sets whether this dialog is canceled when touched outside the window's
+     * bounds. If setting to true, the dialog is set to be cancelable if not
+     * already set.
+     * 
+     * @param cancel Whether the dialog should be canceled when touched outside
+     *            the window.
+     */
+    public void setCanceledOnTouchOutside(boolean cancel) {
+        if (cancel && !mCancelable) {
+            mCancelable = true;
+        }
+        
+        mWindow.setCloseOnTouchOutside(cancel);
+    }
+    
+    /**
+     * Cancel the dialog.  This is essentially the same as calling {@link #dismiss()}, but it will
+     * also call your {@link DialogInterface.OnCancelListener} (if registered).
+     */
+    public void cancel() {
+        if (!mCanceled && mCancelMessage != null) {
+            mCanceled = true;
+            // Obtain a new message so this dialog can be re-used
+            Message.obtain(mCancelMessage).sendToTarget();
+        }
+        dismiss();
+    }
+
+    /**
+     * Set a listener to be invoked when the dialog is canceled.
+     * <p>
+     * This will only be invoked when the dialog is canceled, if the creator
+     * needs to know when it is dismissed in general, use
+     * {@link #setOnDismissListener}.
+     * 
+     * @param listener The {@link DialogInterface.OnCancelListener} to use.
+     */
+    public void setOnCancelListener(final OnCancelListener listener) {
+        if (mCancelAndDismissTaken != null) {
+            throw new IllegalStateException(
+                    "OnCancelListener is already taken by "
+                    + mCancelAndDismissTaken + " and can not be replaced.");
+        }
+        if (listener != null) {
+            mCancelMessage = mListenersHandler.obtainMessage(CANCEL, listener);
+        } else {
+            mCancelMessage = null;
+        }
+    }
+
+    /**
+     * Set a message to be sent when the dialog is canceled.
+     * @param msg The msg to send when the dialog is canceled.
+     * @see #setOnCancelListener(android.content.DialogInterface.OnCancelListener)
+     */
+    public void setCancelMessage(final Message msg) {
+        mCancelMessage = msg;
+    }
+
+    /**
+     * Set a listener to be invoked when the dialog is dismissed.
+     * @param listener The {@link DialogInterface.OnDismissListener} to use.
+     */
+    public void setOnDismissListener(final OnDismissListener listener) {
+        if (mCancelAndDismissTaken != null) {
+            throw new IllegalStateException(
+                    "OnDismissListener is already taken by "
+                    + mCancelAndDismissTaken + " and can not be replaced.");
+        }
+        if (listener != null) {
+            mDismissMessage = mListenersHandler.obtainMessage(DISMISS, listener);
+        } else {
+            mDismissMessage = null;
+        }
+    }
+
+    /**
+     * Sets a listener to be invoked when the dialog is shown.
+     * @param listener The {@link DialogInterface.OnShowListener} to use.
+     */
+    public void setOnShowListener(OnShowListener listener) {
+        if (listener != null) {
+            mShowMessage = mListenersHandler.obtainMessage(SHOW, listener);
+        } else {
+            mShowMessage = null;
+        }
+    }
+
+    /**
+     * Set a message to be sent when the dialog is dismissed.
+     * @param msg The msg to send when the dialog is dismissed.
+     */
+    public void setDismissMessage(final Message msg) {
+        mDismissMessage = msg;
+    }
+
+    /** @hide */
+    public boolean takeCancelAndDismissListeners(String msg, final OnCancelListener cancel,
+            final OnDismissListener dismiss) {
+        if (mCancelAndDismissTaken != null) {
+            mCancelAndDismissTaken = null;
+        } else if (mCancelMessage != null || mDismissMessage != null) {
+            return false;
+        }
+        
+        setOnCancelListener(cancel);
+        setOnDismissListener(dismiss);
+        mCancelAndDismissTaken = msg;
+        
+        return true;
+    }
+    
+    /**
+     * By default, this will use the owner Activity's suggested stream type.
+     * 
+     * @see Activity#setVolumeControlStream(int)
+     * @see #setOwnerActivity(Activity)
+     */
+    public final void setVolumeControlStream(int streamType) {
+        getWindow().setVolumeControlStream(streamType);
+    }
+
+    /**
+     * @see Activity#getVolumeControlStream()
+     */
+    public final int getVolumeControlStream() {
+        return getWindow().getVolumeControlStream();
+    }
+    
+    /**
+     * Sets the callback that will be called if a key is dispatched to the dialog.
+     */
+    public void setOnKeyListener(final OnKeyListener onKeyListener) {
+        mOnKeyListener = onKeyListener;
+    }
+
+    private static final class ListenersHandler extends Handler {
+        private WeakReference<DialogInterface> mDialog;
+
+        public ListenersHandler(Dialog dialog) {
+            mDialog = new WeakReference<DialogInterface>(dialog);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case DISMISS:
+                    ((OnDismissListener) msg.obj).onDismiss(mDialog.get());
+                    break;
+                case CANCEL:
+                    ((OnCancelListener) msg.obj).onCancel(mDialog.get());
+                    break;
+                case SHOW:
+                    ((OnShowListener) msg.obj).onShow(mDialog.get());
+                    break;
+            }
+        }
+    }
+}
diff --git a/src/frameworks/base/core/java/android/app/ListActivity.java b/src/frameworks/base/core/java/android/app/ListActivity.java
deleted file mode 100644
index 2162521..0000000
--- a/src/frameworks/base/core/java/android/app/ListActivity.java
+++ /dev/null
@@ -1,322 +0,0 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.app;
-
-import android.os.Bundle;
-import android.os.Handler;
-import android.view.View;
-import android.widget.AdapterView;
-import android.widget.ListAdapter;
-import android.widget.ListView;
-
-/**
- * An activity that displays a list of items by binding to a data source such as
- * an array or Cursor, and exposes event handlers when the user selects an item.
- * <p>
- * ListActivity hosts a {@link android.widget.ListView ListView} object that can
- * be bound to different data sources, typically either an array or a Cursor
- * holding query results. Binding, screen layout, and row layout are discussed
- * in the following sections.
- * <p>
- * <strong>Screen Layout</strong>
- * </p>
- * <p>
- * ListActivity has a default layout that consists of a single, full-screen list
- * in the center of the screen. However, if you desire, you can customize the
- * screen layout by setting your own view layout with setContentView() in
- * onCreate(). To do this, your own view MUST contain a ListView object with the
- * id "@android:id/list" (or {@link android.R.id#list} if it's in code)
- * <p>
- * Optionally, your custom view can contain another view object of any type to
- * display when the list view is empty. This "empty list" notifier must have an
- * id "android:id/empty". Note that when an empty view is present, the list view
- * will be hidden when there is no data to display.
- * <p>
- * The following code demonstrates an (ugly) custom screen layout. It has a list
- * with a green background, and an alternate red "no data" message.
- * </p>
- *
- * <pre>
- * &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
- * &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
- *         android:orientation=&quot;vertical&quot;
- *         android:layout_width=&quot;match_parent&quot;
- *         android:layout_height=&quot;match_parent&quot;
- *         android:paddingLeft=&quot;8dp&quot;
- *         android:paddingRight=&quot;8dp&quot;&gt;
- *
- *     &lt;ListView android:id=&quot;@android:id/list&quot;
- *               android:layout_width=&quot;match_parent&quot;
- *               android:layout_height=&quot;match_parent&quot;
- *               android:background=&quot;#00FF00&quot;
- *               android:layout_weight=&quot;1&quot;
- *               android:drawSelectorOnTop=&quot;false&quot;/&gt;
- *
- *     &lt;TextView android:id=&quot;@android:id/empty&quot;
- *               android:layout_width=&quot;match_parent&quot;
- *               android:layout_height=&quot;match_parent&quot;
- *               android:background=&quot;#FF0000&quot;
- *               android:text=&quot;No data&quot;/&gt;
- * &lt;/LinearLayout&gt;
- * </pre>
- *
- * <p>
- * <strong>Row Layout</strong>
- * </p>
- * <p>
- * You can specify the layout of individual rows in the list. You do this by
- * specifying a layout resource in the ListAdapter object hosted by the activity
- * (the ListAdapter binds the ListView to the data; more on this later).
- * <p>
- * A ListAdapter constructor takes a parameter that specifies a layout resource
- * for each row. It also has two additional parameters that let you specify
- * which data field to associate with which object in the row layout resource.
- * These two parameters are typically parallel arrays.
- * </p>
- * <p>
- * Android provides some standard row layout resources. These are in the
- * {@link android.R.layout} class, and have names such as simple_list_item_1,
- * simple_list_item_2, and two_line_list_item. The following layout XML is the
- * source for the resource two_line_list_item, which displays two data
- * fields,one above the other, for each list row.
- * </p>
- *
- * <pre>
- * &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
- * &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
- *     android:layout_width=&quot;match_parent&quot;
- *     android:layout_height=&quot;wrap_content&quot;
- *     android:orientation=&quot;vertical&quot;&gt;
- *
- *     &lt;TextView android:id=&quot;@+id/text1&quot;
- *         android:textSize=&quot;16sp&quot;
- *         android:textStyle=&quot;bold&quot;
- *         android:layout_width=&quot;match_parent&quot;
- *         android:layout_height=&quot;wrap_content&quot;/&gt;
- *
- *     &lt;TextView android:id=&quot;@+id/text2&quot;
- *         android:textSize=&quot;16sp&quot;
- *         android:layout_width=&quot;match_parent&quot;
- *         android:layout_height=&quot;wrap_content&quot;/&gt;
- * &lt;/LinearLayout&gt;
- * </pre>
- *
- * <p>
- * You must identify the data bound to each TextView object in this layout. The
- * syntax for this is discussed in the next section.
- * </p>
- * <p>
- * <strong>Binding to Data</strong>
- * </p>
- * <p>
- * You bind the ListActivity's ListView object to data using a class that
- * implements the {@link android.widget.ListAdapter ListAdapter} interface.
- * Android provides two standard list adapters:
- * {@link android.widget.SimpleAdapter SimpleAdapter} for static data (Maps),
- * and {@link android.widget.SimpleCursorAdapter SimpleCursorAdapter} for Cursor
- * query results.
- * </p>
- * <p>
- * The following code from a custom ListActivity demonstrates querying the
- * Contacts provider for all contacts, then binding the Name and Company fields
- * to a two line row layout in the activity's ListView.
- * </p>
- *
- * <pre>
- * public class MyListAdapter extends ListActivity {
- *
- *     &#064;Override
- *     protected void onCreate(Bundle savedInstanceState){
- *         super.onCreate(savedInstanceState);
- *
- *         // We'll define a custom screen layout here (the one shown above), but
- *         // typically, you could just use the standard ListActivity layout.
- *         setContentView(R.layout.custom_list_activity_view);
- *
- *         // Query for all people contacts using the {@link android.provider.Contacts.People} convenience class.
- *         // Put a managed wrapper around the retrieved cursor so we don't have to worry about
- *         // requerying or closing it as the activity changes state.
- *         mCursor = this.getContentResolver().query(People.CONTENT_URI, null, null, null, null);
- *         startManagingCursor(mCursor);
- *
- *         // Now create a new list adapter bound to the cursor.
- *         // SimpleListAdapter is designed for binding to a Cursor.
- *         ListAdapter adapter = new SimpleCursorAdapter(
- *                 this, // Context.
- *                 android.R.layout.two_line_list_item,  // Specify the row template to use (here, two columns bound to the two retrieved cursor
- * rows).
- *                 mCursor,                                              // Pass in the cursor to bind to.
- *                 new String[] {People.NAME, People.COMPANY},           // Array of cursor columns to bind to.
- *                 new int[] {android.R.id.text1, android.R.id.text2});  // Parallel array of which template objects to bind to those columns.
- *
- *         // Bind to our new adapter.
- *         setListAdapter(adapter);
- *     }
- * }
- * </pre>
- *
- * @see #setListAdapter
- * @see android.widget.ListView
- */
-public class ListActivity extends Activity {
-    /**
-     * This field should be made private, so it is hidden from the SDK.
-     * {@hide}
-     */
-    protected ListAdapter mAdapter;
-    /**
-     * This field should be made private, so it is hidden from the SDK.
-     * {@hide}
-     */
-    protected ListView mList;
-
-    private Handler mHandler = new Handler();
-    private boolean mFinishedStart = false;
-
-    private Runnable mRequestFocus = new Runnable() {
-        public void run() {
-            mList.focusableViewAvailable(mList);
-        }
-    };
-
-    /**
-     * This method will be called when an item in the list is selected.
-     * Subclasses should override. Subclasses can call
-     * getListView().getItemAtPosition(position) if they need to access the
-     * data associated with the selected item.
-     *
-     * @param l The ListView where the click happened
-     * @param v The view that was clicked within the ListView
-     * @param position The position of the view in the list
-     * @param id The row id of the item that was clicked
-     */
-    protected void onListItemClick(ListView l, View v, int position, long id) {
-    }
-
-    /**
-     * Ensures the list view has been created before Activity restores all
-     * of the view states.
-     *
-     *@see Activity#onRestoreInstanceState(Bundle)
-     */
-    @Override
-    protected void onRestoreInstanceState(Bundle state) {
-        ensureList();
-        super.onRestoreInstanceState(state);
-    }
-
-    /**
-     * @see Activity#onDestroy()
-     */
-    @Override
-    protected void onDestroy() {
-        mHandler.removeCallbacks(mRequestFocus);
-        super.onDestroy();
-    }
-
-    /**
-     * Updates the screen state (current list and other views) when the
-     * content changes.
-     *
-     * @see Activity#onContentChanged()
-     */
-    @Override
-    public void onContentChanged() {
-        super.onContentChanged();
-        View emptyView = findViewById(com.android.internal.R.id.empty);
-        mList = (ListView)findViewById(com.android.internal.R.id.list);
-        if (mList == null) {
-            throw new RuntimeException(
-                    "Your content must have a ListView whose id attribute is " +
-                    "'android.R.id.list'");
-        }
-        if (emptyView != null) {
-            mList.setEmptyView(emptyView);
-        }
-        mList.setOnItemClickListener(mOnClickListener);
-        if (mFinishedStart) {
-            setListAdapter(mAdapter);
-        }
-        mHandler.post(mRequestFocus);
-        mFinishedStart = true;
-    }
-
-    /**
-     * Provide the cursor for the list view.
-     */
-    public void setListAdapter(ListAdapter adapter) {
-        synchronized (this) {
-            ensureList();
-            mAdapter = adapter;
-            mList.setAdapter(adapter);
-        }
-    }
-
-    /**
-     * Set the currently selected list item to the specified
-     * position with the adapter's data
-     *
-     * @param position
-     */
-    public void setSelection(int position) {
-        mList.setSelection(position);
-    }
-
-    /**
-     * Get the position of the currently selected list item.
-     */
-    public int getSelectedItemPosition() {
-        return mList.getSelectedItemPosition();
-    }
-
-    /**
-     * Get the cursor row ID of the currently selected list item.
-     */
-    public long getSelectedItemId() {
-        return mList.getSelectedItemId();
-    }
-
-    /**
-     * Get the activity's list view widget.
-     */
-    public ListView getListView() {
-        ensureList();
-        return mList;
-    }
-
-    /**
-     * Get the ListAdapter associated with this activity's ListView.
-     */
-    public ListAdapter getListAdapter() {
-        return mAdapter;
-    }
-
-    private void ensureList() {
-        if (mList != null) {
-            return;
-        }
-        setContentView(com.android.internal.R.layout.list_content_simple);
-
-    }
-
-    private AdapterView.OnItemClickListener mOnClickListener = new AdapterView.OnItemClickListener() {
-        public void onItemClick(AdapterView<?> parent, View v, int position, long id)
-        {
-            onListItemClick((ListView)parent, v, position, id);
-        }
-    };
-}
diff --git a/src/frameworks/base/core/java/android/app/ProgressDialog.java b/src/frameworks/base/core/java/android/app/ProgressDialog.java
new file mode 100644
index 0000000..7f1f385
--- /dev/null
+++ b/src/frameworks/base/core/java/android/app/ProgressDialog.java
@@ -0,0 +1,360 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+import com.android.internal.R;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.drawable.Drawable;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.text.Spannable;
+import android.text.SpannableString;
+import android.text.style.StyleSpan;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.widget.ProgressBar;
+import android.widget.TextView;
+
+import java.text.NumberFormat;
+
+/**
+ * <p>A dialog showing a progress indicator and an optional text message or view.
+ * Only a text message or a view can be used at the same time.</p>
+ * <p>The dialog can be made cancelable on back key press.</p>
+ * <p>The progress range is 0..10000.</p>
+ */
+public class ProgressDialog extends AlertDialog {
+    
+    /** Creates a ProgressDialog with a circular, spinning progress
+     * bar. This is the default.
+     */
+    public static final int STYLE_SPINNER = 0;
+    
+    /** Creates a ProgressDialog with a horizontal progress bar.
+     */
+    public static final int STYLE_HORIZONTAL = 1;
+    
+    private ProgressBar mProgress;
+    private TextView mMessageView;
+    
+    private int mProgressStyle = STYLE_SPINNER;
+    private TextView mProgressNumber;
+    private String mProgressNumberFormat;
+    private TextView mProgressPercent;
+    private NumberFormat mProgressPercentFormat;
+    
+    private int mMax;
+    private int mProgressVal;
+    private int mSecondaryProgressVal;
+    private int mIncrementBy;
+    private int mIncrementSecondaryBy;
+    private Drawable mProgressDrawable;
+    private Drawable mIndeterminateDrawable;
+    private CharSequence mMessage;
+    private boolean mIndeterminate;
+    
+    private boolean mHasStarted;
+    private Handler mViewUpdateHandler;
+    
+    public ProgressDialog(Context context) {
+        super(context);
+        initFormats();
+    }
+
+    public ProgressDialog(Context context, int theme) {
+        super(context, theme);
+        initFormats();
+    }
+
+    private void initFormats() {
+        mProgressNumberFormat = "%1d/%2d";
+        mProgressPercentFormat = NumberFormat.getPercentInstance();
+        mProgressPercentFormat.setMaximumFractionDigits(0);
+    }
+    
+    public static ProgressDialog show(Context context, CharSequence title,
+            CharSequence message) {
+        return show(context, title, message, false);
+    }
+
+    public static ProgressDialog show(Context context, CharSequence title,
+            CharSequence message, boolean indeterminate) {
+        return show(context, title, message, indeterminate, false, null);
+    }
+
+    public static ProgressDialog show(Context context, CharSequence title,
+            CharSequence message, boolean indeterminate, boolean cancelable) {
+        return show(context, title, message, indeterminate, cancelable, null);
+    }
+
+    public static ProgressDialog show(Context context, CharSequence title,
+            CharSequence message, boolean indeterminate,
+            boolean cancelable, OnCancelListener cancelListener) {
+        ProgressDialog dialog = new ProgressDialog(context);
+        dialog.setTitle(title);
+        dialog.setMessage(message);
+        dialog.setIndeterminate(indeterminate);
+        dialog.setCancelable(cancelable);
+        dialog.setOnCancelListener(cancelListener);
+        dialog.show();
+        return dialog;
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        LayoutInflater inflater = LayoutInflater.from(mContext);
+        TypedArray a = mContext.obtainStyledAttributes(null,
+                com.android.internal.R.styleable.AlertDialog,
+                com.android.internal.R.attr.alertDialogStyle, 0);
+        if (mProgressStyle == STYLE_HORIZONTAL) {
+            
+            /* Use a separate handler to update the text views as they
+             * must be updated on the same thread that created them.
+             */
+            mViewUpdateHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    super.handleMessage(msg);
+                    
+                    /* Update the number and percent */
+                    int progress = mProgress.getProgress();
+                    int max = mProgress.getMax();
+                    if (mProgressNumberFormat != null) {
+                        String format = mProgressNumberFormat;
+                        mProgressNumber.setText(String.format(format, progress, max));
+                    } else {
+                        mProgressNumber.setText("");
+                    }
+                    if (mProgressPercentFormat != null) {
+                        double percent = (double) progress / (double) max;
+                        SpannableString tmp = new SpannableString(mProgressPercentFormat.format(percent));
+                        tmp.setSpan(new StyleSpan(android.graphics.Typeface.BOLD),
+                                0, tmp.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
+                        mProgressPercent.setText(tmp);
+                    } else {
+                        mProgressPercent.setText("");
+                    }
+                }
+            };
+            View view = inflater.inflate(a.getResourceId(
+                    com.android.internal.R.styleable.AlertDialog_horizontalProgressLayout,
+                    R.layout.alert_dialog_progress), null);
+            mProgress = (ProgressBar) view.findViewById(R.id.progress);
+            mProgressNumber = (TextView) view.findViewById(R.id.progress_number);
+            mProgressPercent = (TextView) view.findViewById(R.id.progress_percent);
+            setView(view);
+        } else {
+            View view = inflater.inflate(a.getResourceId(
+                    com.android.internal.R.styleable.AlertDialog_progressLayout,
+                    R.layout.progress_dialog), null);
+            mProgress = (ProgressBar) view.findViewById(R.id.progress);
+            mMessageView = (TextView) view.findViewById(R.id.message);
+            setView(view);
+        }
+        a.recycle();
+        if (mMax > 0) {
+            setMax(mMax);
+        }
+        if (mProgressVal > 0) {
+            setProgress(mProgressVal);
+        }
+        if (mSecondaryProgressVal > 0) {
+            setSecondaryProgress(mSecondaryProgressVal);
+        }
+        if (mIncrementBy > 0) {
+            incrementProgressBy(mIncrementBy);
+        }
+        if (mIncrementSecondaryBy > 0) {
+            incrementSecondaryProgressBy(mIncrementSecondaryBy);
+        }
+        if (mProgressDrawable != null) {
+            setProgressDrawable(mProgressDrawable);
+        }
+        if (mIndeterminateDrawable != null) {
+            setIndeterminateDrawable(mIndeterminateDrawable);
+        }
+        if (mMessage != null) {
+            setMessage(mMessage);
+        }
+        setIndeterminate(mIndeterminate);
+        onProgressChanged();
+        super.onCreate(savedInstanceState);
+    }
+    
+    @Override
+    public void onStart() {
+        super.onStart();
+        mHasStarted = true;
+    }
+    
+    @Override
+    protected void onStop() {
+        super.onStop();
+        mHasStarted = false;
+    }
+
+    public void setProgress(int value) {
+        if (mHasStarted) {
+            mProgress.setProgress(value);
+            onProgressChanged();
+        } else {
+            mProgressVal = value;
+        }
+    }
+
+    public void setSecondaryProgress(int secondaryProgress) {
+        if (mProgress != null) {
+            mProgress.setSecondaryProgress(secondaryProgress);
+            onProgressChanged();
+        } else {
+            mSecondaryProgressVal = secondaryProgress;
+        }
+    }
+
+    public int getProgress() {
+        if (mProgress != null) {
+            return mProgress.getProgress();
+        }
+        return mProgressVal;
+    }
+
+    public int getSecondaryProgress() {
+        if (mProgress != null) {
+            return mProgress.getSecondaryProgress();
+        }
+        return mSecondaryProgressVal;
+    }
+
+    public int getMax() {
+        if (mProgress != null) {
+            return mProgress.getMax();
+        }
+        return mMax;
+    }
+
+    public void setMax(int max) {
+        if (mProgress != null) {
+            mProgress.setMax(max);
+            onProgressChanged();
+        } else {
+            mMax = max;
+        }
+    }
+
+    public void incrementProgressBy(int diff) {
+        if (mProgress != null) {
+            mProgress.incrementProgressBy(diff);
+            onProgressChanged();
+        } else {
+            mIncrementBy += diff;
+        }
+    }
+
+    public void incrementSecondaryProgressBy(int diff) {
+        if (mProgress != null) {
+            mProgress.incrementSecondaryProgressBy(diff);
+            onProgressChanged();
+        } else {
+            mIncrementSecondaryBy += diff;
+        }
+    }
+
+    public void setProgressDrawable(Drawable d) {
+        if (mProgress != null) {
+            mProgress.setProgressDrawable(d);
+        } else {
+            mProgressDrawable = d;
+        }
+    }
+
+    public void setIndeterminateDrawable(Drawable d) {
+        if (mProgress != null) {
+            mProgress.setIndeterminateDrawable(d);
+        } else {
+            mIndeterminateDrawable = d;
+        }
+    }
+
+    public void setIndeterminate(boolean indeterminate) {
+        if (mProgress != null) {
+            mProgress.setIndeterminate(indeterminate);
+        } else {
+            mIndeterminate = indeterminate;
+        }
+    }
+
+    public boolean isIndeterminate() {
+        if (mProgress != null) {
+            return mProgress.isIndeterminate();
+        }
+        return mIndeterminate;
+    }
+    
+    @Override
+    public void setMessage(CharSequence message) {
+        if (mProgress != null) {
+            if (mProgressStyle == STYLE_HORIZONTAL) {
+                super.setMessage(message);
+            } else {
+                mMessageView.setText(message);
+            }
+        } else {
+            mMessage = message;
+        }
+    }
+    
+    public void setProgressStyle(int style) {
+        mProgressStyle = style;
+    }
+
+    /**
+     * Change the format of the small text showing current and maximum units
+     * of progress.  The default is "%1d/%2d".
+     * Should not be called during the number is progressing.
+     * @param format A string passed to {@link String#format String.format()};
+     * use "%1d" for the current number and "%2d" for the maximum.  If null,
+     * nothing will be shown.
+     */
+    public void setProgressNumberFormat(String format) {
+        mProgressNumberFormat = format;
+        onProgressChanged();
+    }
+
+    /**
+     * Change the format of the small text showing the percentage of progress.
+     * The default is
+     * {@link NumberFormat#getPercentInstance() NumberFormat.getPercentageInstnace().}
+     * Should not be called during the number is progressing.
+     * @param format An instance of a {@link NumberFormat} to generate the
+     * percentage text.  If null, nothing will be shown.
+     */
+    public void setProgressPercentFormat(NumberFormat format) {
+        mProgressPercentFormat = format;
+        onProgressChanged();
+    }
+    
+    private void onProgressChanged() {
+        if (mProgressStyle == STYLE_HORIZONTAL) {
+            if (mViewUpdateHandler != null && !mViewUpdateHandler.hasMessages(0)) {
+                mViewUpdateHandler.sendEmptyMessage(0);
+            }
+        }
+    }
+}
diff --git a/src/frameworks/base/core/java/android/app/SearchDialog.java b/src/frameworks/base/core/java/android/app/SearchDialog.java
new file mode 100644
index 0000000..d04e9db
--- /dev/null
+++ b/src/frameworks/base/core/java/android/app/SearchDialog.java
@@ -0,0 +1,717 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.res.Configuration;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.os.Bundle;
+import android.speech.RecognizerIntent;
+import android.text.InputType;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.util.TypedValue;
+import android.view.ActionMode;
+import android.view.Gravity;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewConfiguration;
+import android.view.ViewGroup;
+import android.view.Window;
+import android.view.WindowManager;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.AutoCompleteTextView;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.SearchView;
+import android.widget.TextView;
+
+/**
+ * Search dialog. This is controlled by the 
+ * SearchManager and runs in the current foreground process.
+ * 
+ * @hide
+ */
+public class SearchDialog extends Dialog {
+
+    // Debugging support
+    private static final boolean DBG = false;
+    private static final String LOG_TAG = "SearchDialog";
+
+    private static final String INSTANCE_KEY_COMPONENT = "comp";
+    private static final String INSTANCE_KEY_APPDATA = "data";
+    private static final String INSTANCE_KEY_USER_QUERY = "uQry";
+
+    // The string used for privateImeOptions to identify to the IME that it should not show
+    // a microphone button since one already exists in the search dialog.
+    private static final String IME_OPTION_NO_MICROPHONE = "nm";
+
+    private static final int SEARCH_PLATE_LEFT_PADDING_NON_GLOBAL = 7;
+
+    // views & widgets
+    private TextView mBadgeLabel;
+    private ImageView mAppIcon;
+    private AutoCompleteTextView mSearchAutoComplete;
+    private View mSearchPlate;
+    private SearchView mSearchView;
+    private Drawable mWorkingSpinner;
+    private View mCloseSearch;
+
+    // interaction with searchable application
+    private SearchableInfo mSearchable;
+    private ComponentName mLaunchComponent;
+    private Bundle mAppSearchData;
+    private Context mActivityContext;
+
+    // For voice searching
+    private final Intent mVoiceWebSearchIntent;
+    private final Intent mVoiceAppSearchIntent;
+
+    // The query entered by the user. This is not changed when selecting a suggestion
+    // that modifies the contents of the text field. But if the user then edits
+    // the suggestion, the resulting string is saved.
+    private String mUserQuery;
+
+    // Last known IME options value for the search edit text.
+    private int mSearchAutoCompleteImeOptions;
+
+    private BroadcastReceiver mConfChangeListener = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (intent.getAction().equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
+                onConfigurationChanged();
+            }
+        }
+    };
+
+    static int resolveDialogTheme(Context context) {
+        TypedValue outValue = new TypedValue();
+        context.getTheme().resolveAttribute(com.android.internal.R.attr.searchDialogTheme,
+                outValue, true);
+        return outValue.resourceId;
+    }
+
+    /**
+     * Constructor - fires it up and makes it look like the search UI.
+     * 
+     * @param context Application Context we can use for system acess
+     */
+    public SearchDialog(Context context, SearchManager searchManager) {
+        super(context, resolveDialogTheme(context));
+
+        // Save voice intent for later queries/launching
+        mVoiceWebSearchIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
+        mVoiceWebSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        mVoiceWebSearchIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,
+                RecognizerIntent.LANGUAGE_MODEL_WEB_SEARCH);
+
+        mVoiceAppSearchIntent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
+        mVoiceAppSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+    }
+
+    /**
+     * Create the search dialog and any resources that are used for the
+     * entire lifetime of the dialog.
+     */
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        Window theWindow = getWindow();
+        WindowManager.LayoutParams lp = theWindow.getAttributes();
+        lp.width = ViewGroup.LayoutParams.MATCH_PARENT;
+        // taking up the whole window (even when transparent) is less than ideal,
+        // but necessary to show the popup window until the window manager supports
+        // having windows anchored by their parent but not clipped by them.
+        lp.height = ViewGroup.LayoutParams.MATCH_PARENT;
+        lp.gravity = Gravity.TOP | Gravity.FILL_HORIZONTAL;
+        lp.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
+        theWindow.setAttributes(lp);
+
+        // Touching outside of the search dialog will dismiss it
+        setCanceledOnTouchOutside(true);        
+    }
+
+    /**
+     * We recreate the dialog view each time it becomes visible so as to limit
+     * the scope of any problems with the contained resources.
+     */
+    private void createContentView() {
+        setContentView(com.android.internal.R.layout.search_bar);
+
+        // get the view elements for local access
+        SearchBar searchBar = (SearchBar) findViewById(com.android.internal.R.id.search_bar);
+        searchBar.setSearchDialog(this);
+        mSearchView = (SearchView) findViewById(com.android.internal.R.id.search_view);
+        mSearchView.setIconified(false);
+        mSearchView.setOnCloseListener(mOnCloseListener);
+        mSearchView.setOnQueryTextListener(mOnQueryChangeListener);
+        mSearchView.setOnSuggestionListener(mOnSuggestionSelectionListener);
+        mSearchView.onActionViewExpanded();
+
+        mCloseSearch = findViewById(com.android.internal.R.id.closeButton);
+        mCloseSearch.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                dismiss();
+            }
+        });
+
+        // TODO: Move the badge logic to SearchView or move the badge to search_bar.xml
+        mBadgeLabel = (TextView) mSearchView.findViewById(com.android.internal.R.id.search_badge);
+        mSearchAutoComplete = (AutoCompleteTextView)
+                mSearchView.findViewById(com.android.internal.R.id.search_src_text);
+        mAppIcon = (ImageView) findViewById(com.android.internal.R.id.search_app_icon);
+        mSearchPlate = mSearchView.findViewById(com.android.internal.R.id.search_plate);
+        mWorkingSpinner = getContext().getResources().
+                getDrawable(com.android.internal.R.drawable.search_spinner);
+        // TODO: Restore the spinner for slow suggestion lookups
+        // mSearchAutoComplete.setCompoundDrawablesWithIntrinsicBounds(
+        //        null, null, mWorkingSpinner, null);
+        setWorking(false);
+
+        // pre-hide all the extraneous elements
+        mBadgeLabel.setVisibility(View.GONE);
+
+        // Additional adjustments to make Dialog work for Search
+        mSearchAutoCompleteImeOptions = mSearchAutoComplete.getImeOptions();
+    }
+
+    /**
+     * Set up the search dialog
+     * 
+     * @return true if search dialog launched, false if not
+     */
+    public boolean show(String initialQuery, boolean selectInitialQuery,
+            ComponentName componentName, Bundle appSearchData) {
+        boolean success = doShow(initialQuery, selectInitialQuery, componentName, appSearchData);
+        if (success) {
+            // Display the drop down as soon as possible instead of waiting for the rest of the
+            // pending UI stuff to get done, so that things appear faster to the user.
+            mSearchAutoComplete.showDropDownAfterLayout();
+        }
+        return success;
+    }
+
+    /**
+     * Does the rest of the work required to show the search dialog. Called by
+     * {@link #show(String, boolean, ComponentName, Bundle)} and
+     *
+     * @return true if search dialog showed, false if not
+     */
+    private boolean doShow(String initialQuery, boolean selectInitialQuery,
+            ComponentName componentName, Bundle appSearchData) {
+        // set up the searchable and show the dialog
+        if (!show(componentName, appSearchData)) {
+            return false;
+        }
+
+        // finally, load the user's initial text (which may trigger suggestions)
+        setUserQuery(initialQuery);
+        if (selectInitialQuery) {
+            mSearchAutoComplete.selectAll();
+        }
+
+        return true;
+    }
+
+    /**
+     * Sets up the search dialog and shows it.
+     * 
+     * @return <code>true</code> if search dialog launched
+     */
+    private boolean show(ComponentName componentName, Bundle appSearchData) {
+        
+        if (DBG) { 
+            Log.d(LOG_TAG, "show(" + componentName + ", " 
+                    + appSearchData + ")");
+        }
+        
+        SearchManager searchManager = (SearchManager)
+                mContext.getSystemService(Context.SEARCH_SERVICE);
+        // Try to get the searchable info for the provided component.
+        mSearchable = searchManager.getSearchableInfo(componentName);
+
+        if (mSearchable == null) {
+            return false;
+        }
+
+        mLaunchComponent = componentName;
+        mAppSearchData = appSearchData;
+        mActivityContext = mSearchable.getActivityContext(getContext());
+
+        // show the dialog. this will call onStart().
+        if (!isShowing()) {
+            // Recreate the search bar view every time the dialog is shown, to get rid
+            // of any bad state in the AutoCompleteTextView etc
+            createContentView();
+            mSearchView.setSearchableInfo(mSearchable);
+            mSearchView.setAppSearchData(mAppSearchData);
+
+            show();
+        }
+        updateUI();
+
+        return true;
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+
+        // Register a listener for configuration change events.
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_CONFIGURATION_CHANGED);
+        getContext().registerReceiver(mConfChangeListener, filter);
+    }
+
+    /**
+     * The search dialog is being dismissed, so handle all of the local shutdown operations.
+     * 
+     * This function is designed to be idempotent so that dismiss() can be safely called at any time
+     * (even if already closed) and more likely to really dump any memory.  No leaks!
+     */
+    @Override
+    public void onStop() {
+        super.onStop();
+
+        getContext().unregisterReceiver(mConfChangeListener);
+
+        // dump extra memory we're hanging on to
+        mLaunchComponent = null;
+        mAppSearchData = null;
+        mSearchable = null;
+        mUserQuery = null;
+    }
+
+    /**
+     * Sets the search dialog to the 'working' state, which shows a working spinner in the
+     * right hand size of the text field.
+     * 
+     * @param working true to show spinner, false to hide spinner
+     */
+    public void setWorking(boolean working) {
+        mWorkingSpinner.setAlpha(working ? 255 : 0);
+        mWorkingSpinner.setVisible(working, false);
+        mWorkingSpinner.invalidateSelf();
+    }
+
+    /**
+     * Save the minimal set of data necessary to recreate the search
+     * 
+     * @return A bundle with the state of the dialog, or {@code null} if the search
+     *         dialog is not showing.
+     */
+    @Override
+    public Bundle onSaveInstanceState() {
+        if (!isShowing()) return null;
+
+        Bundle bundle = new Bundle();
+
+        // setup info so I can recreate this particular search       
+        bundle.putParcelable(INSTANCE_KEY_COMPONENT, mLaunchComponent);
+        bundle.putBundle(INSTANCE_KEY_APPDATA, mAppSearchData);
+        bundle.putString(INSTANCE_KEY_USER_QUERY, mUserQuery);
+
+        return bundle;
+    }
+
+    /**
+     * Restore the state of the dialog from a previously saved bundle.
+     * 
+     * @param savedInstanceState The state of the dialog previously saved by
+     *     {@link #onSaveInstanceState()}.
+     */
+    @Override
+    public void onRestoreInstanceState(Bundle savedInstanceState) {
+        if (savedInstanceState == null) return;
+
+        ComponentName launchComponent = savedInstanceState.getParcelable(INSTANCE_KEY_COMPONENT);
+        Bundle appSearchData = savedInstanceState.getBundle(INSTANCE_KEY_APPDATA);
+        String userQuery = savedInstanceState.getString(INSTANCE_KEY_USER_QUERY);
+
+        // show the dialog.
+        if (!doShow(userQuery, false, launchComponent, appSearchData)) {
+            // for some reason, we couldn't re-instantiate
+            return;
+        }
+    }
+
+    /**
+     * Called after resources have changed, e.g. after screen rotation or locale change.
+     */
+    public void onConfigurationChanged() {
+        if (mSearchable != null && isShowing()) {
+            // Redraw (resources may have changed)
+            updateSearchAppIcon();
+            updateSearchBadge();
+            if (isLandscapeMode(getContext())) {
+                mSearchAutoComplete.ensureImeVisible(true);
+            }
+        }
+    }
+
+    static boolean isLandscapeMode(Context context) {
+        return context.getResources().getConfiguration().orientation
+                == Configuration.ORIENTATION_LANDSCAPE;
+    }
+
+    /**
+     * Update the UI according to the info in the current value of {@link #mSearchable}.
+     */
+    private void updateUI() {
+        if (mSearchable != null) {
+            mDecor.setVisibility(View.VISIBLE);
+            updateSearchAutoComplete();
+            updateSearchAppIcon();
+            updateSearchBadge();
+            
+            // In order to properly configure the input method (if one is being used), we
+            // need to let it know if we'll be providing suggestions.  Although it would be
+            // difficult/expensive to know if every last detail has been configured properly, we 
+            // can at least see if a suggestions provider has been configured, and use that
+            // as our trigger.
+            int inputType = mSearchable.getInputType();
+            // We only touch this if the input type is set up for text (which it almost certainly
+            // should be, in the case of search!)
+            if ((inputType & InputType.TYPE_MASK_CLASS) == InputType.TYPE_CLASS_TEXT) {
+                // The existence of a suggestions authority is the proxy for "suggestions 
+                // are available here"
+                inputType &= ~InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
+                if (mSearchable.getSuggestAuthority() != null) {
+                    inputType |= InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
+                }
+            }
+            mSearchAutoComplete.setInputType(inputType);
+            mSearchAutoCompleteImeOptions = mSearchable.getImeOptions();
+            mSearchAutoComplete.setImeOptions(mSearchAutoCompleteImeOptions);
+            
+            // If the search dialog is going to show a voice search button, then don't let
+            // the soft keyboard display a microphone button if it would have otherwise.
+            if (mSearchable.getVoiceSearchEnabled()) {
+                mSearchAutoComplete.setPrivateImeOptions(IME_OPTION_NO_MICROPHONE);
+            } else {
+                mSearchAutoComplete.setPrivateImeOptions(null);
+            }
+        }
+    }
+    
+    /**
+     * Updates the auto-complete text view.
+     */
+    private void updateSearchAutoComplete() {
+        // we dismiss the entire dialog instead
+        mSearchAutoComplete.setDropDownDismissedOnCompletion(false);
+        mSearchAutoComplete.setForceIgnoreOutsideTouch(false);
+    }
+    
+    private void updateSearchAppIcon() {
+        PackageManager pm = getContext().getPackageManager();
+        Drawable icon;
+        try {
+            ActivityInfo info = pm.getActivityInfo(mLaunchComponent, 0);
+            icon = pm.getApplicationIcon(info.applicationInfo);
+            if (DBG)
+                Log.d(LOG_TAG, "Using app-specific icon");
+        } catch (NameNotFoundException e) {
+            icon = pm.getDefaultActivityIcon();
+            Log.w(LOG_TAG, mLaunchComponent + " not found, using generic app icon");
+        }
+        mAppIcon.setImageDrawable(icon);
+        mAppIcon.setVisibility(View.VISIBLE);
+        mSearchPlate.setPadding(SEARCH_PLATE_LEFT_PADDING_NON_GLOBAL, mSearchPlate.getPaddingTop(), mSearchPlate.getPaddingRight(), mSearchPlate.getPaddingBottom());
+    }
+
+    /**
+     * Setup the search "Badge" if requested by mode flags.
+     */
+    private void updateSearchBadge() {
+        // assume both hidden
+        int visibility = View.GONE;
+        Drawable icon = null;
+        CharSequence text = null;
+
+        // optionally show one or the other.
+        if (mSearchable.useBadgeIcon()) {
+            icon = mActivityContext.getResources().getDrawable(mSearchable.getIconId());
+            visibility = View.VISIBLE;
+            if (DBG) Log.d(LOG_TAG, "Using badge icon: " + mSearchable.getIconId());
+        } else if (mSearchable.useBadgeLabel()) {
+            text = mActivityContext.getResources().getText(mSearchable.getLabelId()).toString();
+            visibility = View.VISIBLE;
+            if (DBG) Log.d(LOG_TAG, "Using badge label: " + mSearchable.getLabelId());
+        }
+
+        mBadgeLabel.setCompoundDrawablesWithIntrinsicBounds(icon, null, null, null);
+        mBadgeLabel.setText(text);
+        mBadgeLabel.setVisibility(visibility);
+    }
+
+    /*
+     * Listeners of various types
+     */
+
+    /**
+     * {@link Dialog#onTouchEvent(MotionEvent)} will cancel the dialog only when the
+     * touch is outside the window. But the window includes space for the drop-down,
+     * so we also cancel on taps outside the search bar when the drop-down is not showing.
+     */
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        // cancel if the drop-down is not showing and the touch event was outside the search plate
+        if (!mSearchAutoComplete.isPopupShowing() && isOutOfBounds(mSearchPlate, event)) {
+            if (DBG) Log.d(LOG_TAG, "Pop-up not showing and outside of search plate.");
+            cancel();
+            return true;
+        }
+        // Let Dialog handle events outside the window while the pop-up is showing.
+        return super.onTouchEvent(event);
+    }
+
+    private boolean isOutOfBounds(View v, MotionEvent event) {
+        final int x = (int) event.getX();
+        final int y = (int) event.getY();
+        final int slop = ViewConfiguration.get(mContext).getScaledWindowTouchSlop();
+        return (x < -slop) || (y < -slop)
+                || (x > (v.getWidth()+slop))
+                || (y > (v.getHeight()+slop));
+    }
+
+    @Override
+    public void hide() {
+        if (!isShowing()) return;
+
+        // We made sure the IME was displayed, so also make sure it is closed
+        // when we go away.
+        InputMethodManager imm = (InputMethodManager)getContext()
+                .getSystemService(Context.INPUT_METHOD_SERVICE);
+        if (imm != null) {
+            imm.hideSoftInputFromWindow(
+                    getWindow().getDecorView().getWindowToken(), 0);
+        }
+
+        super.hide();
+    }
+    
+    /**
+     * Launch a search for the text in the query text field.
+     */
+    public void launchQuerySearch() {
+        launchQuerySearch(KeyEvent.KEYCODE_UNKNOWN, null);
+    }
+
+    /**
+     * Launch a search for the text in the query text field.
+     *
+     * @param actionKey The key code of the action key that was pressed,
+     *        or {@link KeyEvent#KEYCODE_UNKNOWN} if none.
+     * @param actionMsg The message for the action key that was pressed,
+     *        or <code>null</code> if none.
+     */
+    protected void launchQuerySearch(int actionKey, String actionMsg) {
+        String query = mSearchAutoComplete.getText().toString();
+        String action = Intent.ACTION_SEARCH;
+        Intent intent = createIntent(action, null, null, query, actionKey, actionMsg);
+        launchIntent(intent);
+    }
+
+    /**
+     * Launches an intent, including any special intent handling.
+     */
+    private void launchIntent(Intent intent) {
+        if (intent == null) {
+            return;
+        }
+        Log.d(LOG_TAG, "launching " + intent);
+        try {
+            // If the intent was created from a suggestion, it will always have an explicit
+            // component here.
+            getContext().startActivity(intent);
+            // If the search switches to a different activity,
+            // SearchDialogWrapper#performActivityResuming
+            // will handle hiding the dialog when the next activity starts, but for
+            // real in-app search, we still need to dismiss the dialog.
+            dismiss();
+        } catch (RuntimeException ex) {
+            Log.e(LOG_TAG, "Failed launch activity: " + intent, ex);
+        }
+    }
+
+    /**
+     * Sets the list item selection in the AutoCompleteTextView's ListView.
+     */
+    public void setListSelection(int index) {
+        mSearchAutoComplete.setListSelection(index);
+    }
+
+    /**
+     * Constructs an intent from the given information and the search dialog state.
+     * 
+     * @param action Intent action.
+     * @param data Intent data, or <code>null</code>.
+     * @param extraData Data for {@link SearchManager#EXTRA_DATA_KEY} or <code>null</code>.
+     * @param query Intent query, or <code>null</code>.
+     * @param actionKey The key code of the action key that was pressed,
+     *        or {@link KeyEvent#KEYCODE_UNKNOWN} if none.
+     * @param actionMsg The message for the action key that was pressed,
+     *        or <code>null</code> if none.
+     * @param mode The search mode, one of the acceptable values for
+     *             {@link SearchManager#SEARCH_MODE}, or {@code null}.
+     * @return The intent.
+     */
+    private Intent createIntent(String action, Uri data, String extraData, String query,
+            int actionKey, String actionMsg) {
+        // Now build the Intent
+        Intent intent = new Intent(action);
+        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        // We need CLEAR_TOP to avoid reusing an old task that has other activities
+        // on top of the one we want. We don't want to do this in in-app search though,
+        // as it can be destructive to the activity stack.
+        if (data != null) {
+            intent.setData(data);
+        }
+        intent.putExtra(SearchManager.USER_QUERY, mUserQuery);
+        if (query != null) {
+            intent.putExtra(SearchManager.QUERY, query);
+        }
+        if (extraData != null) {
+            intent.putExtra(SearchManager.EXTRA_DATA_KEY, extraData);
+        }
+        if (mAppSearchData != null) {
+            intent.putExtra(SearchManager.APP_DATA, mAppSearchData);
+        }
+        if (actionKey != KeyEvent.KEYCODE_UNKNOWN) {
+            intent.putExtra(SearchManager.ACTION_KEY, actionKey);
+            intent.putExtra(SearchManager.ACTION_MSG, actionMsg);
+        }
+        intent.setComponent(mSearchable.getSearchActivity());
+        return intent;
+    }
+
+    /**
+     * The root element in the search bar layout. This is a custom view just to override
+     * the handling of the back button.
+     */
+    public static class SearchBar extends LinearLayout {
+
+        private SearchDialog mSearchDialog;
+
+        public SearchBar(Context context, AttributeSet attrs) {
+            super(context, attrs);
+        }
+
+        public SearchBar(Context context) {
+            super(context);
+        }
+
+        public void setSearchDialog(SearchDialog searchDialog) {
+            mSearchDialog = searchDialog;
+        }
+
+        /**
+         * Don't allow action modes in a SearchBar, it looks silly.
+         */
+        @Override
+        public ActionMode startActionModeForChild(View child, ActionMode.Callback callback) {
+            return null;
+        }
+    }
+
+    private boolean isEmpty(AutoCompleteTextView actv) {
+        return TextUtils.getTrimmedLength(actv.getText()) == 0;
+    }
+
+    @Override
+    public void onBackPressed() {
+        // If the input method is covering the search dialog completely,
+        // e.g. in landscape mode with no hard keyboard, dismiss just the input method
+        InputMethodManager imm = (InputMethodManager)getContext()
+                .getSystemService(Context.INPUT_METHOD_SERVICE);
+        if (imm != null && imm.isFullscreenMode() &&
+                imm.hideSoftInputFromWindow(getWindow().getDecorView().getWindowToken(), 0)) {
+            return;
+        }
+        // Close search dialog
+        cancel();
+    }
+
+    private boolean onClosePressed() {
+        // Dismiss the dialog if close button is pressed when there's no query text
+        if (isEmpty(mSearchAutoComplete)) {
+            dismiss();
+            return true;
+        }
+
+        return false;
+    }
+
+    private final SearchView.OnCloseListener mOnCloseListener = new SearchView.OnCloseListener() {
+
+        public boolean onClose() {
+            return onClosePressed();
+        }
+    };
+
+    private final SearchView.OnQueryTextListener mOnQueryChangeListener =
+            new SearchView.OnQueryTextListener() {
+
+        public boolean onQueryTextSubmit(String query) {
+            dismiss();
+            return false;
+        }
+
+        public boolean onQueryTextChange(String newText) {
+            return false;
+        }
+    };
+
+    private final SearchView.OnSuggestionListener mOnSuggestionSelectionListener =
+            new SearchView.OnSuggestionListener() {
+
+        public boolean onSuggestionSelect(int position) {
+            return false;
+        }
+
+        public boolean onSuggestionClick(int position) {
+            dismiss();
+            return false;
+        }
+    };
+
+    /**
+     * Sets the text in the query box, updating the suggestions.
+     */
+    private void setUserQuery(String query) {
+        if (query == null) {
+            query = "";
+        }
+        mUserQuery = query;
+        mSearchAutoComplete.setText(query);
+        mSearchAutoComplete.setSelection(query.length());
+    }
+}
diff --git a/src/frameworks/base/core/java/android/app/StatusBarManager.java b/src/frameworks/base/core/java/android/app/StatusBarManager.java
new file mode 100644
index 0000000..dd9f337
--- /dev/null
+++ b/src/frameworks/base/core/java/android/app/StatusBarManager.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package android.app;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.RemoteException;
+import android.os.IBinder;
+import android.os.ServiceManager;
+import android.util.Slog;
+import android.view.View;
+
+import com.android.internal.statusbar.IStatusBarService;
+
+/**
+ * Allows an app to control the status bar.
+ *
+ * @hide
+ */
+public class StatusBarManager {
+
+    public static final int DISABLE_EXPAND = View.STATUS_BAR_DISABLE_EXPAND;
+    public static final int DISABLE_NOTIFICATION_ICONS = View.STATUS_BAR_DISABLE_NOTIFICATION_ICONS;
+    public static final int DISABLE_NOTIFICATION_ALERTS
+            = View.STATUS_BAR_DISABLE_NOTIFICATION_ALERTS;
+    public static final int DISABLE_NOTIFICATION_TICKER
+            = View.STATUS_BAR_DISABLE_NOTIFICATION_TICKER;
+    public static final int DISABLE_SYSTEM_INFO = View.STATUS_BAR_DISABLE_SYSTEM_INFO;
+    public static final int DISABLE_HOME = View.STATUS_BAR_DISABLE_HOME;
+    public static final int DISABLE_RECENT = View.STATUS_BAR_DISABLE_RECENT;
+    public static final int DISABLE_BACK = View.STATUS_BAR_DISABLE_BACK;
+    public static final int DISABLE_CLOCK = View.STATUS_BAR_DISABLE_CLOCK;
+
+    @Deprecated
+    public static final int DISABLE_NAVIGATION = 
+            View.STATUS_BAR_DISABLE_HOME | View.STATUS_BAR_DISABLE_RECENT;
+
+    public static final int DISABLE_NONE = 0x00000000;
+
+    public static final int DISABLE_MASK = DISABLE_EXPAND | DISABLE_NOTIFICATION_ICONS
+            | DISABLE_NOTIFICATION_ALERTS | DISABLE_NOTIFICATION_TICKER
+            | DISABLE_SYSTEM_INFO | DISABLE_RECENT | DISABLE_HOME | DISABLE_BACK | DISABLE_CLOCK;
+
+    public static final int NAVIGATION_HINT_BACK_NOP      = 1 << 0;
+    public static final int NAVIGATION_HINT_HOME_NOP      = 1 << 1;
+    public static final int NAVIGATION_HINT_RECENT_NOP    = 1 << 2;
+    public static final int NAVIGATION_HINT_BACK_ALT      = 1 << 3;
+
+    private Context mContext;
+    private IStatusBarService mService;
+    private IBinder mToken = new Binder();
+
+    StatusBarManager(Context context) {
+        mContext = context;
+    }
+
+    private synchronized IStatusBarService getService() {
+        if (mService == null) {
+            mService = IStatusBarService.Stub.asInterface(
+                    ServiceManager.getService(Context.STATUS_BAR_SERVICE));
+            if (mService == null) {
+                Slog.w("StatusBarManager", "warning: no STATUS_BAR_SERVICE");
+            }
+        }
+        return mService;
+    }
+
+    /**
+     * Disable some features in the status bar.  Pass the bitwise-or of the DISABLE_* flags.
+     * To re-enable everything, pass {@link #DISABLE_NONE}.
+     */
+    public void disable(int what) {
+        try {
+            final IStatusBarService svc = getService();
+            if (svc != null) {
+                svc.disable(what, mToken, mContext.getPackageName());
+            }
+        } catch (RemoteException ex) {
+            // system process is dead anyway.
+            throw new RuntimeException(ex);
+        }
+    }
+    
+    /**
+     * Expand the status bar.
+     */
+    public void expand() {
+        try {
+            final IStatusBarService svc = getService();
+            if (svc != null) {
+                svc.expand();
+            }
+        } catch (RemoteException ex) {
+            // system process is dead anyway.
+            throw new RuntimeException(ex);
+        }
+    }
+    
+    /**
+     * Collapse the status bar.
+     */
+    public void collapse() {
+        try {
+            final IStatusBarService svc = getService();
+            if (svc != null) {
+                svc.collapse();
+            }
+        } catch (RemoteException ex) {
+            // system process is dead anyway.
+            throw new RuntimeException(ex);
+        }
+    }
+
+    public void setIcon(String slot, int iconId, int iconLevel, String contentDescription) {
+        try {
+            final IStatusBarService svc = getService();
+            if (svc != null) {
+                svc.setIcon(slot, mContext.getPackageName(), iconId, iconLevel,
+                    contentDescription);
+            }
+        } catch (RemoteException ex) {
+            // system process is dead anyway.
+            throw new RuntimeException(ex);
+        }
+    }
+
+    public void removeIcon(String slot) {
+        try {
+            final IStatusBarService svc = getService();
+            if (svc != null) {
+                svc.removeIcon(slot);
+            }
+        } catch (RemoteException ex) {
+            // system process is dead anyway.
+            throw new RuntimeException(ex);
+        }
+    }
+
+    public void setIconVisibility(String slot, boolean visible) {
+        try {
+            final IStatusBarService svc = getService();
+            if (svc != null) {
+                svc.setIconVisibility(slot, visible);
+            }
+        } catch (RemoteException ex) {
+            // system process is dead anyway.
+            throw new RuntimeException(ex);
+        }
+    }
+}
diff --git a/src/frameworks/base/core/java/android/content/ClipboardManager.java b/src/frameworks/base/core/java/android/content/ClipboardManager.java
new file mode 100644
index 0000000..dfd1820
--- /dev/null
+++ b/src/frameworks/base/core/java/android/content/ClipboardManager.java
@@ -0,0 +1,233 @@
+/**
+ * Copyright (c) 2010, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.content;
+
+import android.content.Context;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.ServiceManager;
+import android.util.Log;
+
+import java.util.ArrayList;
+
+/**
+ * Interface to the clipboard service, for placing and retrieving text in
+ * the global clipboard.
+ *
+ * <p>
+ * You do not instantiate this class directly; instead, retrieve it through
+ * {@link android.content.Context#getSystemService}.
+ *
+ * <p>
+ * The ClipboardManager API itself is very simple: it consists of methods
+ * to atomically get and set the current primary clipboard data.  That data
+ * is expressed as a {@link ClipData} object, which defines the protocol
+ * for data exchange between applications.
+ *
+ * <div class="special reference">
+ * <h3>Developer Guides</h3>
+ * <p>For more information about using the clipboard framework, read the
+ * <a href="{@docRoot}guide/topics/clipboard/copy-paste.html">Copy and Paste</a>
+ * developer guide.</p>
+ * </div>
+ *
+ * @see android.content.Context#getSystemService
+ */
+public class ClipboardManager extends android.text.ClipboardManager {
+    private final static Object sStaticLock = new Object();
+    private static IClipboard sService;
+
+    private final Context mContext;
+
+    private final ArrayList<OnPrimaryClipChangedListener> mPrimaryClipChangedListeners
+             = new ArrayList<OnPrimaryClipChangedListener>();
+
+    private final IOnPrimaryClipChangedListener.Stub mPrimaryClipChangedServiceListener
+            = new IOnPrimaryClipChangedListener.Stub() {
+        public void dispatchPrimaryClipChanged() {
+            mHandler.sendEmptyMessage(MSG_REPORT_PRIMARY_CLIP_CHANGED);
+        }
+    };
+
+    static final int MSG_REPORT_PRIMARY_CLIP_CHANGED = 1;
+
+    private final Handler mHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case MSG_REPORT_PRIMARY_CLIP_CHANGED:
+                    reportPrimaryClipChanged();
+            }
+        }
+    };
+
+    /**
+     * Defines a listener callback that is invoked when the primary clip on the clipboard changes.
+     * Objects that want to register a listener call
+     * {@link android.content.ClipboardManager#addPrimaryClipChangedListener(OnPrimaryClipChangedListener)
+     * addPrimaryClipChangedListener()} with an
+     * object that implements OnPrimaryClipChangedListener.
+     *
+     */
+    public interface OnPrimaryClipChangedListener {
+
+        /**
+         * Callback that is invoked by {@link android.content.ClipboardManager} when the primary
+         * clip changes.
+         */
+        void onPrimaryClipChanged();
+    }
+
+    static private IClipboard getService() {
+        synchronized (sStaticLock) {
+            if (sService != null) {
+                return sService;
+            }
+            IBinder b = ServiceManager.getService("clipboard");
+            sService = IClipboard.Stub.asInterface(b);
+            return sService;
+        }
+    }
+
+    /** {@hide} */
+    public ClipboardManager(Context context, Handler handler) {
+        mContext = context;
+    }
+
+    /**
+     * Sets the current primary clip on the clipboard.  This is the clip that
+     * is involved in normal cut and paste operations.
+     *
+     * @param clip The clipped data item to set.
+     */
+    public void setPrimaryClip(ClipData clip) {
+        try {
+            getService().setPrimaryClip(clip);
+        } catch (RemoteException e) {
+        }
+    }
+
+    /**
+     * Returns the current primary clip on the clipboard.
+     */
+    public ClipData getPrimaryClip() {
+        try {
+            return getService().getPrimaryClip(mContext.getPackageName());
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Returns a description of the current primary clip on the clipboard
+     * but not a copy of its data.
+     */
+    public ClipDescription getPrimaryClipDescription() {
+        try {
+            return getService().getPrimaryClipDescription();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Returns true if there is currently a primary clip on the clipboard.
+     */
+    public boolean hasPrimaryClip() {
+        try {
+            return getService().hasPrimaryClip();
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    public void addPrimaryClipChangedListener(OnPrimaryClipChangedListener what) {
+        synchronized (mPrimaryClipChangedListeners) {
+            if (mPrimaryClipChangedListeners.size() == 0) {
+                try {
+                    getService().addPrimaryClipChangedListener(
+                            mPrimaryClipChangedServiceListener);
+                } catch (RemoteException e) {
+                }
+            }
+            mPrimaryClipChangedListeners.add(what);
+        }
+    }
+
+    public void removePrimaryClipChangedListener(OnPrimaryClipChangedListener what) {
+        synchronized (mPrimaryClipChangedListeners) {
+            mPrimaryClipChangedListeners.remove(what);
+            if (mPrimaryClipChangedListeners.size() == 0) {
+                try {
+                    getService().removePrimaryClipChangedListener(
+                            mPrimaryClipChangedServiceListener);
+                } catch (RemoteException e) {
+                }
+            }
+        }
+    }
+
+    /**
+     * @deprecated Use {@link #getPrimaryClip()} instead.  This retrieves
+     * the primary clip and tries to coerce it to a string.
+     */
+    public CharSequence getText() {
+        ClipData clip = getPrimaryClip();
+        if (clip != null && clip.getItemCount() > 0) {
+            return clip.getItemAt(0).coerceToText(mContext);
+        }
+        return null;
+    }
+
+    /**
+     * @deprecated Use {@link #setPrimaryClip(ClipData)} instead.  This
+     * creates a ClippedItem holding the given text and sets it as the
+     * primary clip.  It has no label or icon.
+     */
+    public void setText(CharSequence text) {
+        setPrimaryClip(ClipData.newPlainText(null, text));
+    }
+
+    /**
+     * @deprecated Use {@link #hasPrimaryClip()} instead.
+     */
+    public boolean hasText() {
+        try {
+            return getService().hasClipboardText();
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    void reportPrimaryClipChanged() {
+        Object[] listeners;
+
+        synchronized (mPrimaryClipChangedListeners) {
+            final int N = mPrimaryClipChangedListeners.size();
+            if (N <= 0) {
+                return;
+            }
+            listeners = mPrimaryClipChangedListeners.toArray();
+        }
+
+        for (int i=0; i<listeners.length; i++) {
+            ((OnPrimaryClipChangedListener)listeners[i]).onPrimaryClipChanged();
+        }
+    }
+}
diff --git a/src/frameworks/base/core/java/android/net/ConnectivityManager.java b/src/frameworks/base/core/java/android/net/ConnectivityManager.java
new file mode 100644
index 0000000..5f8793c
--- /dev/null
+++ b/src/frameworks/base/core/java/android/net/ConnectivityManager.java
@@ -0,0 +1,883 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.net;
+
+import static com.android.internal.util.Preconditions.checkNotNull;
+
+import android.annotation.SdkConstant;
+import android.annotation.SdkConstant.SdkConstantType;
+import android.content.Context;
+import android.os.Binder;
+import android.os.Build.VERSION_CODES;
+import android.os.RemoteException;
+import android.provider.Settings;
+
+import java.net.InetAddress;
+
+/**
+ * Class that answers queries about the state of network connectivity. It also
+ * notifies applications when network connectivity changes. Get an instance
+ * of this class by calling
+ * {@link android.content.Context#getSystemService(String) Context.getSystemService(Context.CONNECTIVITY_SERVICE)}.
+ * <p>
+ * The primary responsibilities of this class are to:
+ * <ol>
+ * <li>Monitor network connections (Wi-Fi, GPRS, UMTS, etc.)</li>
+ * <li>Send broadcast intents when network connectivity changes</li>
+ * <li>Attempt to "fail over" to another network when connectivity to a network
+ * is lost</li>
+ * <li>Provide an API that allows applications to query the coarse-grained or fine-grained
+ * state of the available networks</li>
+ * </ol>
+ */
+public class ConnectivityManager {
+    private static final String TAG = "ConnectivityManager";
+
+    /**
+     * A change in network connectivity has occurred. A connection has either
+     * been established or lost. The NetworkInfo for the affected network is
+     * sent as an extra; it should be consulted to see what kind of
+     * connectivity event occurred.
+     * <p/>
+     * If this is a connection that was the result of failing over from a
+     * disconnected network, then the FAILOVER_CONNECTION boolean extra is
+     * set to true.
+     * <p/>
+     * For a loss of connectivity, if the connectivity manager is attempting
+     * to connect (or has already connected) to another network, the
+     * NetworkInfo for the new network is also passed as an extra. This lets
+     * any receivers of the broadcast know that they should not necessarily
+     * tell the user that no data traffic will be possible. Instead, the
+     * reciever should expect another broadcast soon, indicating either that
+     * the failover attempt succeeded (and so there is still overall data
+     * connectivity), or that the failover attempt failed, meaning that all
+     * connectivity has been lost.
+     * <p/>
+     * For a disconnect event, the boolean extra EXTRA_NO_CONNECTIVITY
+     * is set to {@code true} if there are no connected networks at all.
+     */
+    public static final String CONNECTIVITY_ACTION = "android.net.conn.CONNECTIVITY_CHANGE";
+
+    /**
+     * Identical to {@link #CONNECTIVITY_ACTION} broadcast, but sent without any
+     * applicable {@link Settings.Secure#CONNECTIVITY_CHANGE_DELAY}.
+     *
+     * @hide
+     */
+    public static final String CONNECTIVITY_ACTION_IMMEDIATE =
+            "android.net.conn.CONNECTIVITY_CHANGE_IMMEDIATE";
+
+    /**
+     * The lookup key for a {@link NetworkInfo} object. Retrieve with
+     * {@link android.content.Intent#getParcelableExtra(String)}.
+     *
+     * @deprecated Since {@link NetworkInfo} can vary based on UID, applications
+     *             should always obtain network information through
+     *             {@link #getActiveNetworkInfo()} or
+     *             {@link #getAllNetworkInfo()}.
+     */
+    @Deprecated
+    public static final String EXTRA_NETWORK_INFO = "networkInfo";
+
+    /**
+     * The lookup key for a boolean that indicates whether a connect event
+     * is for a network to which the connectivity manager was failing over
+     * following a disconnect on another network.
+     * Retrieve it with {@link android.content.Intent#getBooleanExtra(String,boolean)}.
+     */
+    public static final String EXTRA_IS_FAILOVER = "isFailover";
+    /**
+     * The lookup key for a {@link NetworkInfo} object. This is supplied when
+     * there is another network that it may be possible to connect to. Retrieve with
+     * {@link android.content.Intent#getParcelableExtra(String)}.
+     */
+    public static final String EXTRA_OTHER_NETWORK_INFO = "otherNetwork";
+    /**
+     * The lookup key for a boolean that indicates whether there is a
+     * complete lack of connectivity, i.e., no network is available.
+     * Retrieve it with {@link android.content.Intent#getBooleanExtra(String,boolean)}.
+     */
+    public static final String EXTRA_NO_CONNECTIVITY = "noConnectivity";
+    /**
+     * The lookup key for a string that indicates why an attempt to connect
+     * to a network failed. The string has no particular structure. It is
+     * intended to be used in notifications presented to users. Retrieve
+     * it with {@link android.content.Intent#getStringExtra(String)}.
+     */
+    public static final String EXTRA_REASON = "reason";
+    /**
+     * The lookup key for a string that provides optionally supplied
+     * extra information about the network state. The information
+     * may be passed up from the lower networking layers, and its
+     * meaning may be specific to a particular network type. Retrieve
+     * it with {@link android.content.Intent#getStringExtra(String)}.
+     */
+    public static final String EXTRA_EXTRA_INFO = "extraInfo";
+    /**
+     * The lookup key for an int that provides information about
+     * our connection to the internet at large.  0 indicates no connection,
+     * 100 indicates a great connection.  Retrieve it with
+     * {@link android.content.Intent#getIntExtra(String, int)}.
+     * {@hide}
+     */
+    public static final String EXTRA_INET_CONDITION = "inetCondition";
+
+    /**
+     * Broadcast Action: The setting for background data usage has changed
+     * values. Use {@link #getBackgroundDataSetting()} to get the current value.
+     * <p>
+     * If an application uses the network in the background, it should listen
+     * for this broadcast and stop using the background data if the value is
+     * {@code false}.
+     * <p>
+     *
+     * @deprecated As of {@link VERSION_CODES#ICE_CREAM_SANDWICH}, availability
+     *             of background data depends on several combined factors, and
+     *             this broadcast is no longer sent. Instead, when background
+     *             data is unavailable, {@link #getActiveNetworkInfo()} will now
+     *             appear disconnected. During first boot after a platform
+     *             upgrade, this broadcast will be sent once if
+     *             {@link #getBackgroundDataSetting()} was {@code false} before
+     *             the upgrade.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    @Deprecated
+    public static final String ACTION_BACKGROUND_DATA_SETTING_CHANGED =
+            "android.net.conn.BACKGROUND_DATA_SETTING_CHANGED";
+
+    /**
+     * Broadcast Action: The network connection may not be good
+     * uses {@code ConnectivityManager.EXTRA_INET_CONDITION} and
+     * {@code ConnectivityManager.EXTRA_NETWORK_INFO} to specify
+     * the network and it's condition.
+     * @hide
+     */
+    public static final String INET_CONDITION_ACTION =
+            "android.net.conn.INET_CONDITION_ACTION";
+
+    /**
+     * Broadcast Action: A tetherable connection has come or gone
+     * TODO - finish the doc
+     * @hide
+     */
+    public static final String ACTION_TETHER_STATE_CHANGED =
+            "android.net.conn.TETHER_STATE_CHANGED";
+
+    /**
+     * @hide
+     * gives a String[]
+     */
+    public static final String EXTRA_AVAILABLE_TETHER = "availableArray";
+
+    /**
+     * @hide
+     * gives a String[]
+     */
+    public static final String EXTRA_ACTIVE_TETHER = "activeArray";
+
+    /**
+     * @hide
+     * gives a String[]
+     */
+    public static final String EXTRA_ERRORED_TETHER = "erroredArray";
+
+    /**
+     * The absence of APN..
+     * @hide
+     */
+    public static final int TYPE_NONE        = -1;
+
+    /**
+     * The Default Mobile data connection.  When active, all data traffic
+     * will use this connection by default.
+     */
+    public static final int TYPE_MOBILE      = 0;
+    /**
+     * The Default WIFI data connection.  When active, all data traffic
+     * will use this connection by default.
+     */
+    public static final int TYPE_WIFI        = 1;
+    /**
+     * An MMS-specific Mobile data connection.  This connection may be the
+     * same as {@link #TYPE_MOBILE} but it may be different.  This is used
+     * by applications needing to talk to the carrier's Multimedia Messaging
+     * Service servers.  It may coexist with default data connections.
+     */
+    public static final int TYPE_MOBILE_MMS  = 2;
+    /**
+     * A SUPL-specific Mobile data connection.  This connection may be the
+     * same as {@link #TYPE_MOBILE} but it may be different.  This is used
+     * by applications needing to talk to the carrier's Secure User Plane
+     * Location servers for help locating the device.  It may coexist with
+     * default data connections.
+     */
+    public static final int TYPE_MOBILE_SUPL = 3;
+    /**
+     * A DUN-specific Mobile data connection.  This connection may be the
+     * same as {@link #TYPE_MOBILE} but it may be different.  This is used
+     * by applicaitons performing a Dial Up Networking bridge so that
+     * the carrier is aware of DUN traffic.  It may coexist with default data
+     * connections.
+     */
+    public static final int TYPE_MOBILE_DUN  = 4;
+    /**
+     * A High Priority Mobile data connection.  This connection is typically
+     * the same as {@link #TYPE_MOBILE} but the routing setup is different.
+     * Only requesting processes will have access to the Mobile DNS servers
+     * and only IP's explicitly requested via {@link #requestRouteToHost}
+     * will route over this interface if a default route exists.
+     */
+    public static final int TYPE_MOBILE_HIPRI = 5;
+    /**
+     * The Default WiMAX data connection.  When active, all data traffic
+     * will use this connection by default.
+     */
+    public static final int TYPE_WIMAX       = 6;
+
+    /**
+     * The Default Bluetooth data connection. When active, all data traffic
+     * will use this connection by default.
+     */
+    public static final int TYPE_BLUETOOTH   = 7;
+
+    /**
+     * Dummy data connection.  This should not be used on shipping devices.
+     */
+    public static final int TYPE_DUMMY       = 8;
+
+    /**
+     * The Default Ethernet data connection.  When active, all data traffic
+     * will use this connection by default.
+     */
+    public static final int TYPE_ETHERNET    = 9;
+
+    /**
+     * Over the air Adminstration.
+     * {@hide}
+     */
+    public static final int TYPE_MOBILE_FOTA = 10;
+
+    /**
+     * IP Multimedia Subsystem
+     * {@hide}
+     */
+    public static final int TYPE_MOBILE_IMS  = 11;
+
+    /**
+     * Carrier Branded Services
+     * {@hide}
+     */
+    public static final int TYPE_MOBILE_CBS  = 12;
+
+    /**
+     * A Wi-Fi p2p connection. Only requesting processes will have access to
+     * the peers connected.
+     * {@hide}
+     */
+    public static final int TYPE_WIFI_P2P    = 13;
+
+    /** {@hide} */
+    public static final int MAX_RADIO_TYPE   = TYPE_WIFI_P2P;
+
+    /** {@hide} */
+    public static final int MAX_NETWORK_TYPE = TYPE_WIFI_P2P;
+
+    public static final int DEFAULT_NETWORK_PREFERENCE = TYPE_WIFI;
+
+    private final IConnectivityManager mService;
+
+    public static boolean isNetworkTypeValid(int networkType) {
+        return networkType >= 0 && networkType <= MAX_NETWORK_TYPE;
+    }
+
+    /** {@hide} */
+    public static String getNetworkTypeName(int type) {
+        switch (type) {
+            case TYPE_MOBILE:
+                return "MOBILE";
+            case TYPE_WIFI:
+                return "WIFI";
+            case TYPE_MOBILE_MMS:
+                return "MOBILE_MMS";
+            case TYPE_MOBILE_SUPL:
+                return "MOBILE_SUPL";
+            case TYPE_MOBILE_DUN:
+                return "MOBILE_DUN";
+            case TYPE_MOBILE_HIPRI:
+                return "MOBILE_HIPRI";
+            case TYPE_WIMAX:
+                return "WIMAX";
+            case TYPE_BLUETOOTH:
+                return "BLUETOOTH";
+            case TYPE_DUMMY:
+                return "DUMMY";
+            case TYPE_ETHERNET:
+                return "ETHERNET";
+            case TYPE_MOBILE_FOTA:
+                return "MOBILE_FOTA";
+            case TYPE_MOBILE_IMS:
+                return "MOBILE_IMS";
+            case TYPE_MOBILE_CBS:
+                return "MOBILE_CBS";
+            case TYPE_WIFI_P2P:
+                return "WIFI_P2P";
+            default:
+                return Integer.toString(type);
+        }
+    }
+
+    /** {@hide} */
+    public static boolean isNetworkTypeMobile(int networkType) {
+        switch (networkType) {
+            case TYPE_MOBILE:
+            case TYPE_MOBILE_MMS:
+            case TYPE_MOBILE_SUPL:
+            case TYPE_MOBILE_DUN:
+            case TYPE_MOBILE_HIPRI:
+            case TYPE_MOBILE_FOTA:
+            case TYPE_MOBILE_IMS:
+            case TYPE_MOBILE_CBS:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    public void setNetworkPreference(int preference) {
+        try {
+            mService.setNetworkPreference(preference);
+        } catch (RemoteException e) {
+        }
+    }
+
+    public int getNetworkPreference() {
+        try {
+            return mService.getNetworkPreference();
+        } catch (RemoteException e) {
+            return -1;
+        }
+    }
+
+    /**
+     * Returns details about the currently active data network. When connected,
+     * this network is the default route for outgoing connections. You should
+     * always check {@link NetworkInfo#isConnected()} before initiating network
+     * traffic. This may return {@code null} when no networks are available.
+     * <p>This method requires the caller to hold the permission
+     * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
+     */
+    public NetworkInfo getActiveNetworkInfo() {
+        try {
+            return mService.getActiveNetworkInfo();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /** {@hide} */
+    public NetworkInfo getActiveNetworkInfoForUid(int uid) {
+        try {
+            return mService.getActiveNetworkInfoForUid(uid);
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    public NetworkInfo getNetworkInfo(int networkType) {
+        try {
+            return mService.getNetworkInfo(networkType);
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    public NetworkInfo[] getAllNetworkInfo() {
+        try {
+            return mService.getAllNetworkInfo();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /** {@hide} */
+    public LinkProperties getActiveLinkProperties() {
+        try {
+            return mService.getActiveLinkProperties();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /** {@hide} */
+    public LinkProperties getLinkProperties(int networkType) {
+        try {
+            return mService.getLinkProperties(networkType);
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /** {@hide} */
+    public boolean setRadios(boolean turnOn) {
+        try {
+            return mService.setRadios(turnOn);
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /** {@hide} */
+    public boolean setRadio(int networkType, boolean turnOn) {
+        try {
+            return mService.setRadio(networkType, turnOn);
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Tells the underlying networking system that the caller wants to
+     * begin using the named feature. The interpretation of {@code feature}
+     * is completely up to each networking implementation.
+     * <p>This method requires the caller to hold the permission
+     * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
+     * @param networkType specifies which network the request pertains to
+     * @param feature the name of the feature to be used
+     * @return an integer value representing the outcome of the request.
+     * The interpretation of this value is specific to each networking
+     * implementation+feature combination, except that the value {@code -1}
+     * always indicates failure.
+     */
+    public int startUsingNetworkFeature(int networkType, String feature) {
+        try {
+            return mService.startUsingNetworkFeature(networkType, feature,
+                    new Binder());
+        } catch (RemoteException e) {
+            return -1;
+        }
+    }
+
+    /**
+     * Tells the underlying networking system that the caller is finished
+     * using the named feature. The interpretation of {@code feature}
+     * is completely up to each networking implementation.
+     * <p>This method requires the caller to hold the permission
+     * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
+     * @param networkType specifies which network the request pertains to
+     * @param feature the name of the feature that is no longer needed
+     * @return an integer value representing the outcome of the request.
+     * The interpretation of this value is specific to each networking
+     * implementation+feature combination, except that the value {@code -1}
+     * always indicates failure.
+     */
+    public int stopUsingNetworkFeature(int networkType, String feature) {
+        try {
+            return mService.stopUsingNetworkFeature(networkType, feature);
+        } catch (RemoteException e) {
+            return -1;
+        }
+    }
+
+    /**
+     * Ensure that a network route exists to deliver traffic to the specified
+     * host via the specified network interface. An attempt to add a route that
+     * already exists is ignored, but treated as successful.
+     * <p>This method requires the caller to hold the permission
+     * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
+     * @param networkType the type of the network over which traffic to the specified
+     * host is to be routed
+     * @param hostAddress the IP address of the host to which the route is desired
+     * @return {@code true} on success, {@code false} on failure
+     */
+    public boolean requestRouteToHost(int networkType, int hostAddress) {
+        InetAddress inetAddress = NetworkUtils.intToInetAddress(hostAddress);
+
+        if (inetAddress == null) {
+            return false;
+        }
+
+        return requestRouteToHostAddress(networkType, inetAddress);
+    }
+
+    /**
+     * Ensure that a network route exists to deliver traffic to the specified
+     * host via the specified network interface. An attempt to add a route that
+     * already exists is ignored, but treated as successful.
+     * @param networkType the type of the network over which traffic to the specified
+     * host is to be routed
+     * @param hostAddress the IP address of the host to which the route is desired
+     * @return {@code true} on success, {@code false} on failure
+     * @hide
+     */
+    public boolean requestRouteToHostAddress(int networkType, InetAddress hostAddress) {
+        byte[] address = hostAddress.getAddress();
+        try {
+            return mService.requestRouteToHostAddress(networkType, address);
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Returns the value of the setting for background data usage. If false,
+     * applications should not use the network if the application is not in the
+     * foreground. Developers should respect this setting, and check the value
+     * of this before performing any background data operations.
+     * <p>
+     * All applications that have background services that use the network
+     * should listen to {@link #ACTION_BACKGROUND_DATA_SETTING_CHANGED}.
+     * <p>
+     * @deprecated As of {@link VERSION_CODES#ICE_CREAM_SANDWICH}, availability of
+     * background data depends on several combined factors, and this method will
+     * always return {@code true}. Instead, when background data is unavailable,
+     * {@link #getActiveNetworkInfo()} will now appear disconnected.
+     *
+     * @return Whether background data usage is allowed.
+     */
+    @Deprecated
+    public boolean getBackgroundDataSetting() {
+        // assume that background data is allowed; final authority is
+        // NetworkInfo which may be blocked.
+        return true;
+    }
+
+    /**
+     * Sets the value of the setting for background data usage.
+     *
+     * @param allowBackgroundData Whether an application should use data while
+     *            it is in the background.
+     *
+     * @attr ref android.Manifest.permission#CHANGE_BACKGROUND_DATA_SETTING
+     * @see #getBackgroundDataSetting()
+     * @hide
+     */
+    @Deprecated
+    public void setBackgroundDataSetting(boolean allowBackgroundData) {
+        // ignored
+    }
+
+    /**
+     * Return quota status for the current active network, or {@code null} if no
+     * network is active. Quota status can change rapidly, so these values
+     * shouldn't be cached.
+     *
+     * @hide
+     */
+    public NetworkQuotaInfo getActiveNetworkQuotaInfo() {
+        try {
+            return mService.getActiveNetworkQuotaInfo();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Gets the value of the setting for enabling Mobile data.
+     *
+     * @return Whether mobile data is enabled.
+     * @hide
+     */
+    public boolean getMobileDataEnabled() {
+        try {
+            return mService.getMobileDataEnabled();
+        } catch (RemoteException e) {
+            return true;
+        }
+    }
+
+    /**
+     * Sets the persisted value for enabling/disabling Mobile data.
+     *
+     * @param enabled Whether the mobile data connection should be
+     *            used or not.
+     * @hide
+     */
+    public void setMobileDataEnabled(boolean enabled) {
+        try {
+            mService.setMobileDataEnabled(enabled);
+        } catch (RemoteException e) {
+        }
+    }
+
+    /**
+     * {@hide}
+     */
+    public ConnectivityManager(IConnectivityManager service) {
+        mService = checkNotNull(service, "missing IConnectivityManager");
+    }
+
+    /** {@hide} */
+    public static ConnectivityManager from(Context context) {
+        return (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+    }
+
+    /**
+     * {@hide}
+     */
+    public String[] getTetherableIfaces() {
+        try {
+            return mService.getTetherableIfaces();
+        } catch (RemoteException e) {
+            return new String[0];
+        }
+    }
+
+    /**
+     * {@hide}
+     */
+    public String[] getTetheredIfaces() {
+        try {
+            return mService.getTetheredIfaces();
+        } catch (RemoteException e) {
+            return new String[0];
+        }
+    }
+
+    /**
+     * {@hide}
+     */
+    public String[] getTetheringErroredIfaces() {
+        try {
+            return mService.getTetheringErroredIfaces();
+        } catch (RemoteException e) {
+            return new String[0];
+        }
+    }
+
+    /**
+     * @return error A TETHER_ERROR value indicating success or failure type
+     * {@hide}
+     */
+    public int tether(String iface) {
+        try {
+            return mService.tether(iface);
+        } catch (RemoteException e) {
+            return TETHER_ERROR_SERVICE_UNAVAIL;
+        }
+    }
+
+    /**
+     * @return error A TETHER_ERROR value indicating success or failure type
+     * {@hide}
+     */
+    public int untether(String iface) {
+        try {
+            return mService.untether(iface);
+        } catch (RemoteException e) {
+            return TETHER_ERROR_SERVICE_UNAVAIL;
+        }
+    }
+
+    /**
+     * {@hide}
+     */
+    public boolean isTetheringSupported() {
+        try {
+            return mService.isTetheringSupported();
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * {@hide}
+     */
+    public String[] getTetherableUsbRegexs() {
+        try {
+            return mService.getTetherableUsbRegexs();
+        } catch (RemoteException e) {
+            return new String[0];
+        }
+    }
+
+    /**
+     * {@hide}
+     */
+    public String[] getTetherableWifiRegexs() {
+        try {
+            return mService.getTetherableWifiRegexs();
+        } catch (RemoteException e) {
+            return new String[0];
+        }
+    }
+
+    /**
+     * {@hide}
+     */
+    public String[] getTetherableBluetoothRegexs() {
+        try {
+            return mService.getTetherableBluetoothRegexs();
+        } catch (RemoteException e) {
+            return new String[0];
+        }
+    }
+
+    /**
+     * {@hide}
+     */
+    public int setUsbTethering(boolean enable) {
+        try {
+            return mService.setUsbTethering(enable);
+        } catch (RemoteException e) {
+            return TETHER_ERROR_SERVICE_UNAVAIL;
+        }
+    }
+
+    /** {@hide} */
+    public static final int TETHER_ERROR_NO_ERROR           = 0;
+    /** {@hide} */
+    public static final int TETHER_ERROR_UNKNOWN_IFACE      = 1;
+    /** {@hide} */
+    public static final int TETHER_ERROR_SERVICE_UNAVAIL    = 2;
+    /** {@hide} */
+    public static final int TETHER_ERROR_UNSUPPORTED        = 3;
+    /** {@hide} */
+    public static final int TETHER_ERROR_UNAVAIL_IFACE      = 4;
+    /** {@hide} */
+    public static final int TETHER_ERROR_MASTER_ERROR       = 5;
+    /** {@hide} */
+    public static final int TETHER_ERROR_TETHER_IFACE_ERROR = 6;
+    /** {@hide} */
+    public static final int TETHER_ERROR_UNTETHER_IFACE_ERROR = 7;
+    /** {@hide} */
+    public static final int TETHER_ERROR_ENABLE_NAT_ERROR     = 8;
+    /** {@hide} */
+    public static final int TETHER_ERROR_DISABLE_NAT_ERROR    = 9;
+    /** {@hide} */
+    public static final int TETHER_ERROR_IFACE_CFG_ERROR      = 10;
+
+    /**
+     * @param iface The name of the interface we're interested in
+     * @return error The error code of the last error tethering or untethering the named
+     *               interface
+     * {@hide}
+     */
+    public int getLastTetherError(String iface) {
+        try {
+            return mService.getLastTetherError(iface);
+        } catch (RemoteException e) {
+            return TETHER_ERROR_SERVICE_UNAVAIL;
+        }
+    }
+
+    /**
+     * Ensure the device stays awake until we connect with the next network
+     * @param forWhome The name of the network going down for logging purposes
+     * @return {@code true} on success, {@code false} on failure
+     * {@hide}
+     */
+    public boolean requestNetworkTransitionWakelock(String forWhom) {
+        try {
+            mService.requestNetworkTransitionWakelock(forWhom);
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * @param networkType The type of network you want to report on
+     * @param percentage The quality of the connection 0 is bad, 100 is good
+     * {@hide}
+     */
+    public void reportInetCondition(int networkType, int percentage) {
+        try {
+            mService.reportInetCondition(networkType, percentage);
+        } catch (RemoteException e) {
+        }
+    }
+
+    /**
+     * @param proxyProperties The definition for the new global http proxy
+     * {@hide}
+     */
+    public void setGlobalProxy(ProxyProperties p) {
+        try {
+            mService.setGlobalProxy(p);
+        } catch (RemoteException e) {
+        }
+    }
+
+    /**
+     * @return proxyProperties for the current global proxy
+     * {@hide}
+     */
+    public ProxyProperties getGlobalProxy() {
+        try {
+            return mService.getGlobalProxy();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * @return proxyProperties for the current proxy (global if set, network specific if not)
+     * {@hide}
+     */
+    public ProxyProperties getProxy() {
+        try {
+            return mService.getProxy();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * @param networkType The network who's dependence has changed
+     * @param met Boolean - true if network use is ok, false if not
+     * {@hide}
+     */
+    public void setDataDependency(int networkType, boolean met) {
+        try {
+            mService.setDataDependency(networkType, met);
+        } catch (RemoteException e) {
+        }
+    }
+
+    /**
+     * Returns true if the hardware supports the given network type
+     * else it returns false.  This doesn't indicate we have coverage
+     * or are authorized onto a network, just whether or not the
+     * hardware supports it.  For example a gsm phone without a sim
+     * should still return true for mobile data, but a wifi only tablet
+     * would return false.
+     * @param networkType The nework type we'd like to check
+     * @return true if supported, else false
+     * @hide
+     */
+    public boolean isNetworkSupported(int networkType) {
+        try {
+            return mService.isNetworkSupported(networkType);
+        } catch (RemoteException e) {}
+        return false;
+    }
+
+    /**
+     * Returns if the currently active data network is metered. A network is
+     * classified as metered when the user is sensitive to heavy data usage on
+     * that connection. You should check this before doing large data transfers,
+     * and warn the user or delay the operation until another network is
+     * available.
+     */
+    public boolean isActiveNetworkMetered() {
+        try {
+            return mService.isActiveNetworkMetered();
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+}
diff --git a/src/frameworks/base/core/java/android/preference/PreferenceFrameLayout.java b/src/frameworks/base/core/java/android/preference/PreferenceFrameLayout.java
new file mode 100644
index 0000000..75372aa
--- /dev/null
+++ b/src/frameworks/base/core/java/android/preference/PreferenceFrameLayout.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.preference;
+
+import android.app.FragmentBreadCrumbs;
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.FrameLayout;
+
+/**
+ * @hide
+ */
+public class PreferenceFrameLayout extends FrameLayout {
+    private static final int DEFAULT_BORDER_TOP = 0;
+    private static final int DEFAULT_BORDER_BOTTOM = 0;
+    private static final int DEFAULT_BORDER_LEFT = 0;
+    private static final int DEFAULT_BORDER_RIGHT = 0;
+    private final int mBorderTop;
+    private final int mBorderBottom;
+    private final int mBorderLeft;
+    private final int mBorderRight;
+    private boolean mPaddingApplied;
+
+    public PreferenceFrameLayout(Context context) {
+        this(context, null);
+    }
+
+    public PreferenceFrameLayout(Context context, AttributeSet attrs) {
+        this(context, attrs, com.android.internal.R.attr.preferenceFrameLayoutStyle);
+    }
+
+    public PreferenceFrameLayout(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        TypedArray a = context.obtainStyledAttributes(attrs,
+                com.android.internal.R.styleable.PreferenceFrameLayout, defStyle, 0);
+
+        float density = context.getResources().getDisplayMetrics().density;
+        int defaultBorderTop = (int) (density * DEFAULT_BORDER_TOP + 0.5f);
+        int defaultBottomPadding = (int) (density * DEFAULT_BORDER_BOTTOM + 0.5f);
+        int defaultLeftPadding = (int) (density * DEFAULT_BORDER_LEFT + 0.5f);
+        int defaultRightPadding = (int) (density * DEFAULT_BORDER_RIGHT + 0.5f);
+
+        mBorderTop = a.getDimensionPixelSize(
+                com.android.internal.R.styleable.PreferenceFrameLayout_borderTop,
+                defaultBorderTop);
+        mBorderBottom = a.getDimensionPixelSize(
+                com.android.internal.R.styleable.PreferenceFrameLayout_borderBottom,
+                defaultBottomPadding);
+        mBorderLeft = a.getDimensionPixelSize(
+                com.android.internal.R.styleable.PreferenceFrameLayout_borderLeft,
+                defaultLeftPadding);
+        mBorderRight = a.getDimensionPixelSize(
+                com.android.internal.R.styleable.PreferenceFrameLayout_borderRight,
+                defaultRightPadding);
+
+        a.recycle();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public LayoutParams generateLayoutParams(AttributeSet attrs) {
+        return new LayoutParams(getContext(), attrs);
+    }
+
+    @Override
+    public void addView(View child) {
+        int borderTop = getPaddingTop();
+        int borderBottom = getPaddingBottom();
+        int borderLeft = getPaddingLeft();
+        int borderRight = getPaddingRight();
+
+        android.view.ViewGroup.LayoutParams params = child.getLayoutParams();
+        LayoutParams layoutParams = params instanceof PreferenceFrameLayout.LayoutParams
+            ? (PreferenceFrameLayout.LayoutParams) child.getLayoutParams() : null;
+        // Check on the id of the child before adding it.
+        if (layoutParams != null && layoutParams.removeBorders) {
+            if (mPaddingApplied) {
+                borderTop -= mBorderTop;
+                borderBottom -= mBorderBottom;
+                borderLeft -= mBorderLeft;
+                borderRight -= mBorderRight;
+                mPaddingApplied = false;
+            }
+        } else {
+            // Add the padding to the view group after determining if the
+            // padding already exists.
+            if (!mPaddingApplied) {
+                borderTop += mBorderTop;
+                borderBottom += mBorderBottom;
+                borderLeft += mBorderLeft;
+                borderRight += mBorderRight;
+                mPaddingApplied = true;
+            }
+        }
+
+        int previousTop = getPaddingTop();
+        int previousBottom = getPaddingBottom();
+        int previousLeft = getPaddingLeft();
+        int previousRight = getPaddingRight();
+        if (previousTop != borderTop || previousBottom != borderBottom
+                || previousLeft != borderLeft || previousRight != borderRight) {
+            setPadding(borderLeft, borderTop, borderRight, borderBottom);
+        }
+
+        super.addView(child);
+    }
+
+    public static class LayoutParams extends FrameLayout.LayoutParams {
+        public boolean removeBorders = false;
+        /**
+         * {@inheritDoc}
+         */
+        public LayoutParams(Context c, AttributeSet attrs) {
+            super(c, attrs);
+
+            TypedArray a = c.obtainStyledAttributes(attrs,
+                    com.android.internal.R.styleable.PreferenceFrameLayout_Layout);
+            removeBorders = a.getBoolean(
+                    com.android.internal.R.styleable.PreferenceFrameLayout_Layout_layout_removeBorders,
+                    false);
+            a.recycle();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public LayoutParams(int width, int height) {
+            super(width, height);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/frameworks/base/core/java/android/speech/tts/TextToSpeech.java b/src/frameworks/base/core/java/android/speech/tts/TextToSpeech.java
new file mode 100755
index 0000000..7a174af
--- /dev/null
+++ b/src/frameworks/base/core/java/android/speech/tts/TextToSpeech.java
@@ -0,0 +1,1386 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy of
+ * the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package android.speech.tts;
+
+import android.annotation.SdkConstant;
+import android.annotation.SdkConstant.SdkConstantType;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.media.AudioManager;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.provider.Settings;
+import android.text.TextUtils;
+import android.util.Log;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ *
+ * Synthesizes speech from text for immediate playback or to create a sound file.
+ * <p>A TextToSpeech instance can only be used to synthesize text once it has completed its
+ * initialization. Implement the {@link TextToSpeech.OnInitListener} to be
+ * notified of the completion of the initialization.<br>
+ * When you are done using the TextToSpeech instance, call the {@link #shutdown()} method
+ * to release the native resources used by the TextToSpeech engine.
+ *
+ */
+public class TextToSpeech {
+
+    private static final String TAG = "TextToSpeech";
+
+    /**
+     * Denotes a successful operation.
+     */
+    public static final int SUCCESS = 0;
+    /**
+     * Denotes a generic operation failure.
+     */
+    public static final int ERROR = -1;
+
+    /**
+     * Queue mode where all entries in the playback queue (media to be played
+     * and text to be synthesized) are dropped and replaced by the new entry.
+     * Queues are flushed with respect to a given calling app. Entries in the queue
+     * from other callees are not discarded.
+     */
+    public static final int QUEUE_FLUSH = 0;
+    /**
+     * Queue mode where the new entry is added at the end of the playback queue.
+     */
+    public static final int QUEUE_ADD = 1;
+    /**
+     * Queue mode where the entire playback queue is purged. This is different
+     * from {@link #QUEUE_FLUSH} in that all entries are purged, not just entries
+     * from a given caller.
+     *
+     * @hide
+     */
+    static final int QUEUE_DESTROY = 2;
+
+    /**
+     * Denotes the language is available exactly as specified by the locale.
+     */
+    public static final int LANG_COUNTRY_VAR_AVAILABLE = 2;
+
+    /**
+     * Denotes the language is available for the language and country specified
+     * by the locale, but not the variant.
+     */
+    public static final int LANG_COUNTRY_AVAILABLE = 1;
+
+    /**
+     * Denotes the language is available for the language by the locale,
+     * but not the country and variant.
+     */
+    public static final int LANG_AVAILABLE = 0;
+
+    /**
+     * Denotes the language data is missing.
+     */
+    public static final int LANG_MISSING_DATA = -1;
+
+    /**
+     * Denotes the language is not supported.
+     */
+    public static final int LANG_NOT_SUPPORTED = -2;
+
+    /**
+     * Broadcast Action: The TextToSpeech synthesizer has completed processing
+     * of all the text in the speech queue.
+     *
+     * Note that this notifies callers when the <b>engine</b> has finished has
+     * processing text data. Audio playback might not have completed (or even started)
+     * at this point. If you wish to be notified when this happens, see
+     * {@link OnUtteranceCompletedListener}.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_TTS_QUEUE_PROCESSING_COMPLETED =
+            "android.speech.tts.TTS_QUEUE_PROCESSING_COMPLETED";
+
+    /**
+     * Interface definition of a callback to be invoked indicating the completion of the
+     * TextToSpeech engine initialization.
+     */
+    public interface OnInitListener {
+        /**
+         * Called to signal the completion of the TextToSpeech engine initialization.
+         *
+         * @param status {@link TextToSpeech#SUCCESS} or {@link TextToSpeech#ERROR}.
+         */
+        public void onInit(int status);
+    }
+
+    /**
+     * Listener that will be called when the TTS service has
+     * completed synthesizing an utterance. This is only called if the utterance
+     * has an utterance ID (see {@link TextToSpeech.Engine#KEY_PARAM_UTTERANCE_ID}).
+     */
+    public interface OnUtteranceCompletedListener {
+        /**
+         * Called when an utterance has been synthesized.
+         *
+         * @param utteranceId the identifier of the utterance.
+         */
+        public void onUtteranceCompleted(String utteranceId);
+    }
+
+    /**
+     * Constants and parameter names for controlling text-to-speech. These include:
+     *
+     * <ul>
+     *     <li>
+     *         Intents to ask engine to install data or check its data and
+     *         extras for a TTS engine's check data activity.
+     *     </li>
+     *     <li>
+     *         Keys for the parameters passed with speak commands, e.g.
+     *         {@link Engine#KEY_PARAM_UTTERANCE_ID}, {@link Engine#KEY_PARAM_STREAM}.
+     *     </li>
+     *     <li>
+     *         A list of feature strings that engines might support, e.g
+     *         {@link Engine#KEY_FEATURE_NETWORK_SYNTHESIS}). These values may be passed in to
+     *         {@link TextToSpeech#speak} and {@link TextToSpeech#synthesizeToFile} to modify
+     *         engine behaviour. The engine can be queried for the set of features it supports
+     *         through {@link TextToSpeech#getFeatures(java.util.Locale)}.
+     *     </li>
+     * </ul>
+     */
+    public class Engine {
+
+        /**
+         * Default speech rate.
+         * @hide
+         */
+        public static final int DEFAULT_RATE = 100;
+
+        /**
+         * Default pitch.
+         * @hide
+         */
+        public static final int DEFAULT_PITCH = 100;
+
+        /**
+         * Default volume.
+         * @hide
+         */
+        public static final float DEFAULT_VOLUME = 1.0f;
+
+        /**
+         * Default pan (centered).
+         * @hide
+         */
+        public static final float DEFAULT_PAN = 0.0f;
+
+        /**
+         * Default value for {@link Settings.Secure#TTS_USE_DEFAULTS}.
+         * @hide
+         */
+        public static final int USE_DEFAULTS = 0; // false
+
+        /**
+         * Package name of the default TTS engine.
+         *
+         * @hide
+         * @deprecated No longer in use, the default engine is determined by
+         *         the sort order defined in {@link TtsEngines}. Note that
+         *         this doesn't "break" anything because there is no guarantee that
+         *         the engine specified below is installed on a given build, let
+         *         alone be the default.
+         */
+        @Deprecated
+        public static final String DEFAULT_ENGINE = "com.svox.pico";
+
+        /**
+         * Default audio stream used when playing synthesized speech.
+         */
+        public static final int DEFAULT_STREAM = AudioManager.STREAM_MUSIC;
+
+        /**
+         * Indicates success when checking the installation status of the resources used by the
+         * TextToSpeech engine with the {@link #ACTION_CHECK_TTS_DATA} intent.
+         */
+        public static final int CHECK_VOICE_DATA_PASS = 1;
+
+        /**
+         * Indicates failure when checking the installation status of the resources used by the
+         * TextToSpeech engine with the {@link #ACTION_CHECK_TTS_DATA} intent.
+         */
+        public static final int CHECK_VOICE_DATA_FAIL = 0;
+
+        /**
+         * Indicates erroneous data when checking the installation status of the resources used by
+         * the TextToSpeech engine with the {@link #ACTION_CHECK_TTS_DATA} intent.
+         */
+        public static final int CHECK_VOICE_DATA_BAD_DATA = -1;
+
+        /**
+         * Indicates missing resources when checking the installation status of the resources used
+         * by the TextToSpeech engine with the {@link #ACTION_CHECK_TTS_DATA} intent.
+         */
+        public static final int CHECK_VOICE_DATA_MISSING_DATA = -2;
+
+        /**
+         * Indicates missing storage volume when checking the installation status of the resources
+         * used by the TextToSpeech engine with the {@link #ACTION_CHECK_TTS_DATA} intent.
+         */
+        public static final int CHECK_VOICE_DATA_MISSING_VOLUME = -3;
+
+        /**
+         * Intent for starting a TTS service. Services that handle this intent must
+         * extend {@link TextToSpeechService}. Normal applications should not use this intent
+         * directly, instead they should talk to the TTS service using the the methods in this
+         * class.
+         */
+        @SdkConstant(SdkConstantType.SERVICE_ACTION)
+        public static final String INTENT_ACTION_TTS_SERVICE =
+                "android.intent.action.TTS_SERVICE";
+
+        /**
+         * Name under which a text to speech engine publishes information about itself.
+         * This meta-data should reference an XML resource containing a
+         * <code>&lt;{@link android.R.styleable#TextToSpeechEngine tts-engine}&gt;</code>
+         * tag.
+         */
+        public static final String SERVICE_META_DATA = "android.speech.tts";
+
+        // intents to ask engine to install data or check its data
+        /**
+         * Activity Action: Triggers the platform TextToSpeech engine to
+         * start the activity that installs the resource files on the device
+         * that are required for TTS to be operational. Since the installation
+         * of the data can be interrupted or declined by the user, the application
+         * shouldn't expect successful installation upon return from that intent,
+         * and if need be, should check installation status with
+         * {@link #ACTION_CHECK_TTS_DATA}.
+         */
+        @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+        public static final String ACTION_INSTALL_TTS_DATA =
+                "android.speech.tts.engine.INSTALL_TTS_DATA";
+
+        /**
+         * Broadcast Action: broadcast to signal the completion of the installation of
+         * the data files used by the synthesis engine. Success or failure is indicated in the
+         * {@link #EXTRA_TTS_DATA_INSTALLED} extra.
+         */
+        @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+        public static final String ACTION_TTS_DATA_INSTALLED =
+                "android.speech.tts.engine.TTS_DATA_INSTALLED";
+
+        /**
+         * Activity Action: Starts the activity from the platform TextToSpeech
+         * engine to verify the proper installation and availability of the
+         * resource files on the system. Upon completion, the activity will
+         * return one of the following codes:
+         * {@link #CHECK_VOICE_DATA_PASS},
+         * {@link #CHECK_VOICE_DATA_FAIL},
+         * {@link #CHECK_VOICE_DATA_BAD_DATA},
+         * {@link #CHECK_VOICE_DATA_MISSING_DATA}, or
+         * {@link #CHECK_VOICE_DATA_MISSING_VOLUME}.
+         * <p> Moreover, the data received in the activity result will contain the following
+         * fields:
+         * <ul>
+         *   <li>{@link #EXTRA_VOICE_DATA_ROOT_DIRECTORY} which
+         *       indicates the path to the location of the resource files,</li>
+         *   <li>{@link #EXTRA_VOICE_DATA_FILES} which contains
+         *       the list of all the resource files,</li>
+         *   <li>and {@link #EXTRA_VOICE_DATA_FILES_INFO} which
+         *       contains, for each resource file, the description of the language covered by
+         *       the file in the xxx-YYY format, where xxx is the 3-letter ISO language code,
+         *       and YYY is the 3-letter ISO country code.</li>
+         * </ul>
+         */
+        @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+        public static final String ACTION_CHECK_TTS_DATA =
+                "android.speech.tts.engine.CHECK_TTS_DATA";
+
+        /**
+         * Activity intent for getting some sample text to use for demonstrating TTS.
+         *
+         * @hide This intent was used by engines written against the old API.
+         * Not sure if it should be exposed.
+         */
+        @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+        public static final String ACTION_GET_SAMPLE_TEXT =
+                "android.speech.tts.engine.GET_SAMPLE_TEXT";
+
+        // extras for a TTS engine's check data activity
+        /**
+         * Extra information received with the {@link #ACTION_CHECK_TTS_DATA} intent where
+         * the TextToSpeech engine specifies the path to its resources.
+         */
+        public static final String EXTRA_VOICE_DATA_ROOT_DIRECTORY = "dataRoot";
+
+        /**
+         * Extra information received with the {@link #ACTION_CHECK_TTS_DATA} intent where
+         * the TextToSpeech engine specifies the file names of its resources under the
+         * resource path.
+         */
+        public static final String EXTRA_VOICE_DATA_FILES = "dataFiles";
+
+        /**
+         * Extra information received with the {@link #ACTION_CHECK_TTS_DATA} intent where
+         * the TextToSpeech engine specifies the locale associated with each resource file.
+         */
+        public static final String EXTRA_VOICE_DATA_FILES_INFO = "dataFilesInfo";
+
+        /**
+         * Extra information received with the {@link #ACTION_CHECK_TTS_DATA} intent where
+         * the TextToSpeech engine returns an ArrayList<String> of all the available voices.
+         * The format of each voice is: lang-COUNTRY-variant where COUNTRY and variant are
+         * optional (ie, "eng" or "eng-USA" or "eng-USA-FEMALE").
+         */
+        public static final String EXTRA_AVAILABLE_VOICES = "availableVoices";
+
+        /**
+         * Extra information received with the {@link #ACTION_CHECK_TTS_DATA} intent where
+         * the TextToSpeech engine returns an ArrayList<String> of all the unavailable voices.
+         * The format of each voice is: lang-COUNTRY-variant where COUNTRY and variant are
+         * optional (ie, "eng" or "eng-USA" or "eng-USA-FEMALE").
+         */
+        public static final String EXTRA_UNAVAILABLE_VOICES = "unavailableVoices";
+
+        /**
+         * Extra information sent with the {@link #ACTION_CHECK_TTS_DATA} intent where the
+         * caller indicates to the TextToSpeech engine which specific sets of voice data to
+         * check for by sending an ArrayList<String> of the voices that are of interest.
+         * The format of each voice is: lang-COUNTRY-variant where COUNTRY and variant are
+         * optional (ie, "eng" or "eng-USA" or "eng-USA-FEMALE").
+         */
+        public static final String EXTRA_CHECK_VOICE_DATA_FOR = "checkVoiceDataFor";
+
+        // extras for a TTS engine's data installation
+        /**
+         * Extra information received with the {@link #ACTION_TTS_DATA_INSTALLED} intent.
+         * It indicates whether the data files for the synthesis engine were successfully
+         * installed. The installation was initiated with the  {@link #ACTION_INSTALL_TTS_DATA}
+         * intent. The possible values for this extra are
+         * {@link TextToSpeech#SUCCESS} and {@link TextToSpeech#ERROR}.
+         */
+        public static final String EXTRA_TTS_DATA_INSTALLED = "dataInstalled";
+
+        // keys for the parameters passed with speak commands. Hidden keys are used internally
+        // to maintain engine state for each TextToSpeech instance.
+        /**
+         * @hide
+         */
+        public static final String KEY_PARAM_RATE = "rate";
+
+        /**
+         * @hide
+         */
+        public static final String KEY_PARAM_LANGUAGE = "language";
+
+        /**
+         * @hide
+         */
+        public static final String KEY_PARAM_COUNTRY = "country";
+
+        /**
+         * @hide
+         */
+        public static final String KEY_PARAM_VARIANT = "variant";
+
+        /**
+         * @hide
+         */
+        public static final String KEY_PARAM_ENGINE = "engine";
+
+        /**
+         * @hide
+         */
+        public static final String KEY_PARAM_PITCH = "pitch";
+
+        /**
+         * Parameter key to specify the audio stream type to be used when speaking text
+         * or playing back a file. The value should be one of the STREAM_ constants
+         * defined in {@link AudioManager}.
+         *
+         * @see TextToSpeech#speak(String, int, HashMap)
+         * @see TextToSpeech#playEarcon(String, int, HashMap)
+         */
+        public static final String KEY_PARAM_STREAM = "streamType";
+
+        /**
+         * Parameter key to identify an utterance in the
+         * {@link TextToSpeech.OnUtteranceCompletedListener} after text has been
+         * spoken, a file has been played back or a silence duration has elapsed.
+         *
+         * @see TextToSpeech#speak(String, int, HashMap)
+         * @see TextToSpeech#playEarcon(String, int, HashMap)
+         * @see TextToSpeech#synthesizeToFile(String, HashMap, String)
+         */
+        public static final String KEY_PARAM_UTTERANCE_ID = "utteranceId";
+
+        /**
+         * Parameter key to specify the speech volume relative to the current stream type
+         * volume used when speaking text. Volume is specified as a float ranging from 0 to 1
+         * where 0 is silence, and 1 is the maximum volume (the default behavior).
+         *
+         * @see TextToSpeech#speak(String, int, HashMap)
+         * @see TextToSpeech#playEarcon(String, int, HashMap)
+         */
+        public static final String KEY_PARAM_VOLUME = "volume";
+
+        /**
+         * Parameter key to specify how the speech is panned from left to right when speaking text.
+         * Pan is specified as a float ranging from -1 to +1 where -1 maps to a hard-left pan,
+         * 0 to center (the default behavior), and +1 to hard-right.
+         *
+         * @see TextToSpeech#speak(String, int, HashMap)
+         * @see TextToSpeech#playEarcon(String, int, HashMap)
+         */
+        public static final String KEY_PARAM_PAN = "pan";
+
+        /**
+         * Feature key for network synthesis. See {@link TextToSpeech#getFeatures(Locale)}
+         * for a description of how feature keys work. If set (and supported by the engine
+         * as per {@link TextToSpeech#getFeatures(Locale)}, the engine must
+         * use network based synthesis.
+         *
+         * @see TextToSpeech#speak(String, int, java.util.HashMap)
+         * @see TextToSpeech#synthesizeToFile(String, java.util.HashMap, String)
+         * @see TextToSpeech#getFeatures(java.util.Locale)
+         */
+        public static final String KEY_FEATURE_NETWORK_SYNTHESIS = "networkTts";
+
+        /**
+         * Feature key for embedded synthesis. See {@link TextToSpeech#getFeatures(Locale)}
+         * for a description of how feature keys work. If set and supported by the engine
+         * as per {@link TextToSpeech#getFeatures(Locale)}, the engine must synthesize
+         * text on-device (without making network requests).
+         */
+        public static final String KEY_FEATURE_EMBEDDED_SYNTHESIS = "embeddedTts";
+    }
+
+    private final Context mContext;
+    private Connection mServiceConnection;
+    private OnInitListener mInitListener;
+    // Written from an unspecified application thread, read from
+    // a binder thread.
+    private volatile UtteranceProgressListener mUtteranceProgressListener;
+    private final Object mStartLock = new Object();
+
+    private String mRequestedEngine;
+    // Whether to initialize this TTS object with the default engine,
+    // if the requested engine is not available. Valid only if mRequestedEngine
+    // is not null. Used only for testing, though potentially useful API wise
+    // too.
+    private final boolean mUseFallback;
+    private final Map<String, Uri> mEarcons;
+    private final Map<String, Uri> mUtterances;
+    private final Bundle mParams = new Bundle();
+    private final TtsEngines mEnginesHelper;
+    private final String mPackageName;
+    private volatile String mCurrentEngine = null;
+
+    /**
+     * The constructor for the TextToSpeech class, using the default TTS engine.
+     * This will also initialize the associated TextToSpeech engine if it isn't already running.
+     *
+     * @param context
+     *            The context this instance is running in.
+     * @param listener
+     *            The {@link TextToSpeech.OnInitListener} that will be called when the
+     *            TextToSpeech engine has initialized.
+     */
+    public TextToSpeech(Context context, OnInitListener listener) {
+        this(context, listener, null);
+    }
+
+    /**
+     * The constructor for the TextToSpeech class, using the given TTS engine.
+     * This will also initialize the associated TextToSpeech engine if it isn't already running.
+     *
+     * @param context
+     *            The context this instance is running in.
+     * @param listener
+     *            The {@link TextToSpeech.OnInitListener} that will be called when the
+     *            TextToSpeech engine has initialized.
+     * @param engine Package name of the TTS engine to use.
+     */
+    public TextToSpeech(Context context, OnInitListener listener, String engine) {
+        this(context, listener, engine, null, true);
+    }
+
+    /**
+     * Used by the framework to instantiate TextToSpeech objects with a supplied
+     * package name, instead of using {@link android.content.Context#getPackageName()}
+     *
+     * @hide
+     */
+    public TextToSpeech(Context context, OnInitListener listener, String engine,
+            String packageName, boolean useFallback) {
+        mContext = context;
+        mInitListener = listener;
+        mRequestedEngine = engine;
+        mUseFallback = useFallback;
+
+        mEarcons = new HashMap<String, Uri>();
+        mUtterances = new HashMap<String, Uri>();
+        mUtteranceProgressListener = null;
+
+        mEnginesHelper = new TtsEngines(mContext);
+        if (packageName != null) {
+            mPackageName = packageName;
+        } else {
+            mPackageName = mContext.getPackageName();
+        }
+        initTts();
+    }
+
+    private <R> R runActionNoReconnect(Action<R> action, R errorResult, String method) {
+        return runAction(action, errorResult, method, false);
+    }
+
+    private <R> R runAction(Action<R> action, R errorResult, String method) {
+        return runAction(action, errorResult, method, true);
+    }
+
+    private <R> R runAction(Action<R> action, R errorResult, String method, boolean reconnect) {
+        synchronized (mStartLock) {
+            if (mServiceConnection == null) {
+                Log.w(TAG, method + " failed: not bound to TTS engine");
+                return errorResult;
+            }
+            return mServiceConnection.runAction(action, errorResult, method, reconnect);
+        }
+    }
+
+    private int initTts() {
+        // Step 1: Try connecting to the engine that was requested.
+        if (mRequestedEngine != null) {
+            if (mEnginesHelper.isEngineInstalled(mRequestedEngine)) {
+                if (connectToEngine(mRequestedEngine)) {
+                    mCurrentEngine = mRequestedEngine;
+                    return SUCCESS;
+                } else if (!mUseFallback) {
+                    mCurrentEngine = null;
+                    dispatchOnInit(ERROR);
+                    return ERROR;
+                }
+            } else if (!mUseFallback) {
+                Log.i(TAG, "Requested engine not installed: " + mRequestedEngine);
+                mCurrentEngine = null;
+                dispatchOnInit(ERROR);
+                return ERROR;
+            }
+        }
+
+        // Step 2: Try connecting to the user's default engine.
+        final String defaultEngine = getDefaultEngine();
+        if (defaultEngine != null && !defaultEngine.equals(mRequestedEngine)) {
+            if (connectToEngine(defaultEngine)) {
+                mCurrentEngine = defaultEngine;
+                return SUCCESS;
+            }
+        }
+
+        // Step 3: Try connecting to the highest ranked engine in the
+        // system.
+        final String highestRanked = mEnginesHelper.getHighestRankedEngineName();
+        if (highestRanked != null && !highestRanked.equals(mRequestedEngine) &&
+                !highestRanked.equals(defaultEngine)) {
+            if (connectToEngine(highestRanked)) {
+                mCurrentEngine = highestRanked;
+                return SUCCESS;
+            }
+        }
+
+        // NOTE: The API currently does not allow the caller to query whether
+        // they are actually connected to any engine. This might fail for various
+        // reasons like if the user disables all her TTS engines.
+
+        mCurrentEngine = null;
+        dispatchOnInit(ERROR);
+        return ERROR;
+    }
+
+    private boolean connectToEngine(String engine) {
+        Connection connection = new Connection();
+        Intent intent = new Intent(Engine.INTENT_ACTION_TTS_SERVICE);
+        intent.setPackage(engine);
+        boolean bound = mContext.bindService(intent, connection, Context.BIND_AUTO_CREATE);
+        if (!bound) {
+            Log.e(TAG, "Failed to bind to " + engine);
+            return false;
+        } else {
+            Log.i(TAG, "Sucessfully bound to " + engine);
+            return true;
+        }
+    }
+
+    private void dispatchOnInit(int result) {
+        synchronized (mStartLock) {
+            if (mInitListener != null) {
+                mInitListener.onInit(result);
+                mInitListener = null;
+            }
+        }
+    }
+
+    private IBinder getCallerIdentity() {
+        return mServiceConnection.getCallerIdentity();
+    }
+
+    /**
+     * Releases the resources used by the TextToSpeech engine.
+     * It is good practice for instance to call this method in the onDestroy() method of an Activity
+     * so the TextToSpeech engine can be cleanly stopped.
+     */
+    public void shutdown() {
+        runActionNoReconnect(new Action<Void>() {
+            @Override
+            public Void run(ITextToSpeechService service) throws RemoteException {
+                service.setCallback(getCallerIdentity(), null);
+                service.stop(getCallerIdentity());
+                mServiceConnection.disconnect();
+                // Context#unbindService does not result in a call to
+                // ServiceConnection#onServiceDisconnected. As a result, the
+                // service ends up being destroyed (if there are no other open
+                // connections to it) but the process lives on and the
+                // ServiceConnection continues to refer to the destroyed service.
+                //
+                // This leads to tons of log spam about SynthThread being dead.
+                mServiceConnection = null;
+                mCurrentEngine = null;
+                return null;
+            }
+        }, null, "shutdown");
+    }
+
+    /**
+     * Adds a mapping between a string of text and a sound resource in a
+     * package. After a call to this method, subsequent calls to
+     * {@link #speak(String, int, HashMap)} will play the specified sound resource
+     * if it is available, or synthesize the text it is missing.
+     *
+     * @param text
+     *            The string of text. Example: <code>"south_south_east"</code>
+     *
+     * @param packagename
+     *            Pass the packagename of the application that contains the
+     *            resource. If the resource is in your own application (this is
+     *            the most common case), then put the packagename of your
+     *            application here.<br/>
+     *            Example: <b>"com.google.marvin.compass"</b><br/>
+     *            The packagename can be found in the AndroidManifest.xml of
+     *            your application.
+     *            <p>
+     *            <code>&lt;manifest xmlns:android=&quot;...&quot;
+     *      package=&quot;<b>com.google.marvin.compass</b>&quot;&gt;</code>
+     *            </p>
+     *
+     * @param resourceId
+     *            Example: <code>R.raw.south_south_east</code>
+     *
+     * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
+     */
+    public int addSpeech(String text, String packagename, int resourceId) {
+        synchronized (mStartLock) {
+            mUtterances.put(text, makeResourceUri(packagename, resourceId));
+            return SUCCESS;
+        }
+    }
+
+    /**
+     * Adds a mapping between a string of text and a sound file. Using this, it
+     * is possible to add custom pronounciations for a string of text.
+     * After a call to this method, subsequent calls to {@link #speak(String, int, HashMap)}
+     * will play the specified sound resource if it is available, or synthesize the text it is
+     * missing.
+     *
+     * @param text
+     *            The string of text. Example: <code>"south_south_east"</code>
+     * @param filename
+     *            The full path to the sound file (for example:
+     *            "/sdcard/mysounds/hello.wav")
+     *
+     * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
+     */
+    public int addSpeech(String text, String filename) {
+        synchronized (mStartLock) {
+            mUtterances.put(text, Uri.parse(filename));
+            return SUCCESS;
+        }
+    }
+
+
+    /**
+     * Adds a mapping between a string of text and a sound resource in a
+     * package. Use this to add custom earcons.
+     *
+     * @see #playEarcon(String, int, HashMap)
+     *
+     * @param earcon The name of the earcon.
+     *            Example: <code>"[tick]"</code><br/>
+     *
+     * @param packagename
+     *            the package name of the application that contains the
+     *            resource. This can for instance be the package name of your own application.
+     *            Example: <b>"com.google.marvin.compass"</b><br/>
+     *            The package name can be found in the AndroidManifest.xml of
+     *            the application containing the resource.
+     *            <p>
+     *            <code>&lt;manifest xmlns:android=&quot;...&quot;
+     *      package=&quot;<b>com.google.marvin.compass</b>&quot;&gt;</code>
+     *            </p>
+     *
+     * @param resourceId
+     *            Example: <code>R.raw.tick_snd</code>
+     *
+     * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
+     */
+    public int addEarcon(String earcon, String packagename, int resourceId) {
+        synchronized(mStartLock) {
+            mEarcons.put(earcon, makeResourceUri(packagename, resourceId));
+            return SUCCESS;
+        }
+    }
+
+    /**
+     * Adds a mapping between a string of text and a sound file.
+     * Use this to add custom earcons.
+     *
+     * @see #playEarcon(String, int, HashMap)
+     *
+     * @param earcon
+     *            The name of the earcon.
+     *            Example: <code>"[tick]"</code>
+     * @param filename
+     *            The full path to the sound file (for example:
+     *            "/sdcard/mysounds/tick.wav")
+     *
+     * @return Code indicating success or failure. See {@link #ERROR} and {@link #SUCCESS}.
+     */
+    public int addEarcon(String earcon, String filename) {
+        synchronized(mStartLock) {
+            mEarcons.put(earcon, Uri.parse(filename));
+            return SUCCESS;
+        }
+    }
+
+    private Uri makeResourceUri(String packageName, int resourceId) {
+        return new Uri.Builder()
+                .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE)
+                .encodedAuthority(packageName)
+                .appendEncodedPath(String.valueOf(resourceId))
+                .build();
+    }
+
+    /**
+     * Speaks the string using the specified queuing strategy and speech
+     * parameters.
+     *
+     * @param text The string of text to be spoken.
+     * @param queueMode The queuing strategy to use, {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
+     * @param params Parameters for the request. Can be null.
+     *            Supported parameter names:
+     *            {@link Engine#KEY_PARAM_STREAM},
+     *            {@link Engine#KEY_PARAM_UTTERANCE_ID},
+     *            {@link Engine#KEY_PARAM_VOLUME},
+     *            {@link Engine#KEY_PARAM_PAN}.
+     *            Engine specific parameters may be passed in but the parameter keys
+     *            must be prefixed by the name of the engine they are intended for. For example
+     *            the keys "com.svox.pico_foo" and "com.svox.pico:bar" will be passed to the
+     *            engine named "com.svox.pico" if it is being used.
+     *
+     * @return {@link #ERROR} or {@link #SUCCESS}.
+     */
+    public int speak(final String text, final int queueMode, final HashMap<String, String> params) {
+        return runAction(new Action<Integer>() {
+            @Override
+            public Integer run(ITextToSpeechService service) throws RemoteException {
+                Uri utteranceUri = mUtterances.get(text);
+                if (utteranceUri != null) {
+                    return service.playAudio(getCallerIdentity(), utteranceUri, queueMode,
+                            getParams(params));
+                } else {
+                    return service.speak(getCallerIdentity(), text, queueMode, getParams(params));
+                }
+            }
+        }, ERROR, "speak");
+    }
+
+    /**
+     * Plays the earcon using the specified queueing mode and parameters.
+     * The earcon must already have been added with {@link #addEarcon(String, String)} or
+     * {@link #addEarcon(String, String, int)}.
+     *
+     * @param earcon The earcon that should be played
+     * @param queueMode {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
+     * @param params Parameters for the request. Can be null.
+     *            Supported parameter names:
+     *            {@link Engine#KEY_PARAM_STREAM},
+     *            {@link Engine#KEY_PARAM_UTTERANCE_ID}.
+     *            Engine specific parameters may be passed in but the parameter keys
+     *            must be prefixed by the name of the engine they are intended for. For example
+     *            the keys "com.svox.pico_foo" and "com.svox.pico:bar" will be passed to the
+     *            engine named "com.svox.pico" if it is being used.
+     *
+     * @return {@link #ERROR} or {@link #SUCCESS}.
+     */
+    public int playEarcon(final String earcon, final int queueMode,
+            final HashMap<String, String> params) {
+        return runAction(new Action<Integer>() {
+            @Override
+            public Integer run(ITextToSpeechService service) throws RemoteException {
+                Uri earconUri = mEarcons.get(earcon);
+                if (earconUri == null) {
+                    return ERROR;
+                }
+                return service.playAudio(getCallerIdentity(), earconUri, queueMode,
+                        getParams(params));
+            }
+        }, ERROR, "playEarcon");
+    }
+
+    /**
+     * Plays silence for the specified amount of time using the specified
+     * queue mode.
+     *
+     * @param durationInMs The duration of the silence.
+     * @param queueMode {@link #QUEUE_ADD} or {@link #QUEUE_FLUSH}.
+     * @param params Parameters for the request. Can be null.
+     *            Supported parameter names:
+     *            {@link Engine#KEY_PARAM_UTTERANCE_ID}.
+     *            Engine specific parameters may be passed in but the parameter keys
+     *            must be prefixed by the name of the engine they are intended for. For example
+     *            the keys "com.svox.pico_foo" and "com.svox.pico:bar" will be passed to the
+     *            engine named "com.svox.pico" if it is being used.
+     *
+     * @return {@link #ERROR} or {@link #SUCCESS}.
+     */
+    public int playSilence(final long durationInMs, final int queueMode,
+            final HashMap<String, String> params) {
+        return runAction(new Action<Integer>() {
+            @Override
+            public Integer run(ITextToSpeechService service) throws RemoteException {
+                return service.playSilence(getCallerIdentity(), durationInMs, queueMode,
+                        getParams(params));
+            }
+        }, ERROR, "playSilence");
+    }
+
+    /**
+     * Queries the engine for the set of features it supports for a given locale.
+     * Features can either be framework defined, e.g.
+     * {@link TextToSpeech.Engine#KEY_FEATURE_NETWORK_SYNTHESIS} or engine specific.
+     * Engine specific keys must be prefixed by the name of the engine they
+     * are intended for. These keys can be used as parameters to
+     * {@link TextToSpeech#speak(String, int, java.util.HashMap)} and
+     * {@link TextToSpeech#synthesizeToFile(String, java.util.HashMap, String)}.
+     *
+     * Features are boolean flags, and their values in the synthesis parameters
+     * must be behave as per {@link Boolean#parseBoolean(String)}.
+     *
+     * @param locale The locale to query features for.
+     */
+    public Set<String> getFeatures(final Locale locale) {
+        return runAction(new Action<Set<String>>() {
+            @Override
+            public Set<String> run(ITextToSpeechService service) throws RemoteException {
+                String[] features = service.getFeaturesForLanguage(
+                        locale.getISO3Language(), locale.getISO3Country(), locale.getVariant());
+                if (features != null) {
+                    final Set<String> featureSet = new HashSet<String>();
+                    Collections.addAll(featureSet, features);
+                    return featureSet;
+                }
+                return null;
+            }
+        }, null, "getFeatures");
+    }
+
+    /**
+     * Checks whether the TTS engine is busy speaking. Note that a speech item is
+     * considered complete once it's audio data has been sent to the audio mixer, or
+     * written to a file. There might be a finite lag between this point, and when
+     * the audio hardware completes playback.
+     *
+     * @return {@code true} if the TTS engine is speaking.
+     */
+    public boolean isSpeaking() {
+        return runAction(new Action<Boolean>() {
+            @Override
+            public Boolean run(ITextToSpeechService service) throws RemoteException {
+                return service.isSpeaking();
+            }
+        }, false, "isSpeaking");
+    }
+
+    /**
+     * Interrupts the current utterance (whether played or rendered to file) and discards other
+     * utterances in the queue.
+     *
+     * @return {@link #ERROR} or {@link #SUCCESS}.
+     */
+    public int stop() {
+        return runAction(new Action<Integer>() {
+            @Override
+            public Integer run(ITextToSpeechService service) throws RemoteException {
+                return service.stop(getCallerIdentity());
+            }
+        }, ERROR, "stop");
+    }
+
+    /**
+     * Sets the speech rate.
+     *
+     * This has no effect on any pre-recorded speech.
+     *
+     * @param speechRate Speech rate. {@code 1.0} is the normal speech rate,
+     *            lower values slow down the speech ({@code 0.5} is half the normal speech rate),
+     *            greater values accelerate it ({@code 2.0} is twice the normal speech rate).
+     *
+     * @return {@link #ERROR} or {@link #SUCCESS}.
+     */
+    public int setSpeechRate(float speechRate) {
+        if (speechRate > 0.0f) {
+            int intRate = (int)(speechRate * 100);
+            if (intRate > 0) {
+                synchronized (mStartLock) {
+                    mParams.putInt(Engine.KEY_PARAM_RATE, intRate);
+                }
+                return SUCCESS;
+            }
+        }
+        return ERROR;
+    }
+
+    /**
+     * Sets the speech pitch for the TextToSpeech engine.
+     *
+     * This has no effect on any pre-recorded speech.
+     *
+     * @param pitch Speech pitch. {@code 1.0} is the normal pitch,
+     *            lower values lower the tone of the synthesized voice,
+     *            greater values increase it.
+     *
+     * @return {@link #ERROR} or {@link #SUCCESS}.
+     */
+    public int setPitch(float pitch) {
+        if (pitch > 0.0f) {
+            int intPitch = (int)(pitch * 100);
+            if (intPitch > 0) {
+                synchronized (mStartLock) {
+                    mParams.putInt(Engine.KEY_PARAM_PITCH, intPitch);
+                }
+                return SUCCESS;
+            }
+        }
+        return ERROR;
+    }
+
+    /**
+     * @return the engine currently in use by this TextToSpeech instance.
+     * @hide
+     */
+    public String getCurrentEngine() {
+        return mCurrentEngine;
+    }
+
+    /**
+     * Sets the text-to-speech language.
+     * The TTS engine will try to use the closest match to the specified
+     * language as represented by the Locale, but there is no guarantee that the exact same Locale
+     * will be used. Use {@link #isLanguageAvailable(Locale)} to check the level of support
+     * before choosing the language to use for the next utterances.
+     *
+     * @param loc The locale describing the language to be used.
+     *
+     * @return Code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
+     *         {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
+     *         {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
+     */
+    public int setLanguage(final Locale loc) {
+        return runAction(new Action<Integer>() {
+            @Override
+            public Integer run(ITextToSpeechService service) throws RemoteException {
+                if (loc == null) {
+                    return LANG_NOT_SUPPORTED;
+                }
+                String language = loc.getISO3Language();
+                String country = loc.getISO3Country();
+                String variant = loc.getVariant();
+                // Check if the language, country, variant are available, and cache
+                // the available parts.
+                // Note that the language is not actually set here, instead it is cached so it
+                // will be associated with all upcoming utterances.
+                int result = service.loadLanguage(language, country, variant);
+                if (result >= LANG_AVAILABLE){
+                    if (result < LANG_COUNTRY_VAR_AVAILABLE) {
+                        variant = "";
+                        if (result < LANG_COUNTRY_AVAILABLE) {
+                            country = "";
+                        }
+                    }
+                    mParams.putString(Engine.KEY_PARAM_LANGUAGE, language);
+                    mParams.putString(Engine.KEY_PARAM_COUNTRY, country);
+                    mParams.putString(Engine.KEY_PARAM_VARIANT, variant);
+                }
+                return result;
+            }
+        }, LANG_NOT_SUPPORTED, "setLanguage");
+    }
+
+    /**
+     * Returns a Locale instance describing the language currently being used by the TextToSpeech
+     * engine.
+     *
+     * @return language, country (if any) and variant (if any) used by the engine stored in a Locale
+     *     instance, or {@code null} on error.
+     */
+    public Locale getLanguage() {
+        return runAction(new Action<Locale>() {
+            @Override
+            public Locale run(ITextToSpeechService service) throws RemoteException {
+                String[] locStrings = service.getLanguage();
+                if (locStrings != null && locStrings.length == 3) {
+                    return new Locale(locStrings[0], locStrings[1], locStrings[2]);
+                }
+                return null;
+            }
+        }, null, "getLanguage");
+    }
+
+    /**
+     * Checks if the specified language as represented by the Locale is available and supported.
+     *
+     * @param loc The Locale describing the language to be used.
+     *
+     * @return Code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
+     *         {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
+     *         {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
+     */
+    public int isLanguageAvailable(final Locale loc) {
+        return runAction(new Action<Integer>() {
+            @Override
+            public Integer run(ITextToSpeechService service) throws RemoteException {
+                return service.isLanguageAvailable(loc.getISO3Language(),
+                        loc.getISO3Country(), loc.getVariant());
+            }
+        }, LANG_NOT_SUPPORTED, "isLanguageAvailable");
+    }
+
+    /**
+     * Synthesizes the given text to a file using the specified parameters.
+     *
+     * @param text The text that should be synthesized
+     * @param params Parameters for the request. Can be null.
+     *            Supported parameter names:
+     *            {@link Engine#KEY_PARAM_UTTERANCE_ID}.
+     *            Engine specific parameters may be passed in but the parameter keys
+     *            must be prefixed by the name of the engine they are intended for. For example
+     *            the keys "com.svox.pico_foo" and "com.svox.pico:bar" will be passed to the
+     *            engine named "com.svox.pico" if it is being used.
+     * @param filename Absolute file filename to write the generated audio data to.It should be
+     *            something like "/sdcard/myappsounds/mysound.wav".
+     *
+     * @return {@link #ERROR} or {@link #SUCCESS}.
+     */
+    public int synthesizeToFile(final String text, final HashMap<String, String> params,
+            final String filename) {
+        return runAction(new Action<Integer>() {
+            @Override
+            public Integer run(ITextToSpeechService service) throws RemoteException {
+                return service.synthesizeToFile(getCallerIdentity(), text, filename,
+                        getParams(params));
+            }
+        }, ERROR, "synthesizeToFile");
+    }
+
+    private Bundle getParams(HashMap<String, String> params) {
+        if (params != null && !params.isEmpty()) {
+            Bundle bundle = new Bundle(mParams);
+            copyIntParam(bundle, params, Engine.KEY_PARAM_STREAM);
+            copyStringParam(bundle, params, Engine.KEY_PARAM_UTTERANCE_ID);
+            copyFloatParam(bundle, params, Engine.KEY_PARAM_VOLUME);
+            copyFloatParam(bundle, params, Engine.KEY_PARAM_PAN);
+
+            // Copy feature strings defined by the framework.
+            copyStringParam(bundle, params, Engine.KEY_FEATURE_NETWORK_SYNTHESIS);
+            copyStringParam(bundle, params, Engine.KEY_FEATURE_EMBEDDED_SYNTHESIS);
+
+            // Copy over all parameters that start with the name of the
+            // engine that we are currently connected to. The engine is
+            // free to interpret them as it chooses.
+            if (!TextUtils.isEmpty(mCurrentEngine)) {
+                for (Map.Entry<String, String> entry : params.entrySet()) {
+                    final String key = entry.getKey();
+                    if (key != null && key.startsWith(mCurrentEngine)) {
+                        bundle.putString(key, entry.getValue());
+                    }
+                }
+            }
+
+            return bundle;
+        } else {
+            return mParams;
+        }
+    }
+
+    private void copyStringParam(Bundle bundle, HashMap<String, String> params, String key) {
+        String value = params.get(key);
+        if (value != null) {
+            bundle.putString(key, value);
+        }
+    }
+
+    private void copyIntParam(Bundle bundle, HashMap<String, String> params, String key) {
+        String valueString = params.get(key);
+        if (!TextUtils.isEmpty(valueString)) {
+            try {
+                int value = Integer.parseInt(valueString);
+                bundle.putInt(key, value);
+            } catch (NumberFormatException ex) {
+                // don't set the value in the bundle
+            }
+        }
+    }
+
+    private void copyFloatParam(Bundle bundle, HashMap<String, String> params, String key) {
+        String valueString = params.get(key);
+        if (!TextUtils.isEmpty(valueString)) {
+            try {
+                float value = Float.parseFloat(valueString);
+                bundle.putFloat(key, value);
+            } catch (NumberFormatException ex) {
+                // don't set the value in the bundle
+            }
+        }
+    }
+
+    /**
+     * Sets the listener that will be notified when synthesis of an utterance completes.
+     *
+     * @param listener The listener to use.
+     *
+     * @return {@link #ERROR} or {@link #SUCCESS}.
+     *
+     * @deprecated Use {@link #setOnUtteranceProgressListener(UtteranceProgressListener)}
+     *        instead.
+     */
+    @Deprecated
+    public int setOnUtteranceCompletedListener(final OnUtteranceCompletedListener listener) {
+        mUtteranceProgressListener = UtteranceProgressListener.from(listener);
+        return TextToSpeech.SUCCESS;
+    }
+
+    /**
+     * Sets the listener that will be notified of various events related to the
+     * synthesis of a given utterance.
+     *
+     * See {@link UtteranceProgressListener} and
+     * {@link TextToSpeech.Engine#KEY_PARAM_UTTERANCE_ID}.
+     *
+     * @param listener the listener to use.
+     * @return {@link #ERROR} or {@link #SUCCESS}
+     */
+    public int setOnUtteranceProgressListener(UtteranceProgressListener listener) {
+        mUtteranceProgressListener = listener;
+        return TextToSpeech.SUCCESS;
+    }
+
+    /**
+     * Sets the TTS engine to use.
+     *
+     * @deprecated This doesn't inform callers when the TTS engine has been
+     *        initialized. {@link #TextToSpeech(Context, OnInitListener, String)}
+     *        can be used with the appropriate engine name. Also, there is no
+     *        guarantee that the engine specified will be loaded. If it isn't
+     *        installed or disabled, the user / system wide defaults will apply.
+     *
+     * @param enginePackageName The package name for the synthesis engine (e.g. "com.svox.pico")
+     *
+     * @return {@link #ERROR} or {@link #SUCCESS}.
+     */
+    @Deprecated
+    public int setEngineByPackageName(String enginePackageName) {
+        mRequestedEngine = enginePackageName;
+        return initTts();
+    }
+
+    /**
+     * Gets the package name of the default speech synthesis engine.
+     *
+     * @return Package name of the TTS engine that the user has chosen
+     *        as their default.
+     */
+    public String getDefaultEngine() {
+        return mEnginesHelper.getDefaultEngine();
+    }
+
+    /**
+     * Checks whether the user's settings should override settings requested
+     * by the calling application. As of the Ice cream sandwich release,
+     * user settings never forcibly override the app's settings.
+     */
+    public boolean areDefaultsEnforced() {
+        return false;
+    }
+
+    /**
+     * Gets a list of all installed TTS engines.
+     *
+     * @return A list of engine info objects. The list can be empty, but never {@code null}.
+     */
+    public List<EngineInfo> getEngines() {
+        return mEnginesHelper.getEngines();
+    }
+
+
+    private class Connection implements ServiceConnection {
+        private ITextToSpeechService mService;
+        private final ITextToSpeechCallback.Stub mCallback = new ITextToSpeechCallback.Stub() {
+            @Override
+            public void onDone(String utteranceId) {
+                UtteranceProgressListener listener = mUtteranceProgressListener;
+                if (listener != null) {
+                    listener.onDone(utteranceId);
+                }
+            }
+
+            @Override
+            public void onError(String utteranceId) {
+                UtteranceProgressListener listener = mUtteranceProgressListener;
+                if (listener != null) {
+                    listener.onError(utteranceId);
+                }
+            }
+
+            @Override
+            public void onStart(String utteranceId) {
+                UtteranceProgressListener listener = mUtteranceProgressListener;
+                if (listener != null) {
+                    listener.onStart(utteranceId);
+                }
+            }
+        };
+
+        public void onServiceConnected(ComponentName name, IBinder service) {
+            Log.i(TAG, "Connected to " + name);
+            synchronized(mStartLock) {
+                if (mServiceConnection != null) {
+                    // Disconnect any previous service connection
+                    mServiceConnection.disconnect();
+                }
+                mServiceConnection = this;
+                mService = ITextToSpeechService.Stub.asInterface(service);
+                try {
+                    mService.setCallback(getCallerIdentity(), mCallback);
+                    dispatchOnInit(SUCCESS);
+                } catch (RemoteException re) {
+                    Log.e(TAG, "Error connecting to service, setCallback() failed");
+                    dispatchOnInit(ERROR);
+                }
+            }
+        }
+
+        public IBinder getCallerIdentity() {
+            return mCallback;
+        }
+
+        public void onServiceDisconnected(ComponentName name) {
+            synchronized(mStartLock) {
+                mService = null;
+                // If this is the active connection, clear it
+                if (mServiceConnection == this) {
+                    mServiceConnection = null;
+                }
+            }
+        }
+
+        public void disconnect() {
+            mContext.unbindService(this);
+        }
+
+        public <R> R runAction(Action<R> action, R errorResult, String method, boolean reconnect) {
+            try {
+                synchronized (mStartLock) {
+                    if (mService == null) {
+                        Log.w(TAG, method + " failed: not connected to TTS engine");
+                        return errorResult;
+                    }
+                    return action.run(mService);
+                }
+            } catch (RemoteException ex) {
+                Log.e(TAG, method + " failed", ex);
+                if (reconnect) {
+                    disconnect();
+                    initTts();
+                }
+                return errorResult;
+            }
+        }
+    }
+
+    private interface Action<R> {
+        R run(ITextToSpeechService service) throws RemoteException;
+    }
+
+    /**
+     * Information about an installed text-to-speech engine.
+     *
+     * @see TextToSpeech#getEngines
+     */
+    public static class EngineInfo {
+        /**
+         * Engine package name..
+         */
+        public String name;
+        /**
+         * Localized label for the engine.
+         */
+        public String label;
+        /**
+         * Icon for the engine.
+         */
+        public int icon;
+        /**
+         * Whether this engine is a part of the system
+         * image.
+         *
+         * @hide
+         */
+        public boolean system;
+        /**
+         * The priority the engine declares for the the intent filter
+         * {@code android.intent.action.TTS_SERVICE}
+         *
+         * @hide
+         */
+        public int priority;
+
+        @Override
+        public String toString() {
+            return "EngineInfo{name=" + name + "}";
+        }
+
+    }
+
+}
diff --git a/src/frameworks/base/core/java/android/text/SpanSet.java b/src/frameworks/base/core/java/android/text/SpanSet.java
new file mode 100644
index 0000000..3ca6033
--- /dev/null
+++ b/src/frameworks/base/core/java/android/text/SpanSet.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.text;
+
+import java.lang.reflect.Array;
+
+/**
+ * A cached set of spans. Caches the result of {@link Spanned#getSpans(int, int, Class)} and then
+ * provides faster access to {@link Spanned#nextSpanTransition(int, int, Class)}.
+ *
+ * Fields are left public for a convenient direct access.
+ *
+ * Note that empty spans are ignored by this class.
+ * @hide
+ */
+public class SpanSet<E> {
+    private final Class<? extends E> classType;
+
+    int numberOfSpans;
+    E[] spans;
+    int[] spanStarts;
+    int[] spanEnds;
+    int[] spanFlags;
+
+    SpanSet(Class<? extends E> type) {
+        classType = type;
+        numberOfSpans = 0;
+    }
+
+    @SuppressWarnings("unchecked")
+    public void init(Spanned spanned, int start, int limit) {
+        final E[] allSpans = spanned.getSpans(start, limit, classType);
+        final int length = allSpans.length;
+
+        if (length > 0 && (spans == null || spans.length < length)) {
+            // These arrays may end up being too large because of the discarded empty spans
+            spans = (E[]) Array.newInstance(classType, length);
+            spanStarts = new int[length];
+            spanEnds = new int[length];
+            spanFlags = new int[length];
+        }
+
+        numberOfSpans = 0;
+        for (int i = 0; i < length; i++) {
+            final E span = allSpans[i];
+
+            final int spanStart = spanned.getSpanStart(span);
+            final int spanEnd = spanned.getSpanEnd(span);
+            if (spanStart == spanEnd) continue;
+
+            final int spanFlag = spanned.getSpanFlags(span);
+
+            spans[numberOfSpans] = span;
+            spanStarts[numberOfSpans] = spanStart;
+            spanEnds[numberOfSpans] = spanEnd;
+            spanFlags[numberOfSpans] = spanFlag;
+
+            numberOfSpans++;
+        }
+    }
+
+    /**
+     * Returns true if there are spans intersecting the given interval.
+     * @param end must be strictly greater than start
+     */
+    public boolean hasSpansIntersecting(int start, int end) {
+        for (int i = 0; i < numberOfSpans; i++) {
+            // equal test is valid since both intervals are not empty by construction
+            if (spanStarts[i] >= end || spanEnds[i] <= start) continue;
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Similar to {@link Spanned#nextSpanTransition(int, int, Class)}
+     */
+    int getNextTransition(int start, int limit) {
+        for (int i = 0; i < numberOfSpans; i++) {
+            final int spanStart = spanStarts[i];
+            final int spanEnd = spanEnds[i];
+            if (spanStart > start && spanStart < limit) limit = spanStart;
+            if (spanEnd > start && spanEnd < limit) limit = spanEnd;
+        }
+        return limit;
+    }
+
+    /**
+     * Removes all internal references to the spans to avoid memory leaks.
+     */
+    public void recycle() {
+        // The spans array is guaranteed to be not null when numberOfSpans is > 0
+        for (int i = 0; i < numberOfSpans; i++) {
+            spans[i] = null; // prevent a leak: no reference kept when TextLine is recycled
+        }
+    }
+}
diff --git a/src/frameworks/base/core/java/android/util/TypedValue.java b/src/frameworks/base/core/java/android/util/TypedValue.java
new file mode 100644
index 0000000..ed45298
--- /dev/null
+++ b/src/frameworks/base/core/java/android/util/TypedValue.java
@@ -0,0 +1,494 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.util;
+
+/**
+ * Container for a dynamically typed data value.  Primarily used with
+ * {@link android.content.res.Resources} for holding resource values.
+ */
+public class TypedValue {
+    /** The value contains no data. */
+    public static final int TYPE_NULL = 0x00;
+
+    /** The <var>data</var> field holds a resource identifier. */
+    public static final int TYPE_REFERENCE = 0x01;
+    /** The <var>data</var> field holds an attribute resource
+     *  identifier (referencing an attribute in the current theme
+     *  style, not a resource entry). */
+    public static final int TYPE_ATTRIBUTE = 0x02;
+    /** The <var>string</var> field holds string data.  In addition, if
+     *  <var>data</var> is non-zero then it is the string block
+     *  index of the string and <var>assetCookie</var> is the set of
+     *  assets the string came from. */
+    public static final int TYPE_STRING = 0x03;
+    /** The <var>data</var> field holds an IEEE 754 floating point number. */
+    public static final int TYPE_FLOAT = 0x04;
+    /** The <var>data</var> field holds a complex number encoding a
+     *  dimension value. */
+    public static final int TYPE_DIMENSION = 0x05;
+    /** The <var>data</var> field holds a complex number encoding a fraction
+     *  of a container. */
+    public static final int TYPE_FRACTION = 0x06;
+
+    /** Identifies the start of plain integer values.  Any type value
+     *  from this to {@link #TYPE_LAST_INT} means the
+     *  <var>data</var> field holds a generic integer value. */
+    public static final int TYPE_FIRST_INT = 0x10;
+
+    /** The <var>data</var> field holds a number that was
+     *  originally specified in decimal. */
+    public static final int TYPE_INT_DEC = 0x10;
+    /** The <var>data</var> field holds a number that was
+     *  originally specified in hexadecimal (0xn). */
+    public static final int TYPE_INT_HEX = 0x11;
+    /** The <var>data</var> field holds 0 or 1 that was originally
+     *  specified as "false" or "true". */
+    public static final int TYPE_INT_BOOLEAN = 0x12;
+
+    /** Identifies the start of integer values that were specified as
+     *  color constants (starting with '#'). */
+    public static final int TYPE_FIRST_COLOR_INT = 0x1c;
+
+    /** The <var>data</var> field holds a color that was originally
+     *  specified as #aarrggbb. */
+    public static final int TYPE_INT_COLOR_ARGB8 = 0x1c;
+    /** The <var>data</var> field holds a color that was originally
+     *  specified as #rrggbb. */
+    public static final int TYPE_INT_COLOR_RGB8 = 0x1d;
+    /** The <var>data</var> field holds a color that was originally
+     *  specified as #argb. */
+    public static final int TYPE_INT_COLOR_ARGB4 = 0x1e;
+    /** The <var>data</var> field holds a color that was originally
+     *  specified as #rgb. */
+    public static final int TYPE_INT_COLOR_RGB4 = 0x1f;
+
+    /** Identifies the end of integer values that were specified as color
+     *  constants. */
+    public static final int TYPE_LAST_COLOR_INT = 0x1f;
+
+    /** Identifies the end of plain integer values. */
+    public static final int TYPE_LAST_INT = 0x1f;
+
+    /* ------------------------------------------------------------ */
+
+    /** Complex data: bit location of unit information. */
+    public static final int COMPLEX_UNIT_SHIFT = 0;
+    /** Complex data: mask to extract unit information (after shifting by
+     *  {@link #COMPLEX_UNIT_SHIFT}). This gives us 16 possible types, as
+     *  defined below. */
+    public static final int COMPLEX_UNIT_MASK = 0xf;
+
+    /** {@link #TYPE_DIMENSION} complex unit: Value is raw pixels. */
+    public static final int COMPLEX_UNIT_PX = 0;
+    /** {@link #TYPE_DIMENSION} complex unit: Value is Device Independent
+     *  Pixels. */
+    public static final int COMPLEX_UNIT_DIP = 1;
+    /** {@link #TYPE_DIMENSION} complex unit: Value is a scaled pixel. */
+    public static final int COMPLEX_UNIT_SP = 2;
+    /** {@link #TYPE_DIMENSION} complex unit: Value is in points. */
+    public static final int COMPLEX_UNIT_PT = 3;
+    /** {@link #TYPE_DIMENSION} complex unit: Value is in inches. */
+    public static final int COMPLEX_UNIT_IN = 4;
+    /** {@link #TYPE_DIMENSION} complex unit: Value is in millimeters. */
+    public static final int COMPLEX_UNIT_MM = 5;
+
+    /** {@link #TYPE_FRACTION} complex unit: A basic fraction of the overall
+     *  size. */
+    public static final int COMPLEX_UNIT_FRACTION = 0;
+    /** {@link #TYPE_FRACTION} complex unit: A fraction of the parent size. */
+    public static final int COMPLEX_UNIT_FRACTION_PARENT = 1;
+
+    /** Complex data: where the radix information is, telling where the decimal
+     *  place appears in the mantissa. */
+    public static final int COMPLEX_RADIX_SHIFT = 4;
+    /** Complex data: mask to extract radix information (after shifting by
+     * {@link #COMPLEX_RADIX_SHIFT}). This give us 4 possible fixed point 
+     * representations as defined below. */ 
+    public static final int COMPLEX_RADIX_MASK = 0x3;
+
+    /** Complex data: the mantissa is an integral number -- i.e., 0xnnnnnn.0 */
+    public static final int COMPLEX_RADIX_23p0 = 0;
+    /** Complex data: the mantissa magnitude is 16 bits -- i.e, 0xnnnn.nn */
+    public static final int COMPLEX_RADIX_16p7 = 1;
+    /** Complex data: the mantissa magnitude is 8 bits -- i.e, 0xnn.nnnn */
+    public static final int COMPLEX_RADIX_8p15 = 2;
+    /** Complex data: the mantissa magnitude is 0 bits -- i.e, 0x0.nnnnnn */
+    public static final int COMPLEX_RADIX_0p23 = 3;
+
+    /** Complex data: bit location of mantissa information. */
+    public static final int COMPLEX_MANTISSA_SHIFT = 8;
+    /** Complex data: mask to extract mantissa information (after shifting by
+     *  {@link #COMPLEX_MANTISSA_SHIFT}). This gives us 23 bits of precision;
+     *  the top bit is the sign. */
+    public static final int COMPLEX_MANTISSA_MASK = 0xffffff;
+
+    /* ------------------------------------------------------------ */
+
+    /**
+     * If {@link #density} is equal to this value, then the density should be
+     * treated as the system's default density value: {@link DisplayMetrics#DENSITY_DEFAULT}.
+     */
+    public static final int DENSITY_DEFAULT = 0;
+
+    /**
+     * If {@link #density} is equal to this value, then there is no density
+     * associated with the resource and it should not be scaled.
+     */
+    public static final int DENSITY_NONE = 0xffff;
+
+    /* ------------------------------------------------------------ */
+
+    /** The type held by this value, as defined by the constants here.
+     *  This tells you how to interpret the other fields in the object. */
+    public int type;
+
+    /** If the value holds a string, this is it. */
+    public CharSequence string;
+
+    /** Basic data in the value, interpreted according to {@link #type} */
+    public int data;
+
+    /** Additional information about where the value came from; only
+     *  set for strings. */
+    public int assetCookie;
+
+    /** If Value came from a resource, this holds the corresponding resource id. */
+    public int resourceId;
+
+    /** If Value came from a resource, these are the configurations for which
+     *  its contents can change. */
+    public int changingConfigurations = -1;
+
+    /**
+     * If the Value came from a resource, this holds the corresponding pixel density.
+     * */
+    public int density;
+
+    /* ------------------------------------------------------------ */
+
+    /** Return the data for this value as a float.  Only use for values
+     *  whose type is {@link #TYPE_FLOAT}. */
+    public final float getFloat() {
+        return Float.intBitsToFloat(data);
+    }
+
+    private static final float MANTISSA_MULT =
+        1.0f / (1<<TypedValue.COMPLEX_MANTISSA_SHIFT);
+    private static final float[] RADIX_MULTS = new float[] {
+        1.0f*MANTISSA_MULT, 1.0f/(1<<7)*MANTISSA_MULT,
+        1.0f/(1<<15)*MANTISSA_MULT, 1.0f/(1<<23)*MANTISSA_MULT
+    };
+
+    /**
+     * Retrieve the base value from a complex data integer.  This uses the 
+     * {@link #COMPLEX_MANTISSA_MASK} and {@link #COMPLEX_RADIX_MASK} fields of 
+     * the data to compute a floating point representation of the number they 
+     * describe.  The units are ignored. 
+     *  
+     * @param complex A complex data value.
+     * 
+     * @return A floating point value corresponding to the complex data.
+     */
+    public static float complexToFloat(int complex)
+    {
+        return (complex&(TypedValue.COMPLEX_MANTISSA_MASK
+                   <<TypedValue.COMPLEX_MANTISSA_SHIFT))
+            * RADIX_MULTS[(complex>>TypedValue.COMPLEX_RADIX_SHIFT)
+                            & TypedValue.COMPLEX_RADIX_MASK];
+    }
+
+    /**
+     * Converts a complex data value holding a dimension to its final floating 
+     * point value. The given <var>data</var> must be structured as a 
+     * {@link #TYPE_DIMENSION}.
+     *  
+     * @param data A complex data value holding a unit, magnitude, and 
+     *             mantissa.
+     * @param metrics Current display metrics to use in the conversion -- 
+     *                supplies display density and scaling information.
+     * 
+     * @return The complex floating point value multiplied by the appropriate 
+     * metrics depending on its unit. 
+     */
+    public static float complexToDimension(int data, DisplayMetrics metrics)
+    {
+        return applyDimension(
+            (data>>COMPLEX_UNIT_SHIFT)&COMPLEX_UNIT_MASK,
+            complexToFloat(data),
+            metrics);
+    }
+
+    /**
+     * Converts a complex data value holding a dimension to its final value
+     * as an integer pixel offset.  This is the same as
+     * {@link #complexToDimension}, except the raw floating point value is
+     * truncated to an integer (pixel) value.
+     * The given <var>data</var> must be structured as a 
+     * {@link #TYPE_DIMENSION}.
+     *  
+     * @param data A complex data value holding a unit, magnitude, and 
+     *             mantissa.
+     * @param metrics Current display metrics to use in the conversion -- 
+     *                supplies display density and scaling information.
+     * 
+     * @return The number of pixels specified by the data and its desired
+     * multiplier and units.
+     */
+    public static int complexToDimensionPixelOffset(int data,
+            DisplayMetrics metrics)
+    {
+        return (int)applyDimension(
+                (data>>COMPLEX_UNIT_SHIFT)&COMPLEX_UNIT_MASK,
+                complexToFloat(data),
+                metrics);
+    }
+
+    /**
+     * Converts a complex data value holding a dimension to its final value
+     * as an integer pixel size.  This is the same as
+     * {@link #complexToDimension}, except the raw floating point value is
+     * converted to an integer (pixel) value for use as a size.  A size
+     * conversion involves rounding the base value, and ensuring that a
+     * non-zero base value is at least one pixel in size.
+     * The given <var>data</var> must be structured as a 
+     * {@link #TYPE_DIMENSION}.
+     *  
+     * @param data A complex data value holding a unit, magnitude, and 
+     *             mantissa.
+     * @param metrics Current display metrics to use in the conversion -- 
+     *                supplies display density and scaling information.
+     * 
+     * @return The number of pixels specified by the data and its desired
+     * multiplier and units.
+     */
+    public static int complexToDimensionPixelSize(int data,
+            DisplayMetrics metrics)
+    {
+        final float value = complexToFloat(data);
+        final float f = applyDimension(
+                (data>>COMPLEX_UNIT_SHIFT)&COMPLEX_UNIT_MASK,
+                value,
+                metrics);
+        final int res = (int)(f+0.5f);
+        if (res != 0) return res;
+        if (value == 0) return 0;
+        if (value > 0) return 1;
+        return -1;
+    }
+
+    public static float complexToDimensionNoisy(int data, DisplayMetrics metrics)
+    {
+        float res = complexToDimension(data, metrics);
+        System.out.println(
+            "Dimension (0x" + ((data>>TypedValue.COMPLEX_MANTISSA_SHIFT)
+                               & TypedValue.COMPLEX_MANTISSA_MASK)
+            + "*" + (RADIX_MULTS[(data>>TypedValue.COMPLEX_RADIX_SHIFT)
+                                & TypedValue.COMPLEX_RADIX_MASK] / MANTISSA_MULT)
+            + ")" + DIMENSION_UNIT_STRS[(data>>COMPLEX_UNIT_SHIFT)
+                                & COMPLEX_UNIT_MASK]
+            + " = " + res);
+        return res;
+    }
+
+    /**
+     * Converts an unpacked complex data value holding a dimension to its final floating 
+     * point value. The two parameters <var>unit</var> and <var>value</var>
+     * are as in {@link #TYPE_DIMENSION}.
+     *  
+     * @param unit The unit to convert from.
+     * @param value The value to apply the unit to.
+     * @param metrics Current display metrics to use in the conversion -- 
+     *                supplies display density and scaling information.
+     * 
+     * @return The complex floating point value multiplied by the appropriate 
+     * metrics depending on its unit. 
+     */
+    public static float applyDimension(int unit, float value,
+                                       DisplayMetrics metrics)
+    {
+        switch (unit) {
+        case COMPLEX_UNIT_PX:
+            return value;
+        case COMPLEX_UNIT_DIP:
+            return value * metrics.density;
+        case COMPLEX_UNIT_SP:
+            return value * metrics.scaledDensity;
+        case COMPLEX_UNIT_PT:
+            return value * metrics.xdpi * (1.0f/72);
+        case COMPLEX_UNIT_IN:
+            return value * metrics.xdpi;
+        case COMPLEX_UNIT_MM:
+            return value * metrics.xdpi * (1.0f/25.4f);
+        }
+        return 0;
+    }
+
+    /**
+     * Return the data for this value as a dimension.  Only use for values 
+     * whose type is {@link #TYPE_DIMENSION}. 
+     * 
+     * @param metrics Current display metrics to use in the conversion -- 
+     *                supplies display density and scaling information.
+     * 
+     * @return The complex floating point value multiplied by the appropriate 
+     * metrics depending on its unit. 
+     */
+    public float getDimension(DisplayMetrics metrics)
+    {
+        return complexToDimension(data, metrics);
+    }
+
+    /**
+     * Converts a complex data value holding a fraction to its final floating 
+     * point value. The given <var>data</var> must be structured as a 
+     * {@link #TYPE_FRACTION}.
+     * 
+     * @param data A complex data value holding a unit, magnitude, and 
+     *             mantissa.
+     * @param base The base value of this fraction.  In other words, a 
+     *             standard fraction is multiplied by this value.
+     * @param pbase The parent base value of this fraction.  In other 
+     *             words, a parent fraction (nn%p) is multiplied by this
+     *             value.
+     * 
+     * @return The complex floating point value multiplied by the appropriate 
+     * base value depending on its unit. 
+     */
+    public static float complexToFraction(int data, float base, float pbase)
+    {
+        switch ((data>>COMPLEX_UNIT_SHIFT)&COMPLEX_UNIT_MASK) {
+        case COMPLEX_UNIT_FRACTION:
+            return complexToFloat(data) * base;
+        case COMPLEX_UNIT_FRACTION_PARENT:
+            return complexToFloat(data) * pbase;
+        }
+        return 0;
+    }
+
+    /**
+     * Return the data for this value as a fraction.  Only use for values whose 
+     * type is {@link #TYPE_FRACTION}. 
+     * 
+     * @param base The base value of this fraction.  In other words, a 
+     *             standard fraction is multiplied by this value.
+     * @param pbase The parent base value of this fraction.  In other 
+     *             words, a parent fraction (nn%p) is multiplied by this
+     *             value.
+     * 
+     * @return The complex floating point value multiplied by the appropriate 
+     * base value depending on its unit. 
+     */
+    public float getFraction(float base, float pbase)
+    {
+        return complexToFraction(data, base, pbase);
+    }
+
+    /**
+     * Regardless of the actual type of the value, try to convert it to a
+     * string value.  For example, a color type will be converted to a
+     * string of the form #aarrggbb.
+     * 
+     * @return CharSequence The coerced string value.  If the value is
+     *         null or the type is not known, null is returned.
+     */
+    public final CharSequence coerceToString()
+    {
+        int t = type;
+        if (t == TYPE_STRING) {
+            return string;
+        }
+        return coerceToString(t, data);
+    }
+
+    private static final String[] DIMENSION_UNIT_STRS = new String[] {
+        "px", "dip", "sp", "pt", "in", "mm"
+    };
+    private static final String[] FRACTION_UNIT_STRS = new String[] {
+        "%", "%p"
+    };
+
+    /**
+     * Perform type conversion as per {@link #coerceToString()} on an
+     * explicitly supplied type and data.
+     * 
+     * @param type The data type identifier.
+     * @param data The data value.
+     * 
+     * @return String The coerced string value.  If the value is
+     *         null or the type is not known, null is returned.
+     */
+    public static final String coerceToString(int type, int data)
+    {
+        switch (type) {
+        case TYPE_NULL:
+            return null;
+        case TYPE_REFERENCE:
+            return "@" + data;
+        case TYPE_ATTRIBUTE:
+            return "?" + data;
+        case TYPE_FLOAT:
+            return Float.toString(Float.intBitsToFloat(data));
+        case TYPE_DIMENSION:
+            return Float.toString(complexToFloat(data)) + DIMENSION_UNIT_STRS[
+                (data>>COMPLEX_UNIT_SHIFT)&COMPLEX_UNIT_MASK];
+        case TYPE_FRACTION:
+            return Float.toString(complexToFloat(data)*100) + FRACTION_UNIT_STRS[
+                (data>>COMPLEX_UNIT_SHIFT)&COMPLEX_UNIT_MASK];
+        case TYPE_INT_HEX:
+            return "0x" + Integer.toHexString(data);
+        case TYPE_INT_BOOLEAN:
+            return data != 0 ? "true" : "false";
+        }
+
+        if (type >= TYPE_FIRST_COLOR_INT && type <= TYPE_LAST_COLOR_INT) {
+            return "#" + Integer.toHexString(data);
+        } else if (type >= TYPE_FIRST_INT && type <= TYPE_LAST_INT) {
+            return Integer.toString(data);
+        }
+
+        return null;
+    }
+
+    public void setTo(TypedValue other)
+    {
+        type = other.type;
+        string = other.string;
+        data = other.data;
+        assetCookie = other.assetCookie;
+        resourceId = other.resourceId;
+        density = other.density;
+    }
+
+    public String toString()
+    {
+        StringBuilder sb = new StringBuilder();
+        sb.append("TypedValue{t=0x").append(Integer.toHexString(type));
+        sb.append("/d=0x").append(Integer.toHexString(data));
+        if (type == TYPE_STRING) {
+            sb.append(" \"").append(string != null ? string : "<null>").append("\"");
+        }
+        if (assetCookie != 0) {
+            sb.append(" a=").append(assetCookie);
+        }
+        if (resourceId != 0) {
+            sb.append(" r=0x").append(Integer.toHexString(resourceId));
+        }
+        sb.append("}");
+        return sb.toString();
+    }
+};
+
diff --git a/src/frameworks/base/core/java/android/view/LayoutInflater.java b/src/frameworks/base/core/java/android/view/LayoutInflater.java
new file mode 100644
index 0000000..26a5b26
--- /dev/null
+++ b/src/frameworks/base/core/java/android/view/LayoutInflater.java
@@ -0,0 +1,932 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.view;
+
+import android.graphics.Canvas;
+import android.os.Handler;
+import android.os.Message;
+import android.widget.FrameLayout;
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.content.res.XmlResourceParser;
+import android.util.AttributeSet;
+import android.util.Xml;
+
+import java.io.IOException;
+import java.lang.reflect.Constructor;
+import java.util.HashMap;
+
+/**
+ * Instantiates a layout XML file into its corresponding {@link android.view.View}
+ * objects. It is never used directly. Instead, use
+ * {@link android.app.Activity#getLayoutInflater()} or
+ * {@link Context#getSystemService} to retrieve a standard LayoutInflater instance
+ * that is already hooked up to the current context and correctly configured
+ * for the device you are running on.  For example:
+ *
+ * <pre>LayoutInflater inflater = (LayoutInflater)context.getSystemService
+ *      (Context.LAYOUT_INFLATER_SERVICE);</pre>
+ * 
+ * <p>
+ * To create a new LayoutInflater with an additional {@link Factory} for your
+ * own views, you can use {@link #cloneInContext} to clone an existing
+ * ViewFactory, and then call {@link #setFactory} on it to include your
+ * Factory.
+ * 
+ * <p>
+ * For performance reasons, view inflation relies heavily on pre-processing of
+ * XML files that is done at build time. Therefore, it is not currently possible
+ * to use LayoutInflater with an XmlPullParser over a plain XML file at runtime;
+ * it only works with an XmlPullParser returned from a compiled resource
+ * (R.<em>something</em> file.)
+ * 
+ * @see Context#getSystemService
+ */
+public abstract class LayoutInflater {
+    private final boolean DEBUG = false;
+
+    /**
+     * This field should be made private, so it is hidden from the SDK.
+     * {@hide}
+     */
+    protected final Context mContext;
+
+    // these are optional, set by the caller
+    private boolean mFactorySet;
+    private Factory mFactory;
+    private Factory2 mFactory2;
+    private Factory2 mPrivateFactory;
+    private Filter mFilter;
+
+    final Object[] mConstructorArgs = new Object[2];
+
+    static final Class<?>[] mConstructorSignature = new Class[] {
+            Context.class, AttributeSet.class};
+
+    private static final HashMap<String, Constructor<? extends View>> sConstructorMap =
+            new HashMap<String, Constructor<? extends View>>();
+    
+    private HashMap<String, Boolean> mFilterMap;
+
+    private static final String TAG_MERGE = "merge";
+    private static final String TAG_INCLUDE = "include";
+    private static final String TAG_1995 = "blink";
+    private static final String TAG_REQUEST_FOCUS = "requestFocus";
+
+    /**
+     * Hook to allow clients of the LayoutInflater to restrict the set of Views that are allowed
+     * to be inflated.
+     * 
+     */
+    public interface Filter {
+        /**
+         * Hook to allow clients of the LayoutInflater to restrict the set of Views 
+         * that are allowed to be inflated.
+         * 
+         * @param clazz The class object for the View that is about to be inflated
+         * 
+         * @return True if this class is allowed to be inflated, or false otherwise
+         */
+        @SuppressWarnings("unchecked")
+        boolean onLoadClass(Class clazz);
+    }
+    
+    public interface Factory {
+        /**
+         * Hook you can supply that is called when inflating from a LayoutInflater.
+         * You can use this to customize the tag names available in your XML
+         * layout files.
+         * 
+         * <p>
+         * Note that it is good practice to prefix these custom names with your
+         * package (i.e., com.coolcompany.apps) to avoid conflicts with system
+         * names.
+         * 
+         * @param name Tag name to be inflated.
+         * @param context The context the view is being created in.
+         * @param attrs Inflation attributes as specified in XML file.
+         * 
+         * @return View Newly created view. Return null for the default
+         *         behavior.
+         */
+        public View onCreateView(String name, Context context, AttributeSet attrs);
+    }
+
+    public interface Factory2 extends Factory {
+        /**
+         * Version of {@link #onCreateView(String, Context, AttributeSet)}
+         * that also supplies the parent that the view created view will be
+         * placed in.
+         *
+         * @param parent The parent that the created view will be placed
+         * in; <em>note that this may be null</em>.
+         * @param name Tag name to be inflated.
+         * @param context The context the view is being created in.
+         * @param attrs Inflation attributes as specified in XML file.
+         *
+         * @return View Newly created view. Return null for the default
+         *         behavior.
+         */
+        public View onCreateView(View parent, String name, Context context, AttributeSet attrs);
+    }
+
+    private static class FactoryMerger implements Factory2 {
+        private final Factory mF1, mF2;
+        private final Factory2 mF12, mF22;
+        
+        FactoryMerger(Factory f1, Factory2 f12, Factory f2, Factory2 f22) {
+            mF1 = f1;
+            mF2 = f2;
+            mF12 = f12;
+            mF22 = f22;
+        }
+        
+        public View onCreateView(String name, Context context, AttributeSet attrs) {
+            View v = mF1.onCreateView(name, context, attrs);
+            if (v != null) return v;
+            return mF2.onCreateView(name, context, attrs);
+        }
+
+        public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
+            View v = mF12 != null ? mF12.onCreateView(parent, name, context, attrs)
+                    : mF1.onCreateView(name, context, attrs);
+            if (v != null) return v;
+            return mF22 != null ? mF22.onCreateView(parent, name, context, attrs)
+                    : mF2.onCreateView(name, context, attrs);
+        }
+    }
+    
+    /**
+     * Create a new LayoutInflater instance associated with a particular Context.
+     * Applications will almost always want to use
+     * {@link Context#getSystemService Context.getSystemService()} to retrieve
+     * the standard {@link Context#LAYOUT_INFLATER_SERVICE Context.INFLATER_SERVICE}.
+     * 
+     * @param context The Context in which this LayoutInflater will create its
+     * Views; most importantly, this supplies the theme from which the default
+     * values for their attributes are retrieved.
+     */
+    protected LayoutInflater(Context context) {
+        mContext = context;
+    }
+
+    /**
+     * Create a new LayoutInflater instance that is a copy of an existing
+     * LayoutInflater, optionally with its Context changed.  For use in
+     * implementing {@link #cloneInContext}.
+     * 
+     * @param original The original LayoutInflater to copy.
+     * @param newContext The new Context to use.
+     */
+    protected LayoutInflater(LayoutInflater original, Context newContext) {
+        mContext = newContext;
+        mFactory = original.mFactory;
+        mFactory2 = original.mFactory2;
+        mPrivateFactory = original.mPrivateFactory;
+        mFilter = original.mFilter;
+    }
+    
+    /**
+     * Obtains the LayoutInflater from the given context.
+     */
+    public static LayoutInflater from(Context context) {
+        LayoutInflater LayoutInflater =
+                (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        if (LayoutInflater == null) {
+            throw new AssertionError("LayoutInflater not found.");
+        }
+        return LayoutInflater;
+    }
+
+    /**
+     * Create a copy of the existing LayoutInflater object, with the copy
+     * pointing to a different Context than the original.  This is used by
+     * {@link ContextThemeWrapper} to create a new LayoutInflater to go along
+     * with the new Context theme.
+     * 
+     * @param newContext The new Context to associate with the new LayoutInflater.
+     * May be the same as the original Context if desired.
+     * 
+     * @return Returns a brand spanking new LayoutInflater object associated with
+     * the given Context.
+     */
+    public abstract LayoutInflater cloneInContext(Context newContext);
+    
+    /**
+     * Return the context we are running in, for access to resources, class
+     * loader, etc.
+     */
+    public Context getContext() {
+        return mContext;
+    }
+
+    /**
+     * Return the current {@link Factory} (or null). This is called on each element
+     * name. If the factory returns a View, add that to the hierarchy. If it
+     * returns null, proceed to call onCreateView(name).
+     */
+    public final Factory getFactory() {
+        return mFactory;
+    }
+
+    /**
+     * Return the current {@link Factory2}.  Returns null if no factory is set
+     * or the set factory does not implement the {@link Factory2} interface.
+     * This is called on each element
+     * name. If the factory returns a View, add that to the hierarchy. If it
+     * returns null, proceed to call onCreateView(name).
+     */
+    public final Factory2 getFactory2() {
+        return mFactory2;
+    }
+
+    /**
+     * Attach a custom Factory interface for creating views while using
+     * this LayoutInflater.  This must not be null, and can only be set once;
+     * after setting, you can not change the factory.  This is
+     * called on each element name as the xml is parsed. If the factory returns
+     * a View, that is added to the hierarchy. If it returns null, the next
+     * factory default {@link #onCreateView} method is called.
+     * 
+     * <p>If you have an existing
+     * LayoutInflater and want to add your own factory to it, use
+     * {@link #cloneInContext} to clone the existing instance and then you
+     * can use this function (once) on the returned new instance.  This will
+     * merge your own factory with whatever factory the original instance is
+     * using.
+     */
+    public void setFactory(Factory factory) {
+        if (mFactorySet) {
+            throw new IllegalStateException("A factory has already been set on this LayoutInflater");
+        }
+        if (factory == null) {
+            throw new NullPointerException("Given factory can not be null");
+        }
+        mFactorySet = true;
+        if (mFactory == null) {
+            mFactory = factory;
+        } else {
+            mFactory = new FactoryMerger(factory, null, mFactory, mFactory2);
+        }
+    }
+
+    /**
+     * Like {@link #setFactory}, but allows you to set a {@link Factory2}
+     * interface.
+     */
+    public void setFactory2(Factory2 factory) {
+        if (mFactorySet) {
+            throw new IllegalStateException("A factory has already been set on this LayoutInflater");
+        }
+        if (factory == null) {
+            throw new NullPointerException("Given factory can not be null");
+        }
+        mFactorySet = true;
+        if (mFactory == null) {
+            mFactory = mFactory2 = factory;
+        } else {
+            mFactory = new FactoryMerger(factory, factory, mFactory, mFactory2);
+        }
+    }
+
+    /**
+     * @hide for use by framework
+     */
+    public void setPrivateFactory(Factory2 factory) {
+        mPrivateFactory = factory;
+    }
+
+    /**
+     * @return The {@link Filter} currently used by this LayoutInflater to restrict the set of Views
+     * that are allowed to be inflated.
+     */
+    public Filter getFilter() {
+        return mFilter;
+    }
+    
+    /**
+     * Sets the {@link Filter} to by this LayoutInflater. If a view is attempted to be inflated
+     * which is not allowed by the {@link Filter}, the {@link #inflate(int, ViewGroup)} call will
+     * throw an {@link InflateException}. This filter will replace any previous filter set on this
+     * LayoutInflater.
+     * 
+     * @param filter The Filter which restricts the set of Views that are allowed to be inflated.
+     *        This filter will replace any previous filter set on this LayoutInflater.
+     */
+    public void setFilter(Filter filter) {
+        mFilter = filter;
+        if (filter != null) {
+            mFilterMap = new HashMap<String, Boolean>();
+        }
+    }
+
+    /**
+     * Inflate a new view hierarchy from the specified xml resource. Throws
+     * {@link InflateException} if there is an error.
+     * 
+     * @param resource ID for an XML layout resource to load (e.g.,
+     *        <code>R.layout.main_page</code>)
+     * @param root Optional view to be the parent of the generated hierarchy.
+     * @return The root View of the inflated hierarchy. If root was supplied,
+     *         this is the root View; otherwise it is the root of the inflated
+     *         XML file.
+     */
+    public View inflate(int resource, ViewGroup root) {
+        return inflate(resource, root, root != null);
+    }
+
+    /**
+     * Inflate a new view hierarchy from the specified xml node. Throws
+     * {@link InflateException} if there is an error. *
+     * <p>
+     * <em><strong>Important</strong></em>&nbsp;&nbsp;&nbsp;For performance
+     * reasons, view inflation relies heavily on pre-processing of XML files
+     * that is done at build time. Therefore, it is not currently possible to
+     * use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
+     * 
+     * @param parser XML dom node containing the description of the view
+     *        hierarchy.
+     * @param root Optional view to be the parent of the generated hierarchy.
+     * @return The root View of the inflated hierarchy. If root was supplied,
+     *         this is the root View; otherwise it is the root of the inflated
+     *         XML file.
+     */
+    public View inflate(XmlPullParser parser, ViewGroup root) {
+        return inflate(parser, root, root != null);
+    }
+
+    /**
+     * Inflate a new view hierarchy from the specified xml resource. Throws
+     * {@link InflateException} if there is an error.
+     * 
+     * @param resource ID for an XML layout resource to load (e.g.,
+     *        <code>R.layout.main_page</code>)
+     * @param root Optional view to be the parent of the generated hierarchy (if
+     *        <em>attachToRoot</em> is true), or else simply an object that
+     *        provides a set of LayoutParams values for root of the returned
+     *        hierarchy (if <em>attachToRoot</em> is false.)
+     * @param attachToRoot Whether the inflated hierarchy should be attached to
+     *        the root parameter? If false, root is only used to create the
+     *        correct subclass of LayoutParams for the root view in the XML.
+     * @return The root View of the inflated hierarchy. If root was supplied and
+     *         attachToRoot is true, this is root; otherwise it is the root of
+     *         the inflated XML file.
+     */
+    public View inflate(int resource, ViewGroup root, boolean attachToRoot) {
+        if (DEBUG) System.out.println("INFLATING from resource: " + resource);
+        XmlResourceParser parser = getContext().getResources().getLayout(resource);
+        try {
+            return inflate(parser, root, attachToRoot);
+        } finally {
+            parser.close();
+        }
+    }
+
+    /**
+     * Inflate a new view hierarchy from the specified XML node. Throws
+     * {@link InflateException} if there is an error.
+     * <p>
+     * <em><strong>Important</strong></em>&nbsp;&nbsp;&nbsp;For performance
+     * reasons, view inflation relies heavily on pre-processing of XML files
+     * that is done at build time. Therefore, it is not currently possible to
+     * use LayoutInflater with an XmlPullParser over a plain XML file at runtime.
+     * 
+     * @param parser XML dom node containing the description of the view
+     *        hierarchy.
+     * @param root Optional view to be the parent of the generated hierarchy (if
+     *        <em>attachToRoot</em> is true), or else simply an object that
+     *        provides a set of LayoutParams values for root of the returned
+     *        hierarchy (if <em>attachToRoot</em> is false.)
+     * @param attachToRoot Whether the inflated hierarchy should be attached to
+     *        the root parameter? If false, root is only used to create the
+     *        correct subclass of LayoutParams for the root view in the XML.
+     * @return The root View of the inflated hierarchy. If root was supplied and
+     *         attachToRoot is true, this is root; otherwise it is the root of
+     *         the inflated XML file.
+     */
+    public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) {
+        synchronized (mConstructorArgs) {
+            final AttributeSet attrs = Xml.asAttributeSet(parser);
+            Context lastContext = (Context)mConstructorArgs[0];
+            mConstructorArgs[0] = mContext;
+            View result = root;
+
+            try {
+                // Look for the root node.
+                int type;
+                while ((type = parser.next()) != XmlPullParser.START_TAG &&
+                        type != XmlPullParser.END_DOCUMENT) {
+                    // Empty
+                }
+
+                if (type != XmlPullParser.START_TAG) {
+                    throw new InflateException(parser.getPositionDescription()
+                            + ": No start tag found!");
+                }
+
+                final String name = parser.getName();
+                
+                if (DEBUG) {
+                    System.out.println("**************************");
+                    System.out.println("Creating root view: "
+                            + name);
+                    System.out.println("**************************");
+                }
+
+                if (TAG_MERGE.equals(name)) {
+                    if (root == null || !attachToRoot) {
+                        throw new InflateException("<merge /> can be used only with a valid "
+                                + "ViewGroup root and attachToRoot=true");
+                    }
+
+                    rInflate(parser, root, attrs, false);
+                } else {
+                    // Temp is the root view that was found in the xml
+                    View temp;
+                    if (TAG_1995.equals(name)) {
+                        temp = new BlinkLayout(mContext, attrs);
+                    } else {
+                        temp = createViewFromTag(root, name, attrs);
+                    }
+
+                    ViewGroup.LayoutParams params = null;
+
+                    if (root != null) {
+                        if (DEBUG) {
+                            System.out.println("Creating params from root: " +
+                                    root);
+                        }
+                        // Create layout params that match root, if supplied
+                        params = root.generateLayoutParams(attrs);
+                        if (!attachToRoot) {
+                            // Set the layout params for temp if we are not
+                            // attaching. (If we are, we use addView, below)
+                            temp.setLayoutParams(params);
+                        }
+                    }
+
+                    if (DEBUG) {
+                        System.out.println("-----> start inflating children");
+                    }
+                    // Inflate all children under temp
+                    rInflate(parser, temp, attrs, true);
+                    if (DEBUG) {
+                        System.out.println("-----> done inflating children");
+                    }
+
+                    // We are supposed to attach all the views we found (int temp)
+                    // to root. Do that now.
+                    if (root != null && attachToRoot) {
+                        root.addView(temp, params);
+                    }
+
+                    // Decide whether to return the root that was passed in or the
+                    // top view found in xml.
+                    if (root == null || !attachToRoot) {
+                        result = temp;
+                    }
+                }
+
+            } catch (XmlPullParserException e) {
+                InflateException ex = new InflateException(e.getMessage());
+                ex.initCause(e);
+                throw ex;
+            } catch (IOException e) {
+                InflateException ex = new InflateException(
+                        parser.getPositionDescription()
+                        + ": " + e.getMessage());
+                ex.initCause(e);
+                throw ex;
+            } finally {
+                // Don't retain static reference on context.
+                mConstructorArgs[0] = lastContext;
+                mConstructorArgs[1] = null;
+            }
+
+            return result;
+        }
+    }
+
+    /**
+     * Low-level function for instantiating a view by name. This attempts to
+     * instantiate a view class of the given <var>name</var> found in this
+     * LayoutInflater's ClassLoader.
+     * 
+     * <p>
+     * There are two things that can happen in an error case: either the
+     * exception describing the error will be thrown, or a null will be
+     * returned. You must deal with both possibilities -- the former will happen
+     * the first time createView() is called for a class of a particular name,
+     * the latter every time there-after for that class name.
+     * 
+     * @param name The full name of the class to be instantiated.
+     * @param attrs The XML attributes supplied for this instance.
+     * 
+     * @return View The newly instantiated view, or null.
+     */
+    public final View createView(String name, String prefix, AttributeSet attrs)
+            throws ClassNotFoundException, InflateException {
+        Constructor<? extends View> constructor = sConstructorMap.get(name);
+        Class<? extends View> clazz = null;
+
+        try {
+            if (constructor == null) {
+                // Class not found in the cache, see if it's real, and try to add it
+                clazz = mContext.getClassLoader().loadClass(
+                        prefix != null ? (prefix + name) : name).asSubclass(View.class);
+                
+                if (mFilter != null && clazz != null) {
+                    boolean allowed = mFilter.onLoadClass(clazz);
+                    if (!allowed) {
+                        failNotAllowed(name, prefix, attrs);
+                    }
+                }
+                constructor = clazz.getConstructor(mConstructorSignature);
+                sConstructorMap.put(name, constructor);
+            } else {
+                // If we have a filter, apply it to cached constructor
+                if (mFilter != null) {
+                    // Have we seen this name before?
+                    Boolean allowedState = mFilterMap.get(name);
+                    if (allowedState == null) {
+                        // New class -- remember whether it is allowed
+                        clazz = mContext.getClassLoader().loadClass(
+                                prefix != null ? (prefix + name) : name).asSubclass(View.class);
+                        
+                        boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
+                        mFilterMap.put(name, allowed);
+                        if (!allowed) {
+                            failNotAllowed(name, prefix, attrs);
+                        }
+                    } else if (allowedState.equals(Boolean.FALSE)) {
+                        failNotAllowed(name, prefix, attrs);
+                    }
+                }
+            }
+
+            Object[] args = mConstructorArgs;
+            args[1] = attrs;
+
+            final View view = constructor.newInstance(args);
+            if (view instanceof ViewStub) {
+                // always use ourselves when inflating ViewStub later
+                final ViewStub viewStub = (ViewStub) view;
+                viewStub.setLayoutInflater(this);
+            }
+            return view;
+
+        } catch (NoSuchMethodException e) {
+            InflateException ie = new InflateException(attrs.getPositionDescription()
+                    + ": Error inflating class "
+                    + (prefix != null ? (prefix + name) : name));
+            ie.initCause(e);
+            throw ie;
+
+        } catch (ClassCastException e) {
+            // If loaded class is not a View subclass
+            InflateException ie = new InflateException(attrs.getPositionDescription()
+                    + ": Class is not a View "
+                    + (prefix != null ? (prefix + name) : name));
+            ie.initCause(e);
+            throw ie;
+        } catch (ClassNotFoundException e) {
+            // If loadClass fails, we should propagate the exception.
+            throw e;
+        } catch (Exception e) {
+            InflateException ie = new InflateException(attrs.getPositionDescription()
+                    + ": Error inflating class "
+                    + (clazz == null ? "<unknown>" : clazz.getName()));
+            ie.initCause(e);
+            throw ie;
+        }
+    }
+
+    /**
+     * Throw an exception because the specified class is not allowed to be inflated.
+     */
+    private void failNotAllowed(String name, String prefix, AttributeSet attrs) {
+        throw new InflateException(attrs.getPositionDescription()
+                + ": Class not allowed to be inflated "
+                + (prefix != null ? (prefix + name) : name));
+    }
+
+    /**
+     * This routine is responsible for creating the correct subclass of View
+     * given the xml element name. Override it to handle custom view objects. If
+     * you override this in your subclass be sure to call through to
+     * super.onCreateView(name) for names you do not recognize.
+     * 
+     * @param name The fully qualified class name of the View to be create.
+     * @param attrs An AttributeSet of attributes to apply to the View.
+     * 
+     * @return View The View created.
+     */
+    protected View onCreateView(String name, AttributeSet attrs)
+            throws ClassNotFoundException {
+        return createView(name, "android.view.", attrs);
+    }
+
+    /**
+     * Version of {@link #onCreateView(String, AttributeSet)} that also
+     * takes the future parent of the view being constructure.  The default
+     * implementation simply calls {@link #onCreateView(String, AttributeSet)}.
+     *
+     * @param parent The future parent of the returned view.  <em>Note that
+     * this may be null.</em>
+     * @param name The fully qualified class name of the View to be create.
+     * @param attrs An AttributeSet of attributes to apply to the View.
+     *
+     * @return View The View created.
+     */
+    protected View onCreateView(View parent, String name, AttributeSet attrs)
+            throws ClassNotFoundException {
+        return onCreateView(name, attrs);
+    }
+
+    /*
+     * default visibility so the BridgeInflater can override it.
+     */
+    View createViewFromTag(View parent, String name, AttributeSet attrs) {
+        if (name.equals("view")) {
+            name = attrs.getAttributeValue(null, "class");
+        }
+
+        if (DEBUG) System.out.println("******** Creating view: " + name);
+
+        try {
+            View view;
+            if (mFactory2 != null) view = mFactory2.onCreateView(parent, name, mContext, attrs);
+            else if (mFactory != null) view = mFactory.onCreateView(name, mContext, attrs);
+            else view = null;
+
+            if (view == null && mPrivateFactory != null) {
+                view = mPrivateFactory.onCreateView(parent, name, mContext, attrs);
+            }
+            
+            if (view == null) {
+                if (-1 == name.indexOf('.')) {
+                    view = onCreateView(parent, name, attrs);
+                } else {
+                    view = createView(name, null, attrs);
+                }
+            }
+
+            if (DEBUG) System.out.println("Created view is: " + view);
+            return view;
+
+        } catch (InflateException e) {
+            throw e;
+
+        } catch (ClassNotFoundException e) {
+            InflateException ie = new InflateException(attrs.getPositionDescription()
+                    + ": Error inflating class " + name);
+            ie.initCause(e);
+            throw ie;
+
+        } catch (Exception e) {
+            InflateException ie = new InflateException(attrs.getPositionDescription()
+                    + ": Error inflating class " + name);
+            ie.initCause(e);
+            throw ie;
+        }
+    }
+
+    /**
+     * Recursive method used to descend down the xml hierarchy and instantiate
+     * views, instantiate their children, and then call onFinishInflate().
+     */
+    void rInflate(XmlPullParser parser, View parent, final AttributeSet attrs,
+            boolean finishInflate) throws XmlPullParserException, IOException {
+
+        final int depth = parser.getDepth();
+        int type;
+
+        while (((type = parser.next()) != XmlPullParser.END_TAG ||
+                parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {
+
+            if (type != XmlPullParser.START_TAG) {
+                continue;
+            }
+
+            final String name = parser.getName();
+            
+            if (TAG_REQUEST_FOCUS.equals(name)) {
+                parseRequestFocus(parser, parent);
+            } else if (TAG_INCLUDE.equals(name)) {
+                if (parser.getDepth() == 0) {
+                    throw new InflateException("<include /> cannot be the root element");
+                }
+                parseInclude(parser, parent, attrs);
+            } else if (TAG_MERGE.equals(name)) {
+                throw new InflateException("<merge /> must be the root element");
+            } else if (TAG_1995.equals(name)) {
+                final View view = new BlinkLayout(mContext, attrs);
+                final ViewGroup viewGroup = (ViewGroup) parent;
+                final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);
+                rInflate(parser, view, attrs, true);
+                viewGroup.addView(view, params);                
+            } else {
+                final View view = createViewFromTag(parent, name, attrs);
+                final ViewGroup viewGroup = (ViewGroup) parent;
+                final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);
+                rInflate(parser, view, attrs, true);
+                viewGroup.addView(view, params);
+            }
+        }
+
+        if (finishInflate) parent.onFinishInflate();
+    }
+
+    private void parseRequestFocus(XmlPullParser parser, View parent)
+            throws XmlPullParserException, IOException {
+        int type;
+        parent.requestFocus();
+        final int currentDepth = parser.getDepth();
+        while (((type = parser.next()) != XmlPullParser.END_TAG ||
+                parser.getDepth() > currentDepth) && type != XmlPullParser.END_DOCUMENT) {
+            // Empty
+        }
+    }
+
+    private void parseInclude(XmlPullParser parser, View parent, AttributeSet attrs)
+            throws XmlPullParserException, IOException {
+
+        int type;
+
+        if (parent instanceof ViewGroup) {
+            final int layout = attrs.getAttributeResourceValue(null, "layout", 0);
+            if (layout == 0) {
+                final String value = attrs.getAttributeValue(null, "layout");
+                if (value == null) {
+                    throw new InflateException("You must specifiy a layout in the"
+                            + " include tag: <include layout=\"@layout/layoutID\" />");
+                } else {
+                    throw new InflateException("You must specifiy a valid layout "
+                            + "reference. The layout ID " + value + " is not valid.");
+                }
+            } else {
+                final XmlResourceParser childParser =
+                        getContext().getResources().getLayout(layout);
+
+                try {
+                    final AttributeSet childAttrs = Xml.asAttributeSet(childParser);
+
+                    while ((type = childParser.next()) != XmlPullParser.START_TAG &&
+                            type != XmlPullParser.END_DOCUMENT) {
+                        // Empty.
+                    }
+
+                    if (type != XmlPullParser.START_TAG) {
+                        throw new InflateException(childParser.getPositionDescription() +
+                                ": No start tag found!");
+                    }
+
+                    final String childName = childParser.getName();
+
+                    if (TAG_MERGE.equals(childName)) {
+                        // Inflate all children.
+                        rInflate(childParser, parent, childAttrs, false);
+                    } else {
+                        final View view = createViewFromTag(parent, childName, childAttrs);
+                        final ViewGroup group = (ViewGroup) parent;
+
+                        // We try to load the layout params set in the <include /> tag. If
+                        // they don't exist, we will rely on the layout params set in the
+                        // included XML file.
+                        // During a layoutparams generation, a runtime exception is thrown
+                        // if either layout_width or layout_height is missing. We catch
+                        // this exception and set localParams accordingly: true means we
+                        // successfully loaded layout params from the <include /> tag,
+                        // false means we need to rely on the included layout params.
+                        ViewGroup.LayoutParams params = null;
+                        try {
+                            params = group.generateLayoutParams(attrs);
+                        } catch (RuntimeException e) {
+                            params = group.generateLayoutParams(childAttrs);
+                        } finally {
+                            if (params != null) {
+                                view.setLayoutParams(params);
+                            }
+                        }
+
+                        // Inflate all children.
+                        rInflate(childParser, view, childAttrs, true);
+
+                        // Attempt to override the included layout's android:id with the
+                        // one set on the <include /> tag itself.
+                        TypedArray a = mContext.obtainStyledAttributes(attrs,
+                            com.android.internal.R.styleable.View, 0, 0);
+                        int id = a.getResourceId(com.android.internal.R.styleable.View_id, View.NO_ID);
+                        // While we're at it, let's try to override android:visibility.
+                        int visibility = a.getInt(com.android.internal.R.styleable.View_visibility, -1);
+                        a.recycle();
+
+                        if (id != View.NO_ID) {
+                            view.setId(id);
+                        }
+
+                        switch (visibility) {
+                            case 0:
+                                view.setVisibility(View.VISIBLE);
+                                break;
+                            case 1:
+                                view.setVisibility(View.INVISIBLE);
+                                break;
+                            case 2:
+                                view.setVisibility(View.GONE);
+                                break;
+                        }
+
+                        group.addView(view);
+                    }
+                } finally {
+                    childParser.close();
+                }
+            }
+        } else {
+            throw new InflateException("<include /> can only be used inside of a ViewGroup");
+        }
+
+        final int currentDepth = parser.getDepth();
+        while (((type = parser.next()) != XmlPullParser.END_TAG ||
+                parser.getDepth() > currentDepth) && type != XmlPullParser.END_DOCUMENT) {
+            // Empty
+        }
+    }
+
+    private static class BlinkLayout extends FrameLayout {
+        private static final int MESSAGE_BLINK = 0x42;
+        private static final int BLINK_DELAY = 500;
+
+        private boolean mBlink;
+        private boolean mBlinkState;
+        private final Handler mHandler;
+
+        public BlinkLayout(Context context, AttributeSet attrs) {
+            super(context, attrs);
+            mHandler = new Handler(new Handler.Callback() {
+                @Override
+                public boolean handleMessage(Message msg) {
+                    if (msg.what == MESSAGE_BLINK) {
+                        if (mBlink) {
+                            mBlinkState = !mBlinkState;
+                            makeBlink();
+                        }
+                        invalidate();
+                        return true;
+                    }
+                    return false;
+                }
+            });
+        }
+
+        private void makeBlink() {
+            Message message = mHandler.obtainMessage(MESSAGE_BLINK);
+            mHandler.sendMessageDelayed(message, BLINK_DELAY);
+        }
+
+        @Override
+        protected void onAttachedToWindow() {
+            super.onAttachedToWindow();
+
+            mBlink = true;
+            mBlinkState = true;
+
+            makeBlink();
+        }
+
+        @Override
+        protected void onDetachedFromWindow() {
+            super.onDetachedFromWindow();
+
+            mBlink = false;
+            mBlinkState = true;
+
+            mHandler.removeMessages(MESSAGE_BLINK);
+        }
+
+        @Override
+        protected void dispatchDraw(Canvas canvas) {
+            if (mBlinkState) {
+                super.dispatchDraw(canvas);
+            }
+        }
+    }
+}
diff --git a/src/frameworks/base/core/java/android/view/ViewConfiguration.java b/src/frameworks/base/core/java/android/view/ViewConfiguration.java
new file mode 100644
index 0000000..823befb
--- /dev/null
+++ b/src/frameworks/base/core/java/android/view/ViewConfiguration.java
@@ -0,0 +1,705 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.view;
+
+import android.app.AppGlobals;
+import android.content.Context;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.os.RemoteException;
+import android.provider.Settings;
+import android.util.DisplayMetrics;
+import android.util.SparseArray;
+
+/**
+ * Contains methods to standard constants used in the UI for timeouts, sizes, and distances.
+ */
+public class ViewConfiguration {
+    /**
+     * Expected bit depth of the display panel.
+     *
+     * @hide
+     */
+    public static final float PANEL_BIT_DEPTH = 24;
+
+    /**
+     * Minimum alpha required for a view to draw.
+     *
+     * @hide
+     */
+    public static final float ALPHA_THRESHOLD = 0.5f / PANEL_BIT_DEPTH;
+    /**
+     * @hide
+     */
+    public static final float ALPHA_THRESHOLD_INT = 0x7f / PANEL_BIT_DEPTH;
+
+    /**
+     * Defines the width of the horizontal scrollbar and the height of the vertical scrollbar in
+     * dips
+     */
+    private static final int SCROLL_BAR_SIZE = 10;
+
+    /**
+     * Duration of the fade when scrollbars fade away in milliseconds
+     */
+    private static final int SCROLL_BAR_FADE_DURATION = 250;
+
+    /**
+     * Default delay before the scrollbars fade in milliseconds
+     */
+    private static final int SCROLL_BAR_DEFAULT_DELAY = 300;
+
+    /**
+     * Defines the length of the fading edges in dips
+     */
+    private static final int FADING_EDGE_LENGTH = 12;
+
+    /**
+     * Defines the duration in milliseconds of the pressed state in child
+     * components.
+     */
+    private static final int PRESSED_STATE_DURATION = 64;
+
+    /**
+     * Defines the default duration in milliseconds before a press turns into
+     * a long press
+     */
+    private static final int DEFAULT_LONG_PRESS_TIMEOUT = 500;
+
+    /**
+     * Defines the time between successive key repeats in milliseconds.
+     */
+    private static final int KEY_REPEAT_DELAY = 50;
+
+    /**
+     * Defines the duration in milliseconds a user needs to hold down the
+     * appropriate button to bring up the global actions dialog (power off,
+     * lock screen, etc).
+     */
+    private static final int GLOBAL_ACTIONS_KEY_TIMEOUT = 500;
+
+    /**
+     * Defines the duration in milliseconds we will wait to see if a touch event
+     * is a tap or a scroll. If the user does not move within this interval, it is
+     * considered to be a tap.
+     */
+    private static final int TAP_TIMEOUT = 180;
+
+    /**
+     * Defines the duration in milliseconds we will wait to see if a touch event
+     * is a jump tap. If the user does not complete the jump tap within this interval, it is
+     * considered to be a tap.
+     */
+    private static final int JUMP_TAP_TIMEOUT = 500;
+
+    /**
+     * Defines the duration in milliseconds between the first tap's up event and
+     * the second tap's down event for an interaction to be considered a
+     * double-tap.
+     */
+    private static final int DOUBLE_TAP_TIMEOUT = 300;
+
+    /**
+     * Defines the maximum duration in milliseconds between a touch pad
+     * touch and release for a given touch to be considered a tap (click) as
+     * opposed to a hover movement gesture.
+     */
+    private static final int HOVER_TAP_TIMEOUT = 150;
+
+    /**
+     * Defines the maximum distance in pixels that a touch pad touch can move
+     * before being released for it to be considered a tap (click) as opposed
+     * to a hover movement gesture.
+     */
+    private static final int HOVER_TAP_SLOP = 20;
+
+    /**
+     * Defines the duration in milliseconds we want to display zoom controls in response
+     * to a user panning within an application.
+     */
+    private static final int ZOOM_CONTROLS_TIMEOUT = 3000;
+
+    /**
+     * Inset in dips to look for touchable content when the user touches the edge of the screen
+     */
+    private static final int EDGE_SLOP = 12;
+
+    /**
+     * Distance a touch can wander before we think the user is scrolling in dips.
+     * Note that this value defined here is only used as a fallback by legacy/misbehaving
+     * applications that do not provide a Context for determining density/configuration-dependent
+     * values.
+     *
+     * To alter this value, see the configuration resource config_viewConfigurationTouchSlop
+     * in frameworks/base/core/res/res/values/config.xml or the appropriate device resource overlay.
+     * It may be appropriate to tweak this on a device-specific basis in an overlay based on
+     * the characteristics of the touch panel and firmware.
+     */
+    private static final int TOUCH_SLOP = 8;
+
+    /**
+     * Distance the first touch can wander before we stop considering this event a double tap
+     * (in dips)
+     */
+    private static final int DOUBLE_TAP_TOUCH_SLOP = TOUCH_SLOP;
+
+    /**
+     * Distance a touch can wander before we think the user is attempting a paged scroll
+     * (in dips)
+     *
+     * Note that this value defined here is only used as a fallback by legacy/misbehaving
+     * applications that do not provide a Context for determining density/configuration-dependent
+     * values.
+     *
+     * See the note above on {@link #TOUCH_SLOP} regarding the dimen resource
+     * config_viewConfigurationTouchSlop. ViewConfiguration will report a paging touch slop of
+     * config_viewConfigurationTouchSlop * 2 when provided with a Context.
+     */
+    private static final int PAGING_TOUCH_SLOP = TOUCH_SLOP * 2;
+
+    /**
+     * Distance in dips between the first touch and second touch to still be considered a double tap
+     */
+    private static final int DOUBLE_TAP_SLOP = 100;
+
+    /**
+     * Distance in dips a touch needs to be outside of a window's bounds for it to
+     * count as outside for purposes of dismissing the window.
+     */
+    private static final int WINDOW_TOUCH_SLOP = 16;
+
+    /**
+     * Minimum velocity to initiate a fling, as measured in dips per second
+     */
+    private static final int MINIMUM_FLING_VELOCITY = 50;
+
+    /**
+     * Maximum velocity to initiate a fling, as measured in dips per second
+     */
+    private static final int MAXIMUM_FLING_VELOCITY = 8000;
+
+    /**
+     * Delay before dispatching a recurring accessibility event in milliseconds.
+     * This delay guarantees that a recurring event will be send at most once
+     * during the {@link #SEND_RECURRING_ACCESSIBILITY_EVENTS_INTERVAL_MILLIS} time
+     * frame.
+     */
+    private static final long SEND_RECURRING_ACCESSIBILITY_EVENTS_INTERVAL_MILLIS = 100;
+
+    /**
+     * The maximum size of View's drawing cache, expressed in bytes. This size
+     * should be at least equal to the size of the screen in ARGB888 format.
+     */
+    @Deprecated
+    private static final int MAXIMUM_DRAWING_CACHE_SIZE = 480 * 800 * 4; // ARGB8888
+
+    /**
+     * The coefficient of friction applied to flings/scrolls.
+     */
+    private static final float SCROLL_FRICTION = 0.015f;
+
+    /**
+     * Max distance in dips to overscroll for edge effects
+     */
+    private static final int OVERSCROLL_DISTANCE = 0;
+
+    /**
+     * Max distance in dips to overfling for edge effects
+     */
+    private static final int OVERFLING_DISTANCE = 6;
+
+    private final int mEdgeSlop;
+    private final int mFadingEdgeLength;
+    private final int mMinimumFlingVelocity;
+    private final int mMaximumFlingVelocity;
+    private final int mScrollbarSize;
+    private final int mTouchSlop;
+    private final int mDoubleTapTouchSlop;
+    private final int mPagingTouchSlop;
+    private final int mDoubleTapSlop;
+    private final int mWindowTouchSlop;
+    private final int mMaximumDrawingCacheSize;
+    private final int mOverscrollDistance;
+    private final int mOverflingDistance;
+    private final boolean mFadingMarqueeEnabled;
+
+    private boolean sHasPermanentMenuKey;
+    private boolean sHasPermanentMenuKeySet;
+
+    static final SparseArray<ViewConfiguration> sConfigurations =
+            new SparseArray<ViewConfiguration>(2);
+
+    /**
+     * @deprecated Use {@link android.view.ViewConfiguration#get(android.content.Context)} instead.
+     */
+    @Deprecated
+    public ViewConfiguration() {
+        mEdgeSlop = EDGE_SLOP;
+        mFadingEdgeLength = FADING_EDGE_LENGTH;
+        mMinimumFlingVelocity = MINIMUM_FLING_VELOCITY;
+        mMaximumFlingVelocity = MAXIMUM_FLING_VELOCITY;
+        mScrollbarSize = SCROLL_BAR_SIZE;
+        mTouchSlop = TOUCH_SLOP;
+        mDoubleTapTouchSlop = DOUBLE_TAP_TOUCH_SLOP;
+        mPagingTouchSlop = PAGING_TOUCH_SLOP;
+        mDoubleTapSlop = DOUBLE_TAP_SLOP;
+        mWindowTouchSlop = WINDOW_TOUCH_SLOP;
+        //noinspection deprecation
+        mMaximumDrawingCacheSize = MAXIMUM_DRAWING_CACHE_SIZE;
+        mOverscrollDistance = OVERSCROLL_DISTANCE;
+        mOverflingDistance = OVERFLING_DISTANCE;
+        mFadingMarqueeEnabled = true;
+    }
+
+    /**
+     * Creates a new configuration for the specified context. The configuration depends on
+     * various parameters of the context, like the dimension of the display or the density
+     * of the display.
+     *
+     * @param context The application context used to initialize this view configuration.
+     *
+     * @see #get(android.content.Context)
+     * @see android.util.DisplayMetrics
+     */
+    private ViewConfiguration(Context context) {
+        final Resources res = context.getResources();
+        final DisplayMetrics metrics = res.getDisplayMetrics();
+        final Configuration config = res.getConfiguration();
+        final float density = metrics.density;
+        final float sizeAndDensity;
+        if (config.isLayoutSizeAtLeast(Configuration.SCREENLAYOUT_SIZE_XLARGE)) {
+            sizeAndDensity = density * 1.5f;
+        } else {
+            sizeAndDensity = density;
+        }
+
+        mEdgeSlop = (int) (sizeAndDensity * EDGE_SLOP + 0.5f);
+        mFadingEdgeLength = (int) (sizeAndDensity * FADING_EDGE_LENGTH + 0.5f);
+        mMinimumFlingVelocity = (int) (density * MINIMUM_FLING_VELOCITY + 0.5f);
+        mMaximumFlingVelocity = (int) (density * MAXIMUM_FLING_VELOCITY + 0.5f);
+        mScrollbarSize = (int) (density * SCROLL_BAR_SIZE + 0.5f);
+        mDoubleTapSlop = (int) (sizeAndDensity * DOUBLE_TAP_SLOP + 0.5f);
+        mWindowTouchSlop = (int) (sizeAndDensity * WINDOW_TOUCH_SLOP + 0.5f);
+
+        final Display display = WindowManagerImpl.getDefault().getDefaultDisplay();
+        // Size of the screen in bytes, in ARGB_8888 format
+        mMaximumDrawingCacheSize = 4 * display.getRawWidth() * display.getRawHeight();
+
+        mOverscrollDistance = (int) (sizeAndDensity * OVERSCROLL_DISTANCE + 0.5f);
+        mOverflingDistance = (int) (sizeAndDensity * OVERFLING_DISTANCE + 0.5f);
+
+        if (!sHasPermanentMenuKeySet) {
+            IWindowManager wm = Display.getWindowManager();
+            try {
+                sHasPermanentMenuKey = !wm.hasSystemNavBar() && !wm.hasNavigationBar();
+                sHasPermanentMenuKeySet = true;
+            } catch (RemoteException ex) {
+                sHasPermanentMenuKey = false;
+            }
+        }
+
+        mFadingMarqueeEnabled = res.getBoolean(
+                com.android.internal.R.bool.config_ui_enableFadingMarquee);
+        mTouchSlop = res.getDimensionPixelSize(
+                com.android.internal.R.dimen.config_viewConfigurationTouchSlop);
+        mPagingTouchSlop = mTouchSlop * 2;
+
+        mDoubleTapTouchSlop = mTouchSlop;
+    }
+
+    /**
+     * Returns a configuration for the specified context. The configuration depends on
+     * various parameters of the context, like the dimension of the display or the
+     * density of the display.
+     *
+     * @param context The application context used to initialize the view configuration.
+     */
+    public static ViewConfiguration get(Context context) {
+        final DisplayMetrics metrics = context.getResources().getDisplayMetrics();
+        final int density = (int) (100.0f * metrics.density);
+
+        ViewConfiguration configuration = sConfigurations.get(density);
+        if (configuration == null) {
+            configuration = new ViewConfiguration(context);
+            sConfigurations.put(density, configuration);
+        }
+
+        return configuration;
+    }
+
+    /**
+     * @return The width of the horizontal scrollbar and the height of the vertical
+     *         scrollbar in dips
+     *
+     * @deprecated Use {@link #getScaledScrollBarSize()} instead.
+     */
+    @Deprecated
+    public static int getScrollBarSize() {
+        return SCROLL_BAR_SIZE;
+    }
+
+    /**
+     * @return The width of the horizontal scrollbar and the height of the vertical
+     *         scrollbar in pixels
+     */
+    public int getScaledScrollBarSize() {
+        return mScrollbarSize;
+    }
+
+    /**
+     * @return Duration of the fade when scrollbars fade away in milliseconds
+     */
+    public static int getScrollBarFadeDuration() {
+        return SCROLL_BAR_FADE_DURATION;
+    }
+
+    /**
+     * @return Default delay before the scrollbars fade in milliseconds
+     */
+    public static int getScrollDefaultDelay() {
+        return SCROLL_BAR_DEFAULT_DELAY;
+    }
+
+    /**
+     * @return the length of the fading edges in dips
+     *
+     * @deprecated Use {@link #getScaledFadingEdgeLength()} instead.
+     */
+    @Deprecated
+    public static int getFadingEdgeLength() {
+        return FADING_EDGE_LENGTH;
+    }
+
+    /**
+     * @return the length of the fading edges in pixels
+     */
+    public int getScaledFadingEdgeLength() {
+        return mFadingEdgeLength;
+    }
+
+    /**
+     * @return the duration in milliseconds of the pressed state in child
+     * components.
+     */
+    public static int getPressedStateDuration() {
+        return PRESSED_STATE_DURATION;
+    }
+
+    /**
+     * @return the duration in milliseconds before a press turns into
+     * a long press
+     */
+    public static int getLongPressTimeout() {
+        return AppGlobals.getIntCoreSetting(Settings.Secure.LONG_PRESS_TIMEOUT,
+                DEFAULT_LONG_PRESS_TIMEOUT);
+    }
+
+    /**
+     * @return the time before the first key repeat in milliseconds.
+     */
+    public static int getKeyRepeatTimeout() {
+        return getLongPressTimeout();
+    }
+
+    /**
+     * @return the time between successive key repeats in milliseconds.
+     */
+    public static int getKeyRepeatDelay() {
+        return KEY_REPEAT_DELAY;
+    }
+
+    /**
+     * @return the duration in milliseconds we will wait to see if a touch event
+     * is a tap or a scroll. If the user does not move within this interval, it is
+     * considered to be a tap.
+     */
+    public static int getTapTimeout() {
+        return TAP_TIMEOUT;
+    }
+
+    /**
+     * @return the duration in milliseconds we will wait to see if a touch event
+     * is a jump tap. If the user does not move within this interval, it is
+     * considered to be a tap.
+     */
+    public static int getJumpTapTimeout() {
+        return JUMP_TAP_TIMEOUT;
+    }
+
+    /**
+     * @return the duration in milliseconds between the first tap's up event and
+     * the second tap's down event for an interaction to be considered a
+     * double-tap.
+     */
+    public static int getDoubleTapTimeout() {
+        return DOUBLE_TAP_TIMEOUT;
+    }
+
+    /**
+     * @return the maximum duration in milliseconds between a touch pad
+     * touch and release for a given touch to be considered a tap (click) as
+     * opposed to a hover movement gesture.
+     * @hide
+     */
+    public static int getHoverTapTimeout() {
+        return HOVER_TAP_TIMEOUT;
+    }
+
+    /**
+     * @return the maximum distance in pixels that a touch pad touch can move
+     * before being released for it to be considered a tap (click) as opposed
+     * to a hover movement gesture.
+     * @hide
+     */
+    public static int getHoverTapSlop() {
+        return HOVER_TAP_SLOP;
+    }
+
+    /**
+     * @return Inset in dips to look for touchable content when the user touches the edge of the
+     *         screen
+     *
+     * @deprecated Use {@link #getScaledEdgeSlop()} instead.
+     */
+    @Deprecated
+    public static int getEdgeSlop() {
+        return EDGE_SLOP;
+    }
+
+    /**
+     * @return Inset in pixels to look for touchable content when the user touches the edge of the
+     *         screen
+     */
+    public int getScaledEdgeSlop() {
+        return mEdgeSlop;
+    }
+
+    /**
+     * @return Distance in dips a touch can wander before we think the user is scrolling
+     *
+     * @deprecated Use {@link #getScaledTouchSlop()} instead.
+     */
+    @Deprecated
+    public static int getTouchSlop() {
+        return TOUCH_SLOP;
+    }
+
+    /**
+     * @return Distance in pixels a touch can wander before we think the user is scrolling
+     */
+    public int getScaledTouchSlop() {
+        return mTouchSlop;
+    }
+
+    /**
+     * @return Distance in pixels the first touch can wander before we do not consider this a
+     * potential double tap event
+     * @hide
+     */
+    public int getScaledDoubleTapTouchSlop() {
+        return mDoubleTapTouchSlop;
+    }
+
+    /**
+     * @return Distance in pixels a touch can wander before we think the user is scrolling a full
+     * page
+     */
+    public int getScaledPagingTouchSlop() {
+        return mPagingTouchSlop;
+    }
+
+    /**
+     * @return Distance in dips between the first touch and second touch to still be
+     *         considered a double tap
+     * @deprecated Use {@link #getScaledDoubleTapSlop()} instead.
+     * @hide The only client of this should be GestureDetector, which needs this
+     *       for clients that still use its deprecated constructor.
+     */
+    @Deprecated
+    public static int getDoubleTapSlop() {
+        return DOUBLE_TAP_SLOP;
+    }
+
+    /**
+     * @return Distance in pixels between the first touch and second touch to still be
+     *         considered a double tap
+     */
+    public int getScaledDoubleTapSlop() {
+        return mDoubleTapSlop;
+    }
+
+    /**
+     * Interval for dispatching a recurring accessibility event in milliseconds.
+     * This interval guarantees that a recurring event will be send at most once
+     * during the {@link #getSendRecurringAccessibilityEventsInterval()} time frame.
+     *
+     * @return The delay in milliseconds.
+     *
+     * @hide
+     */
+    public static long getSendRecurringAccessibilityEventsInterval() {
+        return SEND_RECURRING_ACCESSIBILITY_EVENTS_INTERVAL_MILLIS;
+    }
+
+    /**
+     * @return Distance in dips a touch must be outside the bounds of a window for it
+     * to be counted as outside the window for purposes of dismissing that
+     * window.
+     *
+     * @deprecated Use {@link #getScaledWindowTouchSlop()} instead.
+     */
+    @Deprecated
+    public static int getWindowTouchSlop() {
+        return WINDOW_TOUCH_SLOP;
+    }
+
+    /**
+     * @return Distance in pixels a touch must be outside the bounds of a window for it
+     * to be counted as outside the window for purposes of dismissing that window.
+     */
+    public int getScaledWindowTouchSlop() {
+        return mWindowTouchSlop;
+    }
+
+    /**
+     * @return Minimum velocity to initiate a fling, as measured in dips per second.
+     *
+     * @deprecated Use {@link #getScaledMinimumFlingVelocity()} instead.
+     */
+    @Deprecated
+    public static int getMinimumFlingVelocity() {
+        return MINIMUM_FLING_VELOCITY;
+    }
+
+    /**
+     * @return Minimum velocity to initiate a fling, as measured in pixels per second.
+     */
+    public int getScaledMinimumFlingVelocity() {
+        return mMinimumFlingVelocity;
+    }
+
+    /**
+     * @return Maximum velocity to initiate a fling, as measured in dips per second.
+     *
+     * @deprecated Use {@link #getScaledMaximumFlingVelocity()} instead.
+     */
+    @Deprecated
+    public static int getMaximumFlingVelocity() {
+        return MAXIMUM_FLING_VELOCITY;
+    }
+
+    /**
+     * @return Maximum velocity to initiate a fling, as measured in pixels per second.
+     */
+    public int getScaledMaximumFlingVelocity() {
+        return mMaximumFlingVelocity;
+    }
+
+    /**
+     * The maximum drawing cache size expressed in bytes.
+     *
+     * @return the maximum size of View's drawing cache expressed in bytes
+     *
+     * @deprecated Use {@link #getScaledMaximumDrawingCacheSize()} instead.
+     */
+    @Deprecated
+    public static int getMaximumDrawingCacheSize() {
+        //noinspection deprecation
+        return MAXIMUM_DRAWING_CACHE_SIZE;
+    }
+
+    /**
+     * The maximum drawing cache size expressed in bytes.
+     *
+     * @return the maximum size of View's drawing cache expressed in bytes
+     */
+    public int getScaledMaximumDrawingCacheSize() {
+        return mMaximumDrawingCacheSize;
+    }
+
+    /**
+     * @return The maximum distance a View should overscroll by when showing edge effects (in
+     * pixels).
+     */
+    public int getScaledOverscrollDistance() {
+        return mOverscrollDistance;
+    }
+
+    /**
+     * @return The maximum distance a View should overfling by when showing edge effects (in
+     * pixels).
+     */
+    public int getScaledOverflingDistance() {
+        return mOverflingDistance;
+    }
+
+    /**
+     * The amount of time that the zoom controls should be
+     * displayed on the screen expressed in milliseconds.
+     *
+     * @return the time the zoom controls should be visible expressed
+     * in milliseconds.
+     */
+    public static long getZoomControlsTimeout() {
+        return ZOOM_CONTROLS_TIMEOUT;
+    }
+
+    /**
+     * The amount of time a user needs to press the relevant key to bring up
+     * the global actions dialog.
+     *
+     * @return how long a user needs to press the relevant key to bring up
+     *   the global actions dialog.
+     */
+    public static long getGlobalActionKeyTimeout() {
+        return GLOBAL_ACTIONS_KEY_TIMEOUT;
+    }
+
+    /**
+     * The amount of friction applied to scrolls and flings.
+     *
+     * @return A scalar dimensionless value representing the coefficient of
+     *         friction.
+     */
+    public static float getScrollFriction() {
+        return SCROLL_FRICTION;
+    }
+
+    /**
+     * Report if the device has a permanent menu key available to the user.
+     *
+     * <p>As of Android 3.0, devices may not have a permanent menu key available.
+     * Apps should use the action bar to present menu options to users.
+     * However, there are some apps where the action bar is inappropriate
+     * or undesirable. This method may be used to detect if a menu key is present.
+     * If not, applications should provide another on-screen affordance to access
+     * functionality.
+     *
+     * @return true if a permanent menu key is present, false otherwise.
+     */
+    public boolean hasPermanentMenuKey() {
+        return sHasPermanentMenuKey;
+    }
+
+    /**
+     * @hide
+     * @return Whether or not marquee should use fading edges.
+     */
+    public boolean isFadingMarqueeEnabled() {
+        return mFadingMarqueeEnabled;
+    }
+}
diff --git a/src/frameworks/base/core/java/android/widget/CompoundButton.java b/src/frameworks/base/core/java/android/widget/CompoundButton.java
new file mode 100644
index 0000000..0a71c5a
--- /dev/null
+++ b/src/frameworks/base/core/java/android/widget/CompoundButton.java
@@ -0,0 +1,349 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.widget;
+
+import com.android.internal.R;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.drawable.Drawable;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.AttributeSet;
+import android.view.Gravity;
+import android.view.ViewDebug;
+import android.view.accessibility.AccessibilityEvent;
+import android.view.accessibility.AccessibilityNodeInfo;
+
+/**
+ * <p>
+ * A button with two states, checked and unchecked. When the button is pressed
+ * or clicked, the state changes automatically.
+ * </p>
+ *
+ * <p><strong>XML attributes</strong></p>
+ * <p>
+ * See {@link android.R.styleable#CompoundButton
+ * CompoundButton Attributes}, {@link android.R.styleable#Button Button
+ * Attributes}, {@link android.R.styleable#TextView TextView Attributes}, {@link
+ * android.R.styleable#View View Attributes}
+ * </p>
+ */
+public abstract class CompoundButton extends Button implements Checkable {
+    private boolean mChecked;
+    private int mButtonResource;
+    private boolean mBroadcasting;
+    private Drawable mButtonDrawable;
+    private OnCheckedChangeListener mOnCheckedChangeListener;
+    private OnCheckedChangeListener mOnCheckedChangeWidgetListener;
+
+    private static final int[] CHECKED_STATE_SET = {
+        R.attr.state_checked
+    };
+
+    public CompoundButton(Context context) {
+        this(context, null);
+    }
+
+    public CompoundButton(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public CompoundButton(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+
+        TypedArray a =
+                context.obtainStyledAttributes(
+                        attrs, com.android.internal.R.styleable.CompoundButton, defStyle, 0);
+
+        Drawable d = a.getDrawable(com.android.internal.R.styleable.CompoundButton_button);
+        if (d != null) {
+            setButtonDrawable(d);
+        }
+
+        boolean checked = a
+                .getBoolean(com.android.internal.R.styleable.CompoundButton_checked, false);
+        setChecked(checked);
+
+        a.recycle();
+    }
+
+    public void toggle() {
+        setChecked(!mChecked);
+    }
+
+    @Override
+    public boolean performClick() {
+        /*
+         * XXX: These are tiny, need some surrounding 'expanded touch area',
+         * which will need to be implemented in Button if we only override
+         * performClick()
+         */
+
+        /* When clicked, toggle the state */
+        toggle();
+        return super.performClick();
+    }
+
+    @ViewDebug.ExportedProperty
+    public boolean isChecked() {
+        return mChecked;
+    }
+
+    /**
+     * <p>Changes the checked state of this button.</p>
+     *
+     * @param checked true to check the button, false to uncheck it
+     */
+    public void setChecked(boolean checked) {
+        if (mChecked != checked) {
+            mChecked = checked;
+            refreshDrawableState();
+            notifyAccessibilityStateChanged();
+
+            // Avoid infinite recursions if setChecked() is called from a listener
+            if (mBroadcasting) {
+                return;
+            }
+
+            mBroadcasting = true;
+            if (mOnCheckedChangeListener != null) {
+                mOnCheckedChangeListener.onCheckedChanged(this, mChecked);
+            }
+            if (mOnCheckedChangeWidgetListener != null) {
+                mOnCheckedChangeWidgetListener.onCheckedChanged(this, mChecked);
+            }
+
+            mBroadcasting = false;            
+        }
+    }
+
+    /**
+     * Register a callback to be invoked when the checked state of this button
+     * changes.
+     *
+     * @param listener the callback to call on checked state change
+     */
+    public void setOnCheckedChangeListener(OnCheckedChangeListener listener) {
+        mOnCheckedChangeListener = listener;
+    }
+
+    /**
+     * Register a callback to be invoked when the checked state of this button
+     * changes. This callback is used for internal purpose only.
+     *
+     * @param listener the callback to call on checked state change
+     * @hide
+     */
+    void setOnCheckedChangeWidgetListener(OnCheckedChangeListener listener) {
+        mOnCheckedChangeWidgetListener = listener;
+    }
+
+    /**
+     * Interface definition for a callback to be invoked when the checked state
+     * of a compound button changed.
+     */
+    public static interface OnCheckedChangeListener {
+        /**
+         * Called when the checked state of a compound button has changed.
+         *
+         * @param buttonView The compound button view whose state has changed.
+         * @param isChecked  The new checked state of buttonView.
+         */
+        void onCheckedChanged(CompoundButton buttonView, boolean isChecked);
+    }
+
+    /**
+     * Set the background to a given Drawable, identified by its resource id.
+     *
+     * @param resid the resource id of the drawable to use as the background 
+     */
+    public void setButtonDrawable(int resid) {
+        if (resid != 0 && resid == mButtonResource) {
+            return;
+        }
+
+        mButtonResource = resid;
+
+        Drawable d = null;
+        if (mButtonResource != 0) {
+            d = getResources().getDrawable(mButtonResource);
+        }
+        setButtonDrawable(d);
+    }
+
+    /**
+     * Set the background to a given Drawable
+     *
+     * @param d The Drawable to use as the background
+     */
+    public void setButtonDrawable(Drawable d) {
+        if (d != null) {
+            if (mButtonDrawable != null) {
+                mButtonDrawable.setCallback(null);
+                unscheduleDrawable(mButtonDrawable);
+            }
+            d.setCallback(this);
+            d.setState(getDrawableState());
+            d.setVisible(getVisibility() == VISIBLE, false);
+            mButtonDrawable = d;
+            mButtonDrawable.setState(null);
+            setMinHeight(mButtonDrawable.getIntrinsicHeight());
+        }
+
+        refreshDrawableState();
+    }
+
+    @Override
+    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
+        super.onInitializeAccessibilityEvent(event);
+        event.setClassName(CompoundButton.class.getName());
+        event.setChecked(mChecked);
+    }
+
+    @Override
+    public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
+        super.onInitializeAccessibilityNodeInfo(info);
+        info.setClassName(CompoundButton.class.getName());
+        info.setCheckable(true);
+        info.setChecked(mChecked);
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+
+        final Drawable buttonDrawable = mButtonDrawable;
+        if (buttonDrawable != null) {
+            final int verticalGravity = getGravity() & Gravity.VERTICAL_GRAVITY_MASK;
+            final int height = buttonDrawable.getIntrinsicHeight();
+
+            int y = 0;
+
+            switch (verticalGravity) {
+                case Gravity.BOTTOM:
+                    y = getHeight() - height;
+                    break;
+                case Gravity.CENTER_VERTICAL:
+                    y = (getHeight() - height) / 2;
+                    break;
+            }
+
+            buttonDrawable.setBounds(0, y, buttonDrawable.getIntrinsicWidth(), y + height);
+            buttonDrawable.draw(canvas);
+        }
+    }
+
+    @Override
+    protected int[] onCreateDrawableState(int extraSpace) {
+        final int[] drawableState = super.onCreateDrawableState(extraSpace + 1);
+        if (isChecked()) {
+            mergeDrawableStates(drawableState, CHECKED_STATE_SET);
+        }
+        return drawableState;
+    }
+
+    @Override
+    protected void drawableStateChanged() {
+        super.drawableStateChanged();
+        
+        if (mButtonDrawable != null) {
+            int[] myDrawableState = getDrawableState();
+            
+            // Set the state of the Drawable
+            mButtonDrawable.setState(myDrawableState);
+            
+            invalidate();
+        }
+    }
+
+    @Override
+    protected boolean verifyDrawable(Drawable who) {
+        return super.verifyDrawable(who) || who == mButtonDrawable;
+    }
+
+    @Override
+    public void jumpDrawablesToCurrentState() {
+        super.jumpDrawablesToCurrentState();
+        if (mButtonDrawable != null) mButtonDrawable.jumpToCurrentState();
+    }
+
+    static class SavedState extends BaseSavedState {
+        boolean checked;
+
+        /**
+         * Constructor called from {@link CompoundButton#onSaveInstanceState()}
+         */
+        SavedState(Parcelable superState) {
+            super(superState);
+        }
+        
+        /**
+         * Constructor called from {@link #CREATOR}
+         */
+        private SavedState(Parcel in) {
+            super(in);
+            checked = (Boolean)in.readValue(null);
+        }
+
+        @Override
+        public void writeToParcel(Parcel out, int flags) {
+            super.writeToParcel(out, flags);
+            out.writeValue(checked);
+        }
+
+        @Override
+        public String toString() {
+            return "CompoundButton.SavedState{"
+                    + Integer.toHexString(System.identityHashCode(this))
+                    + " checked=" + checked + "}";
+        }
+
+        public static final Parcelable.Creator<SavedState> CREATOR
+                = new Parcelable.Creator<SavedState>() {
+            public SavedState createFromParcel(Parcel in) {
+                return new SavedState(in);
+            }
+
+            public SavedState[] newArray(int size) {
+                return new SavedState[size];
+            }
+        };
+    }
+
+    @Override
+    public Parcelable onSaveInstanceState() {
+        // Force our ancestor class to save its state
+        setFreezesText(true);
+        Parcelable superState = super.onSaveInstanceState();
+
+        SavedState ss = new SavedState(superState);
+
+        ss.checked = isChecked();
+        return ss;
+    }
+
+    @Override
+    public void onRestoreInstanceState(Parcelable state) {
+        SavedState ss = (SavedState) state;
+  
+        super.onRestoreInstanceState(ss.getSuperState());
+        setChecked(ss.checked);
+        requestLayout();
+    }
+}
diff --git a/src/frameworks/base/core/java/android/widget/EdgeEffect.java b/src/frameworks/base/core/java/android/widget/EdgeEffect.java
new file mode 100644
index 0000000..bb4a4cf
--- /dev/null
+++ b/src/frameworks/base/core/java/android/widget/EdgeEffect.java
@@ -0,0 +1,441 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.widget;
+
+import android.graphics.Rect;
+import com.android.internal.R;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Canvas;
+import android.graphics.drawable.Drawable;
+import android.view.animation.AnimationUtils;
+import android.view.animation.DecelerateInterpolator;
+import android.view.animation.Interpolator;
+
+/**
+ * This class performs the graphical effect used at the edges of scrollable widgets
+ * when the user scrolls beyond the content bounds in 2D space.
+ *
+ * <p>EdgeEffect is stateful. Custom widgets using EdgeEffect should create an
+ * instance for each edge that should show the effect, feed it input data using
+ * the methods {@link #onAbsorb(int)}, {@link #onPull(float)}, and {@link #onRelease()},
+ * and draw the effect using {@link #draw(Canvas)} in the widget's overridden
+ * {@link android.view.View#draw(Canvas)} method. If {@link #isFinished()} returns
+ * false after drawing, the edge effect's animation is not yet complete and the widget
+ * should schedule another drawing pass to continue the animation.</p>
+ *
+ * <p>When drawing, widgets should draw their main content and child views first,
+ * usually by invoking <code>super.draw(canvas)</code> from an overridden <code>draw</code>
+ * method. (This will invoke onDraw and dispatch drawing to child views as needed.)
+ * The edge effect may then be drawn on top of the view's content using the
+ * {@link #draw(Canvas)} method.</p>
+ */
+public class EdgeEffect {
+    @SuppressWarnings("UnusedDeclaration")
+    private static final String TAG = "EdgeEffect";
+
+    // Time it will take the effect to fully recede in ms
+    private static final int RECEDE_TIME = 1000;
+
+    // Time it will take before a pulled glow begins receding in ms
+    private static final int PULL_TIME = 167;
+
+    // Time it will take in ms for a pulled glow to decay to partial strength before release
+    private static final int PULL_DECAY_TIME = 1000;
+
+    private static final float MAX_ALPHA = 1.f;
+    private static final float HELD_EDGE_SCALE_Y = 0.5f;
+
+    private static final float MAX_GLOW_HEIGHT = 4.f;
+
+    private static final float PULL_GLOW_BEGIN = 1.f;
+    private static final float PULL_EDGE_BEGIN = 0.6f;
+
+    // Minimum velocity that will be absorbed
+    private static final int MIN_VELOCITY = 100;
+
+    private static final float EPSILON = 0.001f;
+
+    private final Drawable mEdge;
+    private final Drawable mGlow;
+    private int mWidth;
+    private int mHeight;
+    private int mX;
+    private int mY;
+    private static final int MIN_WIDTH = 300;
+    private final int mMinWidth;
+
+    private float mEdgeAlpha;
+    private float mEdgeScaleY;
+    private float mGlowAlpha;
+    private float mGlowScaleY;
+
+    private float mEdgeAlphaStart;
+    private float mEdgeAlphaFinish;
+    private float mEdgeScaleYStart;
+    private float mEdgeScaleYFinish;
+    private float mGlowAlphaStart;
+    private float mGlowAlphaFinish;
+    private float mGlowScaleYStart;
+    private float mGlowScaleYFinish;
+
+    private long mStartTime;
+    private float mDuration;
+
+    private final Interpolator mInterpolator;
+
+    private static final int STATE_IDLE = 0;
+    private static final int STATE_PULL = 1;
+    private static final int STATE_ABSORB = 2;
+    private static final int STATE_RECEDE = 3;
+    private static final int STATE_PULL_DECAY = 4;
+
+    // How much dragging should effect the height of the edge image.
+    // Number determined by user testing.
+    private static final int PULL_DISTANCE_EDGE_FACTOR = 7;
+
+    // How much dragging should effect the height of the glow image.
+    // Number determined by user testing.
+    private static final int PULL_DISTANCE_GLOW_FACTOR = 7;
+    private static final float PULL_DISTANCE_ALPHA_GLOW_FACTOR = 1.1f;
+
+    private static final int VELOCITY_EDGE_FACTOR = 8;
+    private static final int VELOCITY_GLOW_FACTOR = 16;
+
+    private int mState = STATE_IDLE;
+
+    private float mPullDistance;
+    
+    private final Rect mBounds = new Rect();
+
+    private final int mEdgeHeight;
+    private final int mGlowHeight;
+    private final int mGlowWidth;
+    private final int mMaxEffectHeight;
+
+    /**
+     * Construct a new EdgeEffect with a theme appropriate for the provided context.
+     * @param context Context used to provide theming and resource information for the EdgeEffect
+     */
+    public EdgeEffect(Context context) {
+        final Resources res = context.getResources();
+        mEdge = res.getDrawable(R.drawable.overscroll_edge);
+        mGlow = res.getDrawable(R.drawable.overscroll_glow);
+
+        mEdgeHeight = mEdge.getIntrinsicHeight();
+        mGlowHeight = mGlow.getIntrinsicHeight();
+        mGlowWidth = mGlow.getIntrinsicWidth();
+
+        mMaxEffectHeight = (int) (Math.min(
+                mGlowHeight * MAX_GLOW_HEIGHT * mGlowHeight / mGlowWidth * 0.6f,
+                mGlowHeight * MAX_GLOW_HEIGHT) + 0.5f);
+
+        mMinWidth = (int) (res.getDisplayMetrics().density * MIN_WIDTH + 0.5f);
+        mInterpolator = new DecelerateInterpolator();
+    }
+
+    /**
+     * Set the size of this edge effect in pixels.
+     *
+     * @param width Effect width in pixels
+     * @param height Effect height in pixels
+     */
+    public void setSize(int width, int height) {
+        mWidth = width;
+        mHeight = height;
+    }
+
+    /**
+     * Set the position of this edge effect in pixels. This position is
+     * only used by {@link #getBounds(boolean)}.
+     * 
+     * @param x The position of the edge effect on the X axis
+     * @param y The position of the edge effect on the Y axis
+     */
+    void setPosition(int x, int y) {
+        mX = x;
+        mY = y;
+    }
+
+    /**
+     * Reports if this EdgeEffect's animation is finished. If this method returns false
+     * after a call to {@link #draw(Canvas)} the host widget should schedule another
+     * drawing pass to continue the animation.
+     *
+     * @return true if animation is finished, false if drawing should continue on the next frame.
+     */
+    public boolean isFinished() {
+        return mState == STATE_IDLE;
+    }
+
+    /**
+     * Immediately finish the current animation.
+     * After this call {@link #isFinished()} will return true.
+     */
+    public void finish() {
+        mState = STATE_IDLE;
+    }
+
+    /**
+     * A view should call this when content is pulled away from an edge by the user.
+     * This will update the state of the current visual effect and its associated animation.
+     * The host view should always {@link android.view.View#invalidate()} after this
+     * and draw the results accordingly.
+     *
+     * @param deltaDistance Change in distance since the last call. Values may be 0 (no change) to
+     *                      1.f (full length of the view) or negative values to express change
+     *                      back toward the edge reached to initiate the effect.
+     */
+    public void onPull(float deltaDistance) {
+        final long now = AnimationUtils.currentAnimationTimeMillis();
+        if (mState == STATE_PULL_DECAY && now - mStartTime < mDuration) {
+            return;
+        }
+        if (mState != STATE_PULL) {
+            mGlowScaleY = PULL_GLOW_BEGIN;
+        }
+        mState = STATE_PULL;
+
+        mStartTime = now;
+        mDuration = PULL_TIME;
+
+        mPullDistance += deltaDistance;
+        float distance = Math.abs(mPullDistance);
+
+        mEdgeAlpha = mEdgeAlphaStart = Math.max(PULL_EDGE_BEGIN, Math.min(distance, MAX_ALPHA));
+        mEdgeScaleY = mEdgeScaleYStart = Math.max(
+                HELD_EDGE_SCALE_Y, Math.min(distance * PULL_DISTANCE_EDGE_FACTOR, 1.f));
+
+        mGlowAlpha = mGlowAlphaStart = Math.min(MAX_ALPHA,
+                mGlowAlpha +
+                (Math.abs(deltaDistance) * PULL_DISTANCE_ALPHA_GLOW_FACTOR));
+
+        float glowChange = Math.abs(deltaDistance);
+        if (deltaDistance > 0 && mPullDistance < 0) {
+            glowChange = -glowChange;
+        }
+        if (mPullDistance == 0) {
+            mGlowScaleY = 0;
+        }
+
+        // Do not allow glow to get larger than MAX_GLOW_HEIGHT.
+        mGlowScaleY = mGlowScaleYStart = Math.min(MAX_GLOW_HEIGHT, Math.max(
+                0, mGlowScaleY + glowChange * PULL_DISTANCE_GLOW_FACTOR));
+
+        mEdgeAlphaFinish = mEdgeAlpha;
+        mEdgeScaleYFinish = mEdgeScaleY;
+        mGlowAlphaFinish = mGlowAlpha;
+        mGlowScaleYFinish = mGlowScaleY;
+    }
+
+    /**
+     * Call when the object is released after being pulled.
+     * This will begin the "decay" phase of the effect. After calling this method
+     * the host view should {@link android.view.View#invalidate()} and thereby
+     * draw the results accordingly.
+     */
+    public void onRelease() {
+        mPullDistance = 0;
+
+        if (mState != STATE_PULL && mState != STATE_PULL_DECAY) {
+            return;
+        }
+
+        mState = STATE_RECEDE;
+        mEdgeAlphaStart = mEdgeAlpha;
+        mEdgeScaleYStart = mEdgeScaleY;
+        mGlowAlphaStart = mGlowAlpha;
+        mGlowScaleYStart = mGlowScaleY;
+
+        mEdgeAlphaFinish = 0.f;
+        mEdgeScaleYFinish = 0.f;
+        mGlowAlphaFinish = 0.f;
+        mGlowScaleYFinish = 0.f;
+
+        mStartTime = AnimationUtils.currentAnimationTimeMillis();
+        mDuration = RECEDE_TIME;
+    }
+
+    /**
+     * Call when the effect absorbs an impact at the given velocity.
+     * Used when a fling reaches the scroll boundary.
+     *
+     * <p>When using a {@link android.widget.Scroller} or {@link android.widget.OverScroller},
+     * the method <code>getCurrVelocity</code> will provide a reasonable approximation
+     * to use here.</p>
+     *
+     * @param velocity Velocity at impact in pixels per second.
+     */
+    public void onAbsorb(int velocity) {
+        mState = STATE_ABSORB;
+        velocity = Math.max(MIN_VELOCITY, Math.abs(velocity));
+
+        mStartTime = AnimationUtils.currentAnimationTimeMillis();
+        mDuration = 0.1f + (velocity * 0.03f);
+
+        // The edge should always be at least partially visible, regardless
+        // of velocity.
+        mEdgeAlphaStart = 0.f;
+        mEdgeScaleY = mEdgeScaleYStart = 0.f;
+        // The glow depends more on the velocity, and therefore starts out
+        // nearly invisible.
+        mGlowAlphaStart = 0.5f;
+        mGlowScaleYStart = 0.f;
+
+        // Factor the velocity by 8. Testing on device shows this works best to
+        // reflect the strength of the user's scrolling.
+        mEdgeAlphaFinish = Math.max(0, Math.min(velocity * VELOCITY_EDGE_FACTOR, 1));
+        // Edge should never get larger than the size of its asset.
+        mEdgeScaleYFinish = Math.max(
+                HELD_EDGE_SCALE_Y, Math.min(velocity * VELOCITY_EDGE_FACTOR, 1.f));
+
+        // Growth for the size of the glow should be quadratic to properly
+        // respond
+        // to a user's scrolling speed. The faster the scrolling speed, the more
+        // intense the effect should be for both the size and the saturation.
+        mGlowScaleYFinish = Math.min(0.025f + (velocity * (velocity / 100) * 0.00015f), 1.75f);
+        // Alpha should change for the glow as well as size.
+        mGlowAlphaFinish = Math.max(
+                mGlowAlphaStart, Math.min(velocity * VELOCITY_GLOW_FACTOR * .00001f, MAX_ALPHA));
+    }
+
+
+    /**
+     * Draw into the provided canvas. Assumes that the canvas has been rotated
+     * accordingly and the size has been set. The effect will be drawn the full
+     * width of X=0 to X=width, beginning from Y=0 and extending to some factor <
+     * 1.f of height.
+     *
+     * @param canvas Canvas to draw into
+     * @return true if drawing should continue beyond this frame to continue the
+     *         animation
+     */
+    public boolean draw(Canvas canvas) {
+        update();
+
+        mGlow.setAlpha((int) (Math.max(0, Math.min(mGlowAlpha, 1)) * 255));
+
+        int glowBottom = (int) Math.min(
+                mGlowHeight * mGlowScaleY * mGlowHeight / mGlowWidth * 0.6f,
+                mGlowHeight * MAX_GLOW_HEIGHT);
+        if (mWidth < mMinWidth) {
+            // Center the glow and clip it.
+            int glowLeft = (mWidth - mMinWidth)/2;
+            mGlow.setBounds(glowLeft, 0, mWidth - glowLeft, glowBottom);
+        } else {
+            // Stretch the glow to fit.
+            mGlow.setBounds(0, 0, mWidth, glowBottom);
+        }
+
+        mGlow.draw(canvas);
+
+        mEdge.setAlpha((int) (Math.max(0, Math.min(mEdgeAlpha, 1)) * 255));
+
+        int edgeBottom = (int) (mEdgeHeight * mEdgeScaleY);
+        if (mWidth < mMinWidth) {
+            // Center the edge and clip it.
+            int edgeLeft = (mWidth - mMinWidth)/2;
+            mEdge.setBounds(edgeLeft, 0, mWidth - edgeLeft, edgeBottom);
+        } else {
+            // Stretch the edge to fit.
+            mEdge.setBounds(0, 0, mWidth, edgeBottom);
+        }
+        mEdge.draw(canvas);
+
+        if (mState == STATE_RECEDE && glowBottom == 0 && edgeBottom == 0) {
+            mState = STATE_IDLE;
+        }
+
+        return mState != STATE_IDLE;
+    }
+
+    /**
+     * Returns the bounds of the edge effect.
+     * 
+     * @hide
+     */
+    public Rect getBounds(boolean reverse) {
+        mBounds.set(0, 0, mWidth, mMaxEffectHeight);
+        mBounds.offset(mX, mY - (reverse ? mMaxEffectHeight : 0));
+
+        return mBounds;
+    }
+
+    private void update() {
+        final long time = AnimationUtils.currentAnimationTimeMillis();
+        final float t = Math.min((time - mStartTime) / mDuration, 1.f);
+
+        final float interp = mInterpolator.getInterpolation(t);
+
+        mEdgeAlpha = mEdgeAlphaStart + (mEdgeAlphaFinish - mEdgeAlphaStart) * interp;
+        mEdgeScaleY = mEdgeScaleYStart + (mEdgeScaleYFinish - mEdgeScaleYStart) * interp;
+        mGlowAlpha = mGlowAlphaStart + (mGlowAlphaFinish - mGlowAlphaStart) * interp;
+        mGlowScaleY = mGlowScaleYStart + (mGlowScaleYFinish - mGlowScaleYStart) * interp;
+
+        if (t >= 1.f - EPSILON) {
+            switch (mState) {
+                case STATE_ABSORB:
+                    mState = STATE_RECEDE;
+                    mStartTime = AnimationUtils.currentAnimationTimeMillis();
+                    mDuration = RECEDE_TIME;
+
+                    mEdgeAlphaStart = mEdgeAlpha;
+                    mEdgeScaleYStart = mEdgeScaleY;
+                    mGlowAlphaStart = mGlowAlpha;
+                    mGlowScaleYStart = mGlowScaleY;
+
+                    // After absorb, the glow and edge should fade to nothing.
+                    mEdgeAlphaFinish = 0.f;
+                    mEdgeScaleYFinish = 0.f;
+                    mGlowAlphaFinish = 0.f;
+                    mGlowScaleYFinish = 0.f;
+                    break;
+                case STATE_PULL:
+                    mState = STATE_PULL_DECAY;
+                    mStartTime = AnimationUtils.currentAnimationTimeMillis();
+                    mDuration = PULL_DECAY_TIME;
+
+                    mEdgeAlphaStart = mEdgeAlpha;
+                    mEdgeScaleYStart = mEdgeScaleY;
+                    mGlowAlphaStart = mGlowAlpha;
+                    mGlowScaleYStart = mGlowScaleY;
+
+                    // After pull, the glow and edge should fade to nothing.
+                    mEdgeAlphaFinish = 0.f;
+                    mEdgeScaleYFinish = 0.f;
+                    mGlowAlphaFinish = 0.f;
+                    mGlowScaleYFinish = 0.f;
+                    break;
+                case STATE_PULL_DECAY:
+                    // When receding, we want edge to decrease more slowly
+                    // than the glow.
+                    float factor = mGlowScaleYFinish != 0 ? 1
+                            / (mGlowScaleYFinish * mGlowScaleYFinish)
+                            : Float.MAX_VALUE;
+                    mEdgeScaleY = mEdgeScaleYStart +
+                        (mEdgeScaleYFinish - mEdgeScaleYStart) *
+                            interp * factor;
+                    mState = STATE_RECEDE;
+                    break;
+                case STATE_RECEDE:
+                    mState = STATE_IDLE;
+                    break;
+            }
+        }
+    }
+}
diff --git a/src/frameworks/base/core/java/android/widget/NumberPicker.java b/src/frameworks/base/core/java/android/widget/NumberPicker.java
new file mode 100644
index 0000000..a458f57
--- /dev/null
+++ b/src/frameworks/base/core/java/android/widget/NumberPicker.java
@@ -0,0 +1,2569 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.widget;
+
+import android.annotation.Widget;
+import android.content.Context;
+import android.content.res.ColorStateList;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Paint.Align;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.os.Bundle;
+import android.text.InputFilter;
+import android.text.InputType;
+import android.text.Spanned;
+import android.text.TextUtils;
+import android.text.method.NumberKeyListener;
+import android.util.AttributeSet;
+import android.util.SparseArray;
+import android.util.TypedValue;
+import android.view.KeyEvent;
+import android.view.LayoutInflater;
+import android.view.LayoutInflater.Filter;
+import android.view.MotionEvent;
+import android.view.VelocityTracker;
+import android.view.View;
+import android.view.ViewConfiguration;
+import android.view.accessibility.AccessibilityEvent;
+import android.view.accessibility.AccessibilityManager;
+import android.view.accessibility.AccessibilityNodeInfo;
+import android.view.accessibility.AccessibilityNodeProvider;
+import android.view.animation.DecelerateInterpolator;
+import android.view.inputmethod.EditorInfo;
+import android.view.inputmethod.InputMethodManager;
+
+import com.android.internal.R;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * A widget that enables the user to select a number form a predefined range.
+ * There are two flavors of this widget and which one is presented to the user
+ * depends on the current theme.
+ * <ul>
+ * <li>
+ * If the current theme is derived from {@link android.R.style#Theme} the widget
+ * presents the current value as an editable input field with an increment button
+ * above and a decrement button below. Long pressing the buttons allows for a quick
+ * change of the current value. Tapping on the input field allows to type in
+ * a desired value.
+ * </li>
+ * <li>
+ * If the current theme is derived from {@link android.R.style#Theme_Holo} or
+ * {@link android.R.style#Theme_Holo_Light} the widget presents the current
+ * value as an editable input field with a lesser value above and a greater
+ * value below. Tapping on the lesser or greater value selects it by animating
+ * the number axis up or down to make the chosen value current. Flinging up
+ * or down allows for multiple increments or decrements of the current value.
+ * Long pressing on the lesser and greater values also allows for a quick change
+ * of the current value. Tapping on the current value allows to type in a
+ * desired value.
+ * </li>
+ * </ul>
+ * <p>
+ * For an example of using this widget, see {@link android.widget.TimePicker}.
+ * </p>
+ */
+@Widget
+public class NumberPicker extends LinearLayout {
+
+    /**
+     * The number of items show in the selector wheel.
+     */
+    private static final int SELECTOR_WHEEL_ITEM_COUNT = 3;
+
+    /**
+     * The default update interval during long press.
+     */
+    private static final long DEFAULT_LONG_PRESS_UPDATE_INTERVAL = 300;
+
+    /**
+     * The index of the middle selector item.
+     */
+    private static final int SELECTOR_MIDDLE_ITEM_INDEX = SELECTOR_WHEEL_ITEM_COUNT / 2;
+
+    /**
+     * The coefficient by which to adjust (divide) the max fling velocity.
+     */
+    private static final int SELECTOR_MAX_FLING_VELOCITY_ADJUSTMENT = 8;
+
+    /**
+     * The the duration for adjusting the selector wheel.
+     */
+    private static final int SELECTOR_ADJUSTMENT_DURATION_MILLIS = 800;
+
+    /**
+     * The duration of scrolling while snapping to a given position.
+     */
+    private static final int SNAP_SCROLL_DURATION = 300;
+
+    /**
+     * The strength of fading in the top and bottom while drawing the selector.
+     */
+    private static final float TOP_AND_BOTTOM_FADING_EDGE_STRENGTH = 0.9f;
+
+    /**
+     * The default unscaled height of the selection divider.
+     */
+    private static final int UNSCALED_DEFAULT_SELECTION_DIVIDER_HEIGHT = 2;
+
+    /**
+     * The default unscaled distance between the selection dividers.
+     */
+    private static final int UNSCALED_DEFAULT_SELECTION_DIVIDERS_DISTANCE = 48;
+
+    /**
+     * The resource id for the default layout.
+     */
+    private static final int DEFAULT_LAYOUT_RESOURCE_ID = R.layout.number_picker;
+
+    /**
+     * The numbers accepted by the input text's {@link Filter}
+     */
+    private static final char[] DIGIT_CHARACTERS = new char[] {
+            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'
+    };
+
+    /**
+     * Constant for unspecified size.
+     */
+    private static final int SIZE_UNSPECIFIED = -1;
+
+    /**
+     * Use a custom NumberPicker formatting callback to use two-digit minutes
+     * strings like "01". Keeping a static formatter etc. is the most efficient
+     * way to do this; it avoids creating temporary objects on every call to
+     * format().
+     *
+     * @hide
+     */
+    public static final NumberPicker.Formatter TWO_DIGIT_FORMATTER = new NumberPicker.Formatter() {
+        final StringBuilder mBuilder = new StringBuilder();
+
+        final java.util.Formatter mFmt = new java.util.Formatter(mBuilder, java.util.Locale.US);
+
+        final Object[] mArgs = new Object[1];
+
+        public String format(int value) {
+            mArgs[0] = value;
+            mBuilder.delete(0, mBuilder.length());
+            mFmt.format("%02d", mArgs);
+            return mFmt.toString();
+        }
+    };
+
+    /**
+     * The increment button.
+     */
+    private final ImageButton mIncrementButton;
+
+    /**
+     * The decrement button.
+     */
+    private final ImageButton mDecrementButton;
+
+    /**
+     * The text for showing the current value.
+     */
+    private final EditText mInputText;
+
+    /**
+     * The distance between the two selection dividers.
+     */
+    private final int mSelectionDividersDistance;
+
+    /**
+     * The min height of this widget.
+     */
+    private final int mMinHeight;
+
+    /**
+     * The max height of this widget.
+     */
+    private final int mMaxHeight;
+
+    /**
+     * The max width of this widget.
+     */
+    private final int mMinWidth;
+
+    /**
+     * The max width of this widget.
+     */
+    private int mMaxWidth;
+
+    /**
+     * Flag whether to compute the max width.
+     */
+    private final boolean mComputeMaxWidth;
+
+    /**
+     * The height of the text.
+     */
+    private final int mTextSize;
+
+    /**
+     * The height of the gap between text elements if the selector wheel.
+     */
+    private int mSelectorTextGapHeight;
+
+    /**
+     * The values to be displayed instead the indices.
+     */
+    private String[] mDisplayedValues;
+
+    /**
+     * Lower value of the range of numbers allowed for the NumberPicker
+     */
+    private int mMinValue;
+
+    /**
+     * Upper value of the range of numbers allowed for the NumberPicker
+     */
+    private int mMaxValue;
+
+    /**
+     * Current value of this NumberPicker
+     */
+    private int mValue;
+
+    /**
+     * Listener to be notified upon current value change.
+     */
+    private OnValueChangeListener mOnValueChangeListener;
+
+    /**
+     * Listener to be notified upon scroll state change.
+     */
+    private OnScrollListener mOnScrollListener;
+
+    /**
+     * Formatter for for displaying the current value.
+     */
+    private Formatter mFormatter;
+
+    /**
+     * The speed for updating the value form long press.
+     */
+    private long mLongPressUpdateInterval = DEFAULT_LONG_PRESS_UPDATE_INTERVAL;
+
+    /**
+     * Cache for the string representation of selector indices.
+     */
+    private final SparseArray<String> mSelectorIndexToStringCache = new SparseArray<String>();
+
+    /**
+     * The selector indices whose value are show by the selector.
+     */
+    private final int[] mSelectorIndices = new int[SELECTOR_WHEEL_ITEM_COUNT];
+
+    /**
+     * The {@link Paint} for drawing the selector.
+     */
+    private final Paint mSelectorWheelPaint;
+
+    /**
+     * The {@link Drawable} for pressed virtual (increment/decrement) buttons.
+     */
+    private final Drawable mVirtualButtonPressedDrawable;
+
+    /**
+     * The height of a selector element (text + gap).
+     */
+    private int mSelectorElementHeight;
+
+    /**
+     * The initial offset of the scroll selector.
+     */
+    private int mInitialScrollOffset = Integer.MIN_VALUE;
+
+    /**
+     * The current offset of the scroll selector.
+     */
+    private int mCurrentScrollOffset;
+
+    /**
+     * The {@link Scroller} responsible for flinging the selector.
+     */
+    private final Scroller mFlingScroller;
+
+    /**
+     * The {@link Scroller} responsible for adjusting the selector.
+     */
+    private final Scroller mAdjustScroller;
+
+    /**
+     * The previous Y coordinate while scrolling the selector.
+     */
+    private int mPreviousScrollerY;
+
+    /**
+     * Handle to the reusable command for setting the input text selection.
+     */
+    private SetSelectionCommand mSetSelectionCommand;
+
+    /**
+     * Handle to the reusable command for changing the current value from long
+     * press by one.
+     */
+    private ChangeCurrentByOneFromLongPressCommand mChangeCurrentByOneFromLongPressCommand;
+
+    /**
+     * Command for beginning an edit of the current value via IME on long press.
+     */
+    private BeginSoftInputOnLongPressCommand mBeginSoftInputOnLongPressCommand;
+
+    /**
+     * The Y position of the last down event.
+     */
+    private float mLastDownEventY;
+
+    /**
+     * The time of the last down event.
+     */
+    private long mLastDownEventTime;
+
+    /**
+     * The Y position of the last down or move event.
+     */
+    private float mLastDownOrMoveEventY;
+
+    /**
+     * Determines speed during touch scrolling.
+     */
+    private VelocityTracker mVelocityTracker;
+
+    /**
+     * @see ViewConfiguration#getScaledTouchSlop()
+     */
+    private int mTouchSlop;
+
+    /**
+     * @see ViewConfiguration#getScaledMinimumFlingVelocity()
+     */
+    private int mMinimumFlingVelocity;
+
+    /**
+     * @see ViewConfiguration#getScaledMaximumFlingVelocity()
+     */
+    private int mMaximumFlingVelocity;
+
+    /**
+     * Flag whether the selector should wrap around.
+     */
+    private boolean mWrapSelectorWheel;
+
+    /**
+     * The back ground color used to optimize scroller fading.
+     */
+    private final int mSolidColor;
+
+    /**
+     * Flag whether this widget has a selector wheel.
+     */
+    private final boolean mHasSelectorWheel;
+
+    /**
+     * Divider for showing item to be selected while scrolling
+     */
+    private final Drawable mSelectionDivider;
+
+    /**
+     * The height of the selection divider.
+     */
+    private final int mSelectionDividerHeight;
+
+    /**
+     * The current scroll state of the number picker.
+     */
+    private int mScrollState = OnScrollListener.SCROLL_STATE_IDLE;
+
+    /**
+     * Flag whether to ignore move events - we ignore such when we show in IME
+     * to prevent the content from scrolling.
+     */
+    private boolean mIngonreMoveEvents;
+
+    /**
+     * Flag whether to show soft input on tap.
+     */
+    private boolean mShowSoftInputOnTap;
+
+    /**
+     * The top of the top selection divider.
+     */
+    private int mTopSelectionDividerTop;
+
+    /**
+     * The bottom of the bottom selection divider.
+     */
+    private int mBottomSelectionDividerBottom;
+
+    /**
+     * The virtual id of the last hovered child.
+     */
+    private int mLastHoveredChildVirtualViewId;
+
+    /**
+     * Whether the increment virtual button is pressed.
+     */
+    private boolean mIncrementVirtualButtonPressed;
+
+    /**
+     * Whether the decrement virtual button is pressed.
+     */
+    private boolean mDecrementVirtualButtonPressed;
+
+    /**
+     * Provider to report to clients the semantic structure of this widget.
+     */
+    private AccessibilityNodeProviderImpl mAccessibilityNodeProvider;
+
+    /**
+     * Helper class for managing pressed state of the virtual buttons.
+     */
+    private final PressedStateHelper mPressedStateHelper;
+
+    /**
+     * Interface to listen for changes of the current value.
+     */
+    public interface OnValueChangeListener {
+
+        /**
+         * Called upon a change of the current value.
+         *
+         * @param picker The NumberPicker associated with this listener.
+         * @param oldVal The previous value.
+         * @param newVal The new value.
+         */
+        void onValueChange(NumberPicker picker, int oldVal, int newVal);
+    }
+
+    /**
+     * Interface to listen for the picker scroll state.
+     */
+    public interface OnScrollListener {
+
+        /**
+         * The view is not scrolling.
+         */
+        public static int SCROLL_STATE_IDLE = 0;
+
+        /**
+         * The user is scrolling using touch, and his finger is still on the screen.
+         */
+        public static int SCROLL_STATE_TOUCH_SCROLL = 1;
+
+        /**
+         * The user had previously been scrolling using touch and performed a fling.
+         */
+        public static int SCROLL_STATE_FLING = 2;
+
+        /**
+         * Callback invoked while the number picker scroll state has changed.
+         *
+         * @param view The view whose scroll state is being reported.
+         * @param scrollState The current scroll state. One of
+         *            {@link #SCROLL_STATE_IDLE},
+         *            {@link #SCROLL_STATE_TOUCH_SCROLL} or
+         *            {@link #SCROLL_STATE_IDLE}.
+         */
+        public void onScrollStateChange(NumberPicker view, int scrollState);
+    }
+
+    /**
+     * Interface used to format current value into a string for presentation.
+     */
+    public interface Formatter {
+
+        /**
+         * Formats a string representation of the current value.
+         *
+         * @param value The currently selected value.
+         * @return A formatted string representation.
+         */
+        public String format(int value);
+    }
+
+    /**
+     * Create a new number picker.
+     *
+     * @param context The application environment.
+     */
+    public NumberPicker(Context context) {
+        this(context, null);
+    }
+
+    /**
+     * Create a new number picker.
+     *
+     * @param context The application environment.
+     * @param attrs A collection of attributes.
+     */
+    public NumberPicker(Context context, AttributeSet attrs) {
+        this(context, attrs, R.attr.numberPickerStyle);
+    }
+
+    /**
+     * Create a new number picker
+     *
+     * @param context the application environment.
+     * @param attrs a collection of attributes.
+     * @param defStyle The default style to apply to this view.
+     */
+    public NumberPicker(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+
+        // process style attributes
+        TypedArray attributesArray = context.obtainStyledAttributes(
+                attrs, R.styleable.NumberPicker, defStyle, 0);
+        final int layoutResId = attributesArray.getResourceId(
+                R.styleable.NumberPicker_internalLayout, DEFAULT_LAYOUT_RESOURCE_ID);
+
+        mHasSelectorWheel = (layoutResId != DEFAULT_LAYOUT_RESOURCE_ID);
+
+        mSolidColor = attributesArray.getColor(R.styleable.NumberPicker_solidColor, 0);
+
+        mSelectionDivider = attributesArray.getDrawable(R.styleable.NumberPicker_selectionDivider);
+
+        final int defSelectionDividerHeight = (int) TypedValue.applyDimension(
+                TypedValue.COMPLEX_UNIT_DIP, UNSCALED_DEFAULT_SELECTION_DIVIDER_HEIGHT,
+                getResources().getDisplayMetrics());
+        mSelectionDividerHeight = attributesArray.getDimensionPixelSize(
+                R.styleable.NumberPicker_selectionDividerHeight, defSelectionDividerHeight);
+
+        final int defSelectionDividerDistance = (int) TypedValue.applyDimension(
+                TypedValue.COMPLEX_UNIT_DIP, UNSCALED_DEFAULT_SELECTION_DIVIDERS_DISTANCE,
+                getResources().getDisplayMetrics());
+        mSelectionDividersDistance = attributesArray.getDimensionPixelSize(
+                R.styleable.NumberPicker_selectionDividersDistance, defSelectionDividerDistance);
+
+        mMinHeight = attributesArray.getDimensionPixelSize(
+                R.styleable.NumberPicker_internalMinHeight, SIZE_UNSPECIFIED);
+
+        mMaxHeight = attributesArray.getDimensionPixelSize(
+                R.styleable.NumberPicker_internalMaxHeight, SIZE_UNSPECIFIED);
+        if (mMinHeight != SIZE_UNSPECIFIED && mMaxHeight != SIZE_UNSPECIFIED
+                && mMinHeight > mMaxHeight) {
+            throw new IllegalArgumentException("minHeight > maxHeight");
+        }
+
+        mMinWidth = attributesArray.getDimensionPixelSize(
+                R.styleable.NumberPicker_internalMinWidth, SIZE_UNSPECIFIED);
+
+        mMaxWidth = attributesArray.getDimensionPixelSize(
+                R.styleable.NumberPicker_internalMaxWidth, SIZE_UNSPECIFIED);
+        if (mMinWidth != SIZE_UNSPECIFIED && mMaxWidth != SIZE_UNSPECIFIED
+                && mMinWidth > mMaxWidth) {
+            throw new IllegalArgumentException("minWidth > maxWidth");
+        }
+
+        mComputeMaxWidth = (mMaxWidth == SIZE_UNSPECIFIED);
+
+        mVirtualButtonPressedDrawable = attributesArray.getDrawable(
+                R.styleable.NumberPicker_virtualButtonPressedDrawable);
+
+        attributesArray.recycle();
+
+        mPressedStateHelper = new PressedStateHelper();
+
+        // By default Linearlayout that we extend is not drawn. This is
+        // its draw() method is not called but dispatchDraw() is called
+        // directly (see ViewGroup.drawChild()). However, this class uses
+        // the fading edge effect implemented by View and we need our
+        // draw() method to be called. Therefore, we declare we will draw.
+        setWillNotDraw(!mHasSelectorWheel);
+
+        LayoutInflater inflater = (LayoutInflater) getContext().getSystemService(
+                Context.LAYOUT_INFLATER_SERVICE);
+        inflater.inflate(layoutResId, this, true);
+
+        OnClickListener onClickListener = new OnClickListener() {
+            public void onClick(View v) {
+                hideSoftInput();
+                mInputText.clearFocus();
+                if (v.getId() == R.id.increment) {
+                    changeValueByOne(true);
+                } else {
+                    changeValueByOne(false);
+                }
+            }
+        };
+
+        OnLongClickListener onLongClickListener = new OnLongClickListener() {
+            public boolean onLongClick(View v) {
+                hideSoftInput();
+                mInputText.clearFocus();
+                if (v.getId() == R.id.increment) {
+                    postChangeCurrentByOneFromLongPress(true, 0);
+                } else {
+                    postChangeCurrentByOneFromLongPress(false, 0);
+                }
+                return true;
+            }
+        };
+
+        // increment button
+        if (!mHasSelectorWheel) {
+            mIncrementButton = (ImageButton) findViewById(R.id.increment);
+            mIncrementButton.setOnClickListener(onClickListener);
+            mIncrementButton.setOnLongClickListener(onLongClickListener);
+        } else {
+            mIncrementButton = null;
+        }
+
+        // decrement button
+        if (!mHasSelectorWheel) {
+            mDecrementButton = (ImageButton) findViewById(R.id.decrement);
+            mDecrementButton.setOnClickListener(onClickListener);
+            mDecrementButton.setOnLongClickListener(onLongClickListener);
+        } else {
+            mDecrementButton = null;
+        }
+
+        // input text
+        mInputText = (EditText) findViewById(R.id.numberpicker_input);
+        mInputText.setOnFocusChangeListener(new OnFocusChangeListener() {
+            public void onFocusChange(View v, boolean hasFocus) {
+                if (hasFocus) {
+                    mInputText.selectAll();
+                } else {
+                    mInputText.setSelection(0, 0);
+                    validateInputTextView(v);
+                }
+            }
+        });
+        mInputText.setFilters(new InputFilter[] {
+            new InputTextFilter()
+        });
+
+        mInputText.setRawInputType(InputType.TYPE_CLASS_NUMBER);
+        mInputText.setImeOptions(EditorInfo.IME_ACTION_DONE);
+
+        // initialize constants
+        ViewConfiguration configuration = ViewConfiguration.get(context);
+        mTouchSlop = configuration.getScaledTouchSlop();
+        mMinimumFlingVelocity = configuration.getScaledMinimumFlingVelocity();
+        mMaximumFlingVelocity = configuration.getScaledMaximumFlingVelocity()
+                / SELECTOR_MAX_FLING_VELOCITY_ADJUSTMENT;
+        mTextSize = (int) mInputText.getTextSize();
+
+        // create the selector wheel paint
+        Paint paint = new Paint();
+        paint.setAntiAlias(true);
+        paint.setTextAlign(Align.CENTER);
+        paint.setTextSize(mTextSize);
+        paint.setTypeface(mInputText.getTypeface());
+        ColorStateList colors = mInputText.getTextColors();
+        int color = colors.getColorForState(ENABLED_STATE_SET, Color.WHITE);
+        paint.setColor(color);
+        mSelectorWheelPaint = paint;
+
+        // create the fling and adjust scrollers
+        mFlingScroller = new Scroller(getContext(), null, true);
+        mAdjustScroller = new Scroller(getContext(), new DecelerateInterpolator(2.5f));
+
+        updateInputTextView();
+
+        // If not explicitly specified this view is important for accessibility.
+        if (getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
+            setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
+        }
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+        if (!mHasSelectorWheel) {
+            super.onLayout(changed, left, top, right, bottom);
+            return;
+        }
+        final int msrdWdth = getMeasuredWidth();
+        final int msrdHght = getMeasuredHeight();
+
+        // Input text centered horizontally.
+        final int inptTxtMsrdWdth = mInputText.getMeasuredWidth();
+        final int inptTxtMsrdHght = mInputText.getMeasuredHeight();
+        final int inptTxtLeft = (msrdWdth - inptTxtMsrdWdth) / 2;
+        final int inptTxtTop = (msrdHght - inptTxtMsrdHght) / 2;
+        final int inptTxtRight = inptTxtLeft + inptTxtMsrdWdth;
+        final int inptTxtBottom = inptTxtTop + inptTxtMsrdHght;
+        mInputText.layout(inptTxtLeft, inptTxtTop, inptTxtRight, inptTxtBottom);
+
+        if (changed) {
+            // need to do all this when we know our size
+            initializeSelectorWheel();
+            initializeFadingEdges();
+            mTopSelectionDividerTop = (getHeight() - mSelectionDividersDistance) / 2
+                    - mSelectionDividerHeight;
+            mBottomSelectionDividerBottom = mTopSelectionDividerTop + 2 * mSelectionDividerHeight
+                    + mSelectionDividersDistance;
+        }
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        if (!mHasSelectorWheel) {
+            super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+            return;
+        }
+        // Try greedily to fit the max width and height.
+        final int newWidthMeasureSpec = makeMeasureSpec(widthMeasureSpec, mMaxWidth);
+        final int newHeightMeasureSpec = makeMeasureSpec(heightMeasureSpec, mMaxHeight);
+        super.onMeasure(newWidthMeasureSpec, newHeightMeasureSpec);
+        // Flag if we are measured with width or height less than the respective min.
+        final int widthSize = resolveSizeAndStateRespectingMinSize(mMinWidth, getMeasuredWidth(),
+                widthMeasureSpec);
+        final int heightSize = resolveSizeAndStateRespectingMinSize(mMinHeight, getMeasuredHeight(),
+                heightMeasureSpec);
+        setMeasuredDimension(widthSize, heightSize);
+    }
+
+    /**
+     * Move to the final position of a scroller. Ensures to force finish the scroller
+     * and if it is not at its final position a scroll of the selector wheel is
+     * performed to fast forward to the final position.
+     *
+     * @param scroller The scroller to whose final position to get.
+     * @return True of the a move was performed, i.e. the scroller was not in final position.
+     */
+    private boolean moveToFinalScrollerPosition(Scroller scroller) {
+        scroller.forceFinished(true);
+        int amountToScroll = scroller.getFinalY() - scroller.getCurrY();
+        int futureScrollOffset = (mCurrentScrollOffset + amountToScroll) % mSelectorElementHeight;
+        int overshootAdjustment = mInitialScrollOffset - futureScrollOffset;
+        if (overshootAdjustment != 0) {
+            if (Math.abs(overshootAdjustment) > mSelectorElementHeight / 2) {
+                if (overshootAdjustment > 0) {
+                    overshootAdjustment -= mSelectorElementHeight;
+                } else {
+                    overshootAdjustment += mSelectorElementHeight;
+                }
+            }
+            amountToScroll += overshootAdjustment;
+            scrollBy(0, amountToScroll);
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onInterceptTouchEvent(MotionEvent event) {
+        if (!mHasSelectorWheel || !isEnabled()) {
+            return false;
+        }
+        final int action = event.getActionMasked();
+        switch (action) {
+            case MotionEvent.ACTION_DOWN: {
+                removeAllCallbacks();
+                mInputText.setVisibility(View.INVISIBLE);
+                mLastDownOrMoveEventY = mLastDownEventY = event.getY();
+                mLastDownEventTime = event.getEventTime();
+                mIngonreMoveEvents = false;
+                mShowSoftInputOnTap = false;
+                // Handle pressed state before any state change.
+                if (mLastDownEventY < mTopSelectionDividerTop) {
+                    if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
+                        mPressedStateHelper.buttonPressDelayed(
+                                PressedStateHelper.BUTTON_DECREMENT);
+                    }
+                } else if (mLastDownEventY > mBottomSelectionDividerBottom) {
+                    if (mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
+                        mPressedStateHelper.buttonPressDelayed(
+                                PressedStateHelper.BUTTON_INCREMENT);
+                    }
+                }
+                // Make sure we support flinging inside scrollables.
+                getParent().requestDisallowInterceptTouchEvent(true);
+                if (!mFlingScroller.isFinished()) {
+                    mFlingScroller.forceFinished(true);
+                    mAdjustScroller.forceFinished(true);
+                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
+                } else if (!mAdjustScroller.isFinished()) {
+                    mFlingScroller.forceFinished(true);
+                    mAdjustScroller.forceFinished(true);
+                } else if (mLastDownEventY < mTopSelectionDividerTop) {
+                    hideSoftInput();
+                    postChangeCurrentByOneFromLongPress(
+                            false, ViewConfiguration.getLongPressTimeout());
+                } else if (mLastDownEventY > mBottomSelectionDividerBottom) {
+                    hideSoftInput();
+                    postChangeCurrentByOneFromLongPress(
+                            true, ViewConfiguration.getLongPressTimeout());
+                } else {
+                    mShowSoftInputOnTap = true;
+                    postBeginSoftInputOnLongPressCommand();
+                }
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        if (!isEnabled() || !mHasSelectorWheel) {
+            return false;
+        }
+        if (mVelocityTracker == null) {
+            mVelocityTracker = VelocityTracker.obtain();
+        }
+        mVelocityTracker.addMovement(event);
+        int action = event.getActionMasked();
+        switch (action) {
+            case MotionEvent.ACTION_MOVE: {
+                if (mIngonreMoveEvents) {
+                    break;
+                }
+                float currentMoveY = event.getY();
+                if (mScrollState != OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {
+                    int deltaDownY = (int) Math.abs(currentMoveY - mLastDownEventY);
+                    if (deltaDownY > mTouchSlop) {
+                        removeAllCallbacks();
+                        onScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
+                    }
+                } else {
+                    int deltaMoveY = (int) ((currentMoveY - mLastDownOrMoveEventY));
+                    scrollBy(0, deltaMoveY);
+                    invalidate();
+                }
+                mLastDownOrMoveEventY = currentMoveY;
+            } break;
+            case MotionEvent.ACTION_UP: {
+                removeBeginSoftInputCommand();
+                removeChangeCurrentByOneFromLongPress();
+                mPressedStateHelper.cancel();
+                VelocityTracker velocityTracker = mVelocityTracker;
+                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
+                int initialVelocity = (int) velocityTracker.getYVelocity();
+                if (Math.abs(initialVelocity) > mMinimumFlingVelocity) {
+                    fling(initialVelocity);
+                    onScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
+                } else {
+                    int eventY = (int) event.getY();
+                    int deltaMoveY = (int) Math.abs(eventY - mLastDownEventY);
+                    long deltaTime = event.getEventTime() - mLastDownEventTime;
+                    if (deltaMoveY <= mTouchSlop && deltaTime < ViewConfiguration.getTapTimeout()) {
+                        if (mShowSoftInputOnTap) {
+                            mShowSoftInputOnTap = false;
+                            showSoftInput();
+                        } else {
+                            int selectorIndexOffset = (eventY / mSelectorElementHeight)
+                                    - SELECTOR_MIDDLE_ITEM_INDEX;
+                            if (selectorIndexOffset > 0) {
+                                changeValueByOne(true);
+                                mPressedStateHelper.buttonTapped(
+                                        PressedStateHelper.BUTTON_INCREMENT);
+                            } else if (selectorIndexOffset < 0) {
+                                changeValueByOne(false);
+                                mPressedStateHelper.buttonTapped(
+                                        PressedStateHelper.BUTTON_DECREMENT);
+                            }
+                        }
+                    } else {
+                        ensureScrollWheelAdjusted();
+                    }
+                    onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
+                }
+                mVelocityTracker.recycle();
+                mVelocityTracker = null;
+            } break;
+        }
+        return true;
+    }
+
+    @Override
+    public boolean dispatchTouchEvent(MotionEvent event) {
+        final int action = event.getActionMasked();
+        switch (action) {
+            case MotionEvent.ACTION_CANCEL:
+            case MotionEvent.ACTION_UP:
+                removeAllCallbacks();
+                break;
+        }
+        return super.dispatchTouchEvent(event);
+    }
+
+    @Override
+    public boolean dispatchKeyEvent(KeyEvent event) {
+        final int keyCode = event.getKeyCode();
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_DPAD_CENTER:
+            case KeyEvent.KEYCODE_ENTER:
+                removeAllCallbacks();
+                break;
+        }
+        return super.dispatchKeyEvent(event);
+    }
+
+    @Override
+    public boolean dispatchTrackballEvent(MotionEvent event) {
+        final int action = event.getActionMasked();
+        switch (action) {
+            case MotionEvent.ACTION_CANCEL:
+            case MotionEvent.ACTION_UP:
+                removeAllCallbacks();
+                break;
+        }
+        return super.dispatchTrackballEvent(event);
+    }
+
+    @Override
+    protected boolean dispatchHoverEvent(MotionEvent event) {
+        if (!mHasSelectorWheel) {
+            return super.dispatchHoverEvent(event);
+        }
+        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
+            final int eventY = (int) event.getY();
+            final int hoveredVirtualViewId;
+            if (eventY < mTopSelectionDividerTop) {
+                hoveredVirtualViewId = AccessibilityNodeProviderImpl.VIRTUAL_VIEW_ID_DECREMENT;
+            } else if (eventY > mBottomSelectionDividerBottom) {
+                hoveredVirtualViewId = AccessibilityNodeProviderImpl.VIRTUAL_VIEW_ID_INCREMENT;
+            } else {
+                hoveredVirtualViewId = AccessibilityNodeProviderImpl.VIRTUAL_VIEW_ID_INPUT;
+            }
+            final int action = event.getActionMasked();
+            AccessibilityNodeProviderImpl provider =
+                (AccessibilityNodeProviderImpl) getAccessibilityNodeProvider();
+            switch (action) {
+                case MotionEvent.ACTION_HOVER_ENTER: {
+                    provider.sendAccessibilityEventForVirtualView(hoveredVirtualViewId,
+                            AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
+                    mLastHoveredChildVirtualViewId = hoveredVirtualViewId;
+                    provider.performAction(hoveredVirtualViewId,
+                            AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null);
+                } break;
+                case MotionEvent.ACTION_HOVER_MOVE: {
+                    if (mLastHoveredChildVirtualViewId != hoveredVirtualViewId
+                            && mLastHoveredChildVirtualViewId != View.NO_ID) {
+                        provider.sendAccessibilityEventForVirtualView(
+                                mLastHoveredChildVirtualViewId,
+                                AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
+                        provider.sendAccessibilityEventForVirtualView(hoveredVirtualViewId,
+                                AccessibilityEvent.TYPE_VIEW_HOVER_ENTER);
+                        mLastHoveredChildVirtualViewId = hoveredVirtualViewId;
+                        provider.performAction(hoveredVirtualViewId,
+                                AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, null);
+                    }
+                } break;
+                case MotionEvent.ACTION_HOVER_EXIT: {
+                    provider.sendAccessibilityEventForVirtualView(hoveredVirtualViewId,
+                            AccessibilityEvent.TYPE_VIEW_HOVER_EXIT);
+                    mLastHoveredChildVirtualViewId = View.NO_ID;
+                } break;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public void computeScroll() {
+        Scroller scroller = mFlingScroller;
+        if (scroller.isFinished()) {
+            scroller = mAdjustScroller;
+            if (scroller.isFinished()) {
+                return;
+            }
+        }
+        scroller.computeScrollOffset();
+        int currentScrollerY = scroller.getCurrY();
+        if (mPreviousScrollerY == 0) {
+            mPreviousScrollerY = scroller.getStartY();
+        }
+        scrollBy(0, currentScrollerY - mPreviousScrollerY);
+        mPreviousScrollerY = currentScrollerY;
+        if (scroller.isFinished()) {
+            onScrollerFinished(scroller);
+        } else {
+            invalidate();
+        }
+    }
+
+    @Override
+    public void setEnabled(boolean enabled) {
+        super.setEnabled(enabled);
+        if (!mHasSelectorWheel) {
+            mIncrementButton.setEnabled(enabled);
+        }
+        if (!mHasSelectorWheel) {
+            mDecrementButton.setEnabled(enabled);
+        }
+        mInputText.setEnabled(enabled);
+    }
+
+    @Override
+    public void scrollBy(int x, int y) {
+        int[] selectorIndices = mSelectorIndices;
+        if (!mWrapSelectorWheel && y > 0
+                && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] <= mMinValue) {
+            mCurrentScrollOffset = mInitialScrollOffset;
+            return;
+        }
+        if (!mWrapSelectorWheel && y < 0
+                && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] >= mMaxValue) {
+            mCurrentScrollOffset = mInitialScrollOffset;
+            return;
+        }
+        mCurrentScrollOffset += y;
+        while (mCurrentScrollOffset - mInitialScrollOffset > mSelectorTextGapHeight) {
+            mCurrentScrollOffset -= mSelectorElementHeight;
+            decrementSelectorIndices(selectorIndices);
+            setValueInternal(selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX], true);
+            if (!mWrapSelectorWheel && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] <= mMinValue) {
+                mCurrentScrollOffset = mInitialScrollOffset;
+            }
+        }
+        while (mCurrentScrollOffset - mInitialScrollOffset < -mSelectorTextGapHeight) {
+            mCurrentScrollOffset += mSelectorElementHeight;
+            incrementSelectorIndices(selectorIndices);
+            setValueInternal(selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX], true);
+            if (!mWrapSelectorWheel && selectorIndices[SELECTOR_MIDDLE_ITEM_INDEX] >= mMaxValue) {
+                mCurrentScrollOffset = mInitialScrollOffset;
+            }
+        }
+    }
+
+    @Override
+    public int getSolidColor() {
+        return mSolidColor;
+    }
+
+    /**
+     * Sets the listener to be notified on change of the current value.
+     *
+     * @param onValueChangedListener The listener.
+     */
+    public void setOnValueChangedListener(OnValueChangeListener onValueChangedListener) {
+        mOnValueChangeListener = onValueChangedListener;
+    }
+
+    /**
+     * Set listener to be notified for scroll state changes.
+     *
+     * @param onScrollListener The listener.
+     */
+    public void setOnScrollListener(OnScrollListener onScrollListener) {
+        mOnScrollListener = onScrollListener;
+    }
+
+    /**
+     * Set the formatter to be used for formatting the current value.
+     * <p>
+     * Note: If you have provided alternative values for the values this
+     * formatter is never invoked.
+     * </p>
+     *
+     * @param formatter The formatter object. If formatter is <code>null</code>,
+     *            {@link String#valueOf(int)} will be used.
+     *@see #setDisplayedValues(String[])
+     */
+    public void setFormatter(Formatter formatter) {
+        if (formatter == mFormatter) {
+            return;
+        }
+        mFormatter = formatter;
+        initializeSelectorWheelIndices();
+        updateInputTextView();
+    }
+
+    /**
+     * Set the current value for the number picker.
+     * <p>
+     * If the argument is less than the {@link NumberPicker#getMinValue()} and
+     * {@link NumberPicker#getWrapSelectorWheel()} is <code>false</code> the
+     * current value is set to the {@link NumberPicker#getMinValue()} value.
+     * </p>
+     * <p>
+     * If the argument is less than the {@link NumberPicker#getMinValue()} and
+     * {@link NumberPicker#getWrapSelectorWheel()} is <code>true</code> the
+     * current value is set to the {@link NumberPicker#getMaxValue()} value.
+     * </p>
+     * <p>
+     * If the argument is less than the {@link NumberPicker#getMaxValue()} and
+     * {@link NumberPicker#getWrapSelectorWheel()} is <code>false</code> the
+     * current value is set to the {@link NumberPicker#getMaxValue()} value.
+     * </p>
+     * <p>
+     * If the argument is less than the {@link NumberPicker#getMaxValue()} and
+     * {@link NumberPicker#getWrapSelectorWheel()} is <code>true</code> the
+     * current value is set to the {@link NumberPicker#getMinValue()} value.
+     * </p>
+     *
+     * @param value The current value.
+     * @see #setWrapSelectorWheel(boolean)
+     * @see #setMinValue(int)
+     * @see #setMaxValue(int)
+     */
+    public void setValue(int value) {
+        setValueInternal(value, false);
+    }
+
+    /**
+     * Shows the soft input for its input text.
+     */
+    private void showSoftInput() {
+        InputMethodManager inputMethodManager = InputMethodManager.peekInstance();
+        if (inputMethodManager != null) {
+            if (mHasSelectorWheel) {
+                mInputText.setVisibility(View.VISIBLE);
+            }
+            mInputText.requestFocus();
+            inputMethodManager.showSoftInput(mInputText, 0);
+        }
+    }
+
+    /**
+     * Hides the soft input if it is active for the input text.
+     */
+    private void hideSoftInput() {
+        InputMethodManager inputMethodManager = InputMethodManager.peekInstance();
+        if (inputMethodManager != null && inputMethodManager.isActive(mInputText)) {
+            inputMethodManager.hideSoftInputFromWindow(getWindowToken(), 0);
+            if (mHasSelectorWheel) {
+                mInputText.setVisibility(View.INVISIBLE);
+            }
+        }
+    }
+
+    /**
+     * Computes the max width if no such specified as an attribute.
+     */
+    private void tryComputeMaxWidth() {
+        if (!mComputeMaxWidth) {
+            return;
+        }
+        int maxTextWidth = 0;
+        if (mDisplayedValues == null) {
+            float maxDigitWidth = 0;
+            for (int i = 0; i <= 9; i++) {
+                final float digitWidth = mSelectorWheelPaint.measureText(String.valueOf(i));
+                if (digitWidth > maxDigitWidth) {
+                    maxDigitWidth = digitWidth;
+                }
+            }
+            int numberOfDigits = 0;
+            int current = mMaxValue;
+            while (current > 0) {
+                numberOfDigits++;
+                current = current / 10;
+            }
+            maxTextWidth = (int) (numberOfDigits * maxDigitWidth);
+        } else {
+            final int valueCount = mDisplayedValues.length;
+            for (int i = 0; i < valueCount; i++) {
+                final float textWidth = mSelectorWheelPaint.measureText(mDisplayedValues[i]);
+                if (textWidth > maxTextWidth) {
+                    maxTextWidth = (int) textWidth;
+                }
+            }
+        }
+        maxTextWidth += mInputText.getPaddingLeft() + mInputText.getPaddingRight();
+        if (mMaxWidth != maxTextWidth) {
+            if (maxTextWidth > mMinWidth) {
+                mMaxWidth = maxTextWidth;
+            } else {
+                mMaxWidth = mMinWidth;
+            }
+            invalidate();
+        }
+    }
+
+    /**
+     * Gets whether the selector wheel wraps when reaching the min/max value.
+     *
+     * @return True if the selector wheel wraps.
+     *
+     * @see #getMinValue()
+     * @see #getMaxValue()
+     */
+    public boolean getWrapSelectorWheel() {
+        return mWrapSelectorWheel;
+    }
+
+    /**
+     * Sets whether the selector wheel shown during flinging/scrolling should
+     * wrap around the {@link NumberPicker#getMinValue()} and
+     * {@link NumberPicker#getMaxValue()} values.
+     * <p>
+     * By default if the range (max - min) is more than the number of items shown
+     * on the selector wheel the selector wheel wrapping is enabled.
+     * </p>
+     * <p>
+     * <strong>Note:</strong> If the number of items, i.e. the range (
+     * {@link #getMaxValue()} - {@link #getMinValue()}) is less than
+     * the number of items shown on the selector wheel, the selector wheel will
+     * not wrap. Hence, in such a case calling this method is a NOP.
+     * </p>
+     *
+     * @param wrapSelectorWheel Whether to wrap.
+     */
+    public void setWrapSelectorWheel(boolean wrapSelectorWheel) {
+        final boolean wrappingAllowed = (mMaxValue - mMinValue) >= mSelectorIndices.length;
+        if ((!wrapSelectorWheel || wrappingAllowed) && wrapSelectorWheel != mWrapSelectorWheel) {
+            mWrapSelectorWheel = wrapSelectorWheel;
+        }
+    }
+
+    /**
+     * Sets the speed at which the numbers be incremented and decremented when
+     * the up and down buttons are long pressed respectively.
+     * <p>
+     * The default value is 300 ms.
+     * </p>
+     *
+     * @param intervalMillis The speed (in milliseconds) at which the numbers
+     *            will be incremented and decremented.
+     */
+    public void setOnLongPressUpdateInterval(long intervalMillis) {
+        mLongPressUpdateInterval = intervalMillis;
+    }
+
+    /**
+     * Returns the value of the picker.
+     *
+     * @return The value.
+     */
+    public int getValue() {
+        return mValue;
+    }
+
+    /**
+     * Returns the min value of the picker.
+     *
+     * @return The min value
+     */
+    public int getMinValue() {
+        return mMinValue;
+    }
+
+    /**
+     * Sets the min value of the picker.
+     *
+     * @param minValue The min value.
+     */
+    public void setMinValue(int minValue) {
+        if (mMinValue == minValue) {
+            return;
+        }
+        if (minValue < 0) {
+            throw new IllegalArgumentException("minValue must be >= 0");
+        }
+        mMinValue = minValue;
+        if (mMinValue > mValue) {
+            mValue = mMinValue;
+        }
+        boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
+        setWrapSelectorWheel(wrapSelectorWheel);
+        initializeSelectorWheelIndices();
+        updateInputTextView();
+        tryComputeMaxWidth();
+        invalidate();
+    }
+
+    /**
+     * Returns the max value of the picker.
+     *
+     * @return The max value.
+     */
+    public int getMaxValue() {
+        return mMaxValue;
+    }
+
+    /**
+     * Sets the max value of the picker.
+     *
+     * @param maxValue The max value.
+     */
+    public void setMaxValue(int maxValue) {
+        if (mMaxValue == maxValue) {
+            return;
+        }
+        if (maxValue < 0) {
+            throw new IllegalArgumentException("maxValue must be >= 0");
+        }
+        mMaxValue = maxValue;
+        if (mMaxValue < mValue) {
+            mValue = mMaxValue;
+        }
+        boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
+        setWrapSelectorWheel(wrapSelectorWheel);
+        initializeSelectorWheelIndices();
+        updateInputTextView();
+        tryComputeMaxWidth();
+        invalidate();
+    }
+
+    /**
+     * Gets the values to be displayed instead of string values.
+     *
+     * @return The displayed values.
+     */
+    public String[] getDisplayedValues() {
+        return mDisplayedValues;
+    }
+
+    /**
+     * Sets the values to be displayed.
+     *
+     * @param displayedValues The displayed values.
+     */
+    public void setDisplayedValues(String[] displayedValues) {
+        if (mDisplayedValues == displayedValues) {
+            return;
+        }
+        mDisplayedValues = displayedValues;
+        if (mDisplayedValues != null) {
+            // Allow text entry rather than strictly numeric entry.
+            mInputText.setRawInputType(InputType.TYPE_CLASS_TEXT
+                    | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
+        } else {
+            mInputText.setRawInputType(InputType.TYPE_CLASS_NUMBER);
+        }
+        updateInputTextView();
+        initializeSelectorWheelIndices();
+        tryComputeMaxWidth();
+    }
+
+    @Override
+    protected float getTopFadingEdgeStrength() {
+        return TOP_AND_BOTTOM_FADING_EDGE_STRENGTH;
+    }
+
+    @Override
+    protected float getBottomFadingEdgeStrength() {
+        return TOP_AND_BOTTOM_FADING_EDGE_STRENGTH;
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        removeAllCallbacks();
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        if (!mHasSelectorWheel) {
+            super.onDraw(canvas);
+            return;
+        }
+        float x = (mRight - mLeft) / 2;
+        float y = mCurrentScrollOffset;
+
+        // draw the virtual buttons pressed state if needed
+        if (mVirtualButtonPressedDrawable != null
+                && mScrollState == OnScrollListener.SCROLL_STATE_IDLE) {
+            if (mDecrementVirtualButtonPressed) {
+                mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET);
+                mVirtualButtonPressedDrawable.setBounds(0, 0, mRight, mTopSelectionDividerTop);
+                mVirtualButtonPressedDrawable.draw(canvas);
+            }
+            if (mIncrementVirtualButtonPressed) {
+                mVirtualButtonPressedDrawable.setState(PRESSED_STATE_SET);
+                mVirtualButtonPressedDrawable.setBounds(0, mBottomSelectionDividerBottom, mRight,
+                        mBottom);
+                mVirtualButtonPressedDrawable.draw(canvas);
+            }
+        }
+
+        // draw the selector wheel
+        int[] selectorIndices = mSelectorIndices;
+        for (int i = 0; i < selectorIndices.length; i++) {
+            int selectorIndex = selectorIndices[i];
+            String scrollSelectorValue = mSelectorIndexToStringCache.get(selectorIndex);
+            // Do not draw the middle item if input is visible since the input
+            // is shown only if the wheel is static and it covers the middle
+            // item. Otherwise, if the user starts editing the text via the
+            // IME he may see a dimmed version of the old value intermixed
+            // with the new one.
+            if (i != SELECTOR_MIDDLE_ITEM_INDEX || mInputText.getVisibility() != VISIBLE) {
+                canvas.drawText(scrollSelectorValue, x, y, mSelectorWheelPaint);
+            }
+            y += mSelectorElementHeight;
+        }
+
+        // draw the selection dividers
+        if (mSelectionDivider != null) {
+            // draw the top divider
+            int topOfTopDivider = mTopSelectionDividerTop;
+            int bottomOfTopDivider = topOfTopDivider + mSelectionDividerHeight;
+            mSelectionDivider.setBounds(0, topOfTopDivider, mRight, bottomOfTopDivider);
+            mSelectionDivider.draw(canvas);
+
+            // draw the bottom divider
+            int bottomOfBottomDivider = mBottomSelectionDividerBottom;
+            int topOfBottomDivider = bottomOfBottomDivider - mSelectionDividerHeight;
+            mSelectionDivider.setBounds(0, topOfBottomDivider, mRight, bottomOfBottomDivider);
+            mSelectionDivider.draw(canvas);
+        }
+    }
+
+    @Override
+    public void addFocusables(ArrayList<View> views, int direction, int focusableMode) {
+        // We do not want the real descendant to be considered focus search
+        // since it is managed by the accessibility node provider.
+        if ((focusableMode & FOCUSABLES_ACCESSIBILITY) == FOCUSABLES_ACCESSIBILITY) {
+            if (isAccessibilityFocusable()) {
+                views.add(this);
+                return;
+            }
+        }
+        super.addFocusables(views, direction, focusableMode);
+    }
+
+    @Override
+    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
+        super.onInitializeAccessibilityEvent(event);
+        event.setClassName(NumberPicker.class.getName());
+        event.setScrollable(true);
+        event.setScrollY((mMinValue + mValue) * mSelectorElementHeight);
+        event.setMaxScrollY((mMaxValue - mMinValue) * mSelectorElementHeight);
+    }
+
+    @Override
+    public AccessibilityNodeProvider getAccessibilityNodeProvider() {
+        if (!mHasSelectorWheel) {
+            return super.getAccessibilityNodeProvider();
+        }
+        if (mAccessibilityNodeProvider == null) {
+            mAccessibilityNodeProvider = new AccessibilityNodeProviderImpl();
+        }
+        return mAccessibilityNodeProvider;
+    }
+
+    /**
+     * Makes a measure spec that tries greedily to use the max value.
+     *
+     * @param measureSpec The measure spec.
+     * @param maxSize The max value for the size.
+     * @return A measure spec greedily imposing the max size.
+     */
+    private int makeMeasureSpec(int measureSpec, int maxSize) {
+        if (maxSize == SIZE_UNSPECIFIED) {
+            return measureSpec;
+        }
+        final int size = MeasureSpec.getSize(measureSpec);
+        final int mode = MeasureSpec.getMode(measureSpec);
+        switch (mode) {
+            case MeasureSpec.EXACTLY:
+                return measureSpec;
+            case MeasureSpec.AT_MOST:
+                return MeasureSpec.makeMeasureSpec(Math.min(size, maxSize), MeasureSpec.EXACTLY);
+            case MeasureSpec.UNSPECIFIED:
+                return MeasureSpec.makeMeasureSpec(maxSize, MeasureSpec.EXACTLY);
+            default:
+                throw new IllegalArgumentException("Unknown measure mode: " + mode);
+        }
+    }
+
+    /**
+     * Utility to reconcile a desired size and state, with constraints imposed
+     * by a MeasureSpec. Tries to respect the min size, unless a different size
+     * is imposed by the constraints.
+     *
+     * @param minSize The minimal desired size.
+     * @param measuredSize The currently measured size.
+     * @param measureSpec The current measure spec.
+     * @return The resolved size and state.
+     */
+    private int resolveSizeAndStateRespectingMinSize(
+            int minSize, int measuredSize, int measureSpec) {
+        if (minSize != SIZE_UNSPECIFIED) {
+            final int desiredWidth = Math.max(minSize, measuredSize);
+            return resolveSizeAndState(desiredWidth, measureSpec, 0);
+        } else {
+            return measuredSize;
+        }
+    }
+
+    /**
+     * Resets the selector indices and clear the cached string representation of
+     * these indices.
+     */
+    private void initializeSelectorWheelIndices() {
+        mSelectorIndexToStringCache.clear();
+        int[] selectorIndices = mSelectorIndices;
+        int current = getValue();
+        for (int i = 0; i < mSelectorIndices.length; i++) {
+            int selectorIndex = current + (i - SELECTOR_MIDDLE_ITEM_INDEX);
+            if (mWrapSelectorWheel) {
+                selectorIndex = getWrappedSelectorIndex(selectorIndex);
+            }
+            selectorIndices[i] = selectorIndex;
+            ensureCachedScrollSelectorValue(selectorIndices[i]);
+        }
+    }
+
+    /**
+     * Sets the current value of this NumberPicker.
+     *
+     * @param current The new value of the NumberPicker.
+     * @param notifyChange Whether to notify if the current value changed.
+     */
+    private void setValueInternal(int current, boolean notifyChange) {
+        if (mValue == current) {
+            return;
+        }
+        // Wrap around the values if we go past the start or end
+        if (mWrapSelectorWheel) {
+            current = getWrappedSelectorIndex(current);
+        } else {
+            current = Math.max(current, mMinValue);
+            current = Math.min(current, mMaxValue);
+        }
+        int previous = mValue;
+        mValue = current;
+        updateInputTextView();
+        if (notifyChange) {
+            notifyChange(previous, current);
+        }
+        initializeSelectorWheelIndices();
+        invalidate();
+    }
+
+    /**
+     * Changes the current value by one which is increment or
+     * decrement based on the passes argument.
+     * decrement the current value.
+     *
+     * @param increment True to increment, false to decrement.
+     */
+     private void changeValueByOne(boolean increment) {
+        if (mHasSelectorWheel) {
+            mInputText.setVisibility(View.INVISIBLE);
+            if (!moveToFinalScrollerPosition(mFlingScroller)) {
+                moveToFinalScrollerPosition(mAdjustScroller);
+            }
+            mPreviousScrollerY = 0;
+            if (increment) {
+                mFlingScroller.startScroll(0, 0, 0, -mSelectorElementHeight, SNAP_SCROLL_DURATION);
+            } else {
+                mFlingScroller.startScroll(0, 0, 0, mSelectorElementHeight, SNAP_SCROLL_DURATION);
+            }
+            invalidate();
+        } else {
+            if (increment) {
+                setValueInternal(mValue + 1, true);
+            } else {
+                setValueInternal(mValue - 1, true);
+            }
+        }
+    }
+
+    private void initializeSelectorWheel() {
+        initializeSelectorWheelIndices();
+        int[] selectorIndices = mSelectorIndices;
+        int totalTextHeight = selectorIndices.length * mTextSize;
+        float totalTextGapHeight = (mBottom - mTop) - totalTextHeight;
+        float textGapCount = selectorIndices.length;
+        mSelectorTextGapHeight = (int) (totalTextGapHeight / textGapCount + 0.5f);
+        mSelectorElementHeight = mTextSize + mSelectorTextGapHeight;
+        // Ensure that the middle item is positioned the same as the text in
+        // mInputText
+        int editTextTextPosition = mInputText.getBaseline() + mInputText.getTop();
+        mInitialScrollOffset = editTextTextPosition
+                - (mSelectorElementHeight * SELECTOR_MIDDLE_ITEM_INDEX);
+        mCurrentScrollOffset = mInitialScrollOffset;
+        updateInputTextView();
+    }
+
+    private void initializeFadingEdges() {
+        setVerticalFadingEdgeEnabled(true);
+        setFadingEdgeLength((mBottom - mTop - mTextSize) / 2);
+    }
+
+    /**
+     * Callback invoked upon completion of a given <code>scroller</code>.
+     */
+    private void onScrollerFinished(Scroller scroller) {
+        if (scroller == mFlingScroller) {
+            if (!ensureScrollWheelAdjusted()) {
+                updateInputTextView();
+            }
+            onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
+        } else {
+            if (mScrollState != OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {
+                updateInputTextView();
+            }
+        }
+    }
+
+    /**
+     * Handles transition to a given <code>scrollState</code>
+     */
+    private void onScrollStateChange(int scrollState) {
+        if (mScrollState == scrollState) {
+            return;
+        }
+        mScrollState = scrollState;
+        if (mOnScrollListener != null) {
+            mOnScrollListener.onScrollStateChange(this, scrollState);
+        }
+    }
+
+    /**
+     * Flings the selector with the given <code>velocityY</code>.
+     */
+    private void fling(int velocityY) {
+        mPreviousScrollerY = 0;
+
+        if (velocityY > 0) {
+            mFlingScroller.fling(0, 0, 0, velocityY, 0, 0, 0, Integer.MAX_VALUE);
+        } else {
+            mFlingScroller.fling(0, Integer.MAX_VALUE, 0, velocityY, 0, 0, 0, Integer.MAX_VALUE);
+        }
+
+        invalidate();
+    }
+
+    /**
+     * @return The wrapped index <code>selectorIndex</code> value.
+     */
+    private int getWrappedSelectorIndex(int selectorIndex) {
+        if (selectorIndex > mMaxValue) {
+            return mMinValue + (selectorIndex - mMaxValue) % (mMaxValue - mMinValue) - 1;
+        } else if (selectorIndex < mMinValue) {
+            return mMaxValue - (mMinValue - selectorIndex) % (mMaxValue - mMinValue) + 1;
+        }
+        return selectorIndex;
+    }
+
+    /**
+     * Increments the <code>selectorIndices</code> whose string representations
+     * will be displayed in the selector.
+     */
+    private void incrementSelectorIndices(int[] selectorIndices) {
+        for (int i = 0; i < selectorIndices.length - 1; i++) {
+            selectorIndices[i] = selectorIndices[i + 1];
+        }
+        int nextScrollSelectorIndex = selectorIndices[selectorIndices.length - 2] + 1;
+        if (mWrapSelectorWheel && nextScrollSelectorIndex > mMaxValue) {
+            nextScrollSelectorIndex = mMinValue;
+        }
+        selectorIndices[selectorIndices.length - 1] = nextScrollSelectorIndex;
+        ensureCachedScrollSelectorValue(nextScrollSelectorIndex);
+    }
+
+    /**
+     * Decrements the <code>selectorIndices</code> whose string representations
+     * will be displayed in the selector.
+     */
+    private void decrementSelectorIndices(int[] selectorIndices) {
+        for (int i = selectorIndices.length - 1; i > 0; i--) {
+            selectorIndices[i] = selectorIndices[i - 1];
+        }
+        int nextScrollSelectorIndex = selectorIndices[1] - 1;
+        if (mWrapSelectorWheel && nextScrollSelectorIndex < mMinValue) {
+            nextScrollSelectorIndex = mMaxValue;
+        }
+        selectorIndices[0] = nextScrollSelectorIndex;
+        ensureCachedScrollSelectorValue(nextScrollSelectorIndex);
+    }
+
+    /**
+     * Ensures we have a cached string representation of the given <code>
+     * selectorIndex</code> to avoid multiple instantiations of the same string.
+     */
+    private void ensureCachedScrollSelectorValue(int selectorIndex) {
+        SparseArray<String> cache = mSelectorIndexToStringCache;
+        String scrollSelectorValue = cache.get(selectorIndex);
+        if (scrollSelectorValue != null) {
+            return;
+        }
+        if (selectorIndex < mMinValue || selectorIndex > mMaxValue) {
+            scrollSelectorValue = "";
+        } else {
+            if (mDisplayedValues != null) {
+                int displayedValueIndex = selectorIndex - mMinValue;
+                scrollSelectorValue = mDisplayedValues[displayedValueIndex];
+            } else {
+                scrollSelectorValue = formatNumber(selectorIndex);
+            }
+        }
+        cache.put(selectorIndex, scrollSelectorValue);
+    }
+
+    private String formatNumber(int value) {
+        return (mFormatter != null) ? mFormatter.format(value) : String.valueOf(value);
+    }
+
+    private void validateInputTextView(View v) {
+        String str = String.valueOf(((TextView) v).getText());
+        if (TextUtils.isEmpty(str)) {
+            // Restore to the old value as we don't allow empty values
+            updateInputTextView();
+        } else {
+            // Check the new value and ensure it's in range
+            int current = getSelectedPos(str.toString());
+            setValueInternal(current, true);
+        }
+    }
+
+    /**
+     * Updates the view of this NumberPicker. If displayValues were specified in
+     * the string corresponding to the index specified by the current value will
+     * be returned. Otherwise, the formatter specified in {@link #setFormatter}
+     * will be used to format the number.
+     *
+     * @return Whether the text was updated.
+     */
+    private boolean updateInputTextView() {
+        /*
+         * If we don't have displayed values then use the current number else
+         * find the correct value in the displayed values for the current
+         * number.
+         */
+        String text = (mDisplayedValues == null) ? formatNumber(mValue)
+                : mDisplayedValues[mValue - mMinValue];
+        if (!TextUtils.isEmpty(text) && !text.equals(mInputText.getText().toString())) {
+            mInputText.setText(text);
+            return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * Notifies the listener, if registered, of a change of the value of this
+     * NumberPicker.
+     */
+    private void notifyChange(int previous, int current) {
+        if (mOnValueChangeListener != null) {
+            mOnValueChangeListener.onValueChange(this, previous, mValue);
+        }
+    }
+
+    /**
+     * Posts a command for changing the current value by one.
+     *
+     * @param increment Whether to increment or decrement the value.
+     */
+    private void postChangeCurrentByOneFromLongPress(boolean increment, long delayMillis) {
+        if (mChangeCurrentByOneFromLongPressCommand == null) {
+            mChangeCurrentByOneFromLongPressCommand = new ChangeCurrentByOneFromLongPressCommand();
+        } else {
+            removeCallbacks(mChangeCurrentByOneFromLongPressCommand);
+        }
+        mChangeCurrentByOneFromLongPressCommand.setStep(increment);
+        postDelayed(mChangeCurrentByOneFromLongPressCommand, delayMillis);
+    }
+
+    /**
+     * Removes the command for changing the current value by one.
+     */
+    private void removeChangeCurrentByOneFromLongPress() {
+        if (mChangeCurrentByOneFromLongPressCommand != null) {
+            removeCallbacks(mChangeCurrentByOneFromLongPressCommand);
+        }
+    }
+
+    /**
+     * Posts a command for beginning an edit of the current value via IME on
+     * long press.
+     */
+    private void postBeginSoftInputOnLongPressCommand() {
+        if (mBeginSoftInputOnLongPressCommand == null) {
+            mBeginSoftInputOnLongPressCommand = new BeginSoftInputOnLongPressCommand();
+        } else {
+            removeCallbacks(mBeginSoftInputOnLongPressCommand);
+        }
+        postDelayed(mBeginSoftInputOnLongPressCommand, ViewConfiguration.getLongPressTimeout());
+    }
+
+    /**
+     * Removes the command for beginning an edit of the current value via IME.
+     */
+    private void removeBeginSoftInputCommand() {
+        if (mBeginSoftInputOnLongPressCommand != null) {
+            removeCallbacks(mBeginSoftInputOnLongPressCommand);
+        }
+    }
+
+    /**
+     * Removes all pending callback from the message queue.
+     */
+    private void removeAllCallbacks() {
+        if (mChangeCurrentByOneFromLongPressCommand != null) {
+            removeCallbacks(mChangeCurrentByOneFromLongPressCommand);
+        }
+        if (mSetSelectionCommand != null) {
+            removeCallbacks(mSetSelectionCommand);
+        }
+        if (mBeginSoftInputOnLongPressCommand != null) {
+            removeCallbacks(mBeginSoftInputOnLongPressCommand);
+        }
+        mPressedStateHelper.cancel();
+    }
+
+    /**
+     * @return The selected index given its displayed <code>value</code>.
+     */
+    private int getSelectedPos(String value) {
+        if (mDisplayedValues == null) {
+            try {
+                return Integer.parseInt(value);
+            } catch (NumberFormatException e) {
+                // Ignore as if it's not a number we don't care
+            }
+        } else {
+            for (int i = 0; i < mDisplayedValues.length; i++) {
+                // Don't force the user to type in jan when ja will do
+                value = value.toLowerCase();
+                if (mDisplayedValues[i].toLowerCase().startsWith(value)) {
+                    return mMinValue + i;
+                }
+            }
+
+            /*
+             * The user might have typed in a number into the month field i.e.
+             * 10 instead of OCT so support that too.
+             */
+            try {
+                return Integer.parseInt(value);
+            } catch (NumberFormatException e) {
+
+                // Ignore as if it's not a number we don't care
+            }
+        }
+        return mMinValue;
+    }
+
+    /**
+     * Posts an {@link SetSelectionCommand} from the given <code>selectionStart
+     * </code> to <code>selectionEnd</code>.
+     */
+    private void postSetSelectionCommand(int selectionStart, int selectionEnd) {
+        if (mSetSelectionCommand == null) {
+            mSetSelectionCommand = new SetSelectionCommand();
+        } else {
+            removeCallbacks(mSetSelectionCommand);
+        }
+        mSetSelectionCommand.mSelectionStart = selectionStart;
+        mSetSelectionCommand.mSelectionEnd = selectionEnd;
+        post(mSetSelectionCommand);
+    }
+
+    /**
+     * Filter for accepting only valid indices or prefixes of the string
+     * representation of valid indices.
+     */
+    class InputTextFilter extends NumberKeyListener {
+
+        // XXX This doesn't allow for range limits when controlled by a
+        // soft input method!
+        public int getInputType() {
+            return InputType.TYPE_CLASS_TEXT;
+        }
+
+        @Override
+        protected char[] getAcceptedChars() {
+            return DIGIT_CHARACTERS;
+        }
+
+        @Override
+        public CharSequence filter(
+                CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {
+            if (mDisplayedValues == null) {
+                CharSequence filtered = super.filter(source, start, end, dest, dstart, dend);
+                if (filtered == null) {
+                    filtered = source.subSequence(start, end);
+                }
+
+                String result = String.valueOf(dest.subSequence(0, dstart)) + filtered
+                        + dest.subSequence(dend, dest.length());
+
+                if ("".equals(result)) {
+                    return result;
+                }
+                int val = getSelectedPos(result);
+
+                /*
+                 * Ensure the user can't type in a value greater than the max
+                 * allowed. We have to allow less than min as the user might
+                 * want to delete some numbers and then type a new number.
+                 */
+                if (val > mMaxValue) {
+                    return "";
+                } else {
+                    return filtered;
+                }
+            } else {
+                CharSequence filtered = String.valueOf(source.subSequence(start, end));
+                if (TextUtils.isEmpty(filtered)) {
+                    return "";
+                }
+                String result = String.valueOf(dest.subSequence(0, dstart)) + filtered
+                        + dest.subSequence(dend, dest.length());
+                String str = String.valueOf(result).toLowerCase();
+                for (String val : mDisplayedValues) {
+                    String valLowerCase = val.toLowerCase();
+                    if (valLowerCase.startsWith(str)) {
+                        postSetSelectionCommand(result.length(), val.length());
+                        return val.subSequence(dstart, val.length());
+                    }
+                }
+                return "";
+            }
+        }
+    }
+
+    /**
+     * Ensures that the scroll wheel is adjusted i.e. there is no offset and the
+     * middle element is in the middle of the widget.
+     *
+     * @return Whether an adjustment has been made.
+     */
+    private boolean ensureScrollWheelAdjusted() {
+        // adjust to the closest value
+        int deltaY = mInitialScrollOffset - mCurrentScrollOffset;
+        if (deltaY != 0) {
+            mPreviousScrollerY = 0;
+            if (Math.abs(deltaY) > mSelectorElementHeight / 2) {
+                deltaY += (deltaY > 0) ? -mSelectorElementHeight : mSelectorElementHeight;
+            }
+            mAdjustScroller.startScroll(0, 0, 0, deltaY, SELECTOR_ADJUSTMENT_DURATION_MILLIS);
+            invalidate();
+            return true;
+        }
+        return false;
+    }
+
+    class PressedStateHelper implements Runnable {
+        public static final int BUTTON_INCREMENT = 1;
+        public static final int BUTTON_DECREMENT = 2;
+
+        private final int MODE_PRESS = 1;
+        private final int MODE_TAPPED = 2;
+
+        private int mManagedButton;
+        private int mMode;
+
+        public void cancel() {
+            mMode = 0;
+            mManagedButton = 0;
+            NumberPicker.this.removeCallbacks(this);
+            if (mIncrementVirtualButtonPressed) {
+                mIncrementVirtualButtonPressed = false;
+                invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
+            }
+            mDecrementVirtualButtonPressed = false;
+            if (mDecrementVirtualButtonPressed) {
+                invalidate(0, 0, mRight, mTopSelectionDividerTop);
+            }
+        }
+
+        public void buttonPressDelayed(int button) {
+            cancel();
+            mMode = MODE_PRESS;
+            mManagedButton = button;
+            NumberPicker.this.postDelayed(this, ViewConfiguration.getTapTimeout());
+        }
+
+        public void buttonTapped(int button) {
+            cancel();
+            mMode = MODE_TAPPED;
+            mManagedButton = button;
+            NumberPicker.this.post(this);
+        }
+
+        @Override
+        public void run() {
+            switch (mMode) {
+                case MODE_PRESS: {
+                    switch (mManagedButton) {
+                        case BUTTON_INCREMENT: {
+                            mIncrementVirtualButtonPressed = true;
+                            invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
+                        } break;
+                        case BUTTON_DECREMENT: {
+                            mDecrementVirtualButtonPressed = true;
+                            invalidate(0, 0, mRight, mTopSelectionDividerTop);
+                        }
+                    }
+                } break;
+                case MODE_TAPPED: {
+                    switch (mManagedButton) {
+                        case BUTTON_INCREMENT: {
+                            if (!mIncrementVirtualButtonPressed) {
+                                NumberPicker.this.postDelayed(this,
+                                        ViewConfiguration.getPressedStateDuration());
+                            }
+                            mIncrementVirtualButtonPressed ^= true;
+                            invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
+                        } break;
+                        case BUTTON_DECREMENT: {
+                            if (!mDecrementVirtualButtonPressed) {
+                                NumberPicker.this.postDelayed(this,
+                                        ViewConfiguration.getPressedStateDuration());
+                            }
+                            mDecrementVirtualButtonPressed ^= true;
+                            invalidate(0, 0, mRight, mTopSelectionDividerTop);
+                        }
+                    }
+                } break;
+            }
+        }
+    }
+
+    /**
+     * Command for setting the input text selection.
+     */
+    class SetSelectionCommand implements Runnable {
+        private int mSelectionStart;
+
+        private int mSelectionEnd;
+
+        public void run() {
+            mInputText.setSelection(mSelectionStart, mSelectionEnd);
+        }
+    }
+
+    /**
+     * Command for changing the current value from a long press by one.
+     */
+    class ChangeCurrentByOneFromLongPressCommand implements Runnable {
+        private boolean mIncrement;
+
+        private void setStep(boolean increment) {
+            mIncrement = increment;
+        }
+
+        @Override
+        public void run() {
+            changeValueByOne(mIncrement);
+            postDelayed(this, mLongPressUpdateInterval);
+        }
+    }
+
+    /**
+     * @hide
+     */
+    public static class CustomEditText extends EditText {
+
+        public CustomEditText(Context context, AttributeSet attrs) {
+            super(context, attrs);
+        }
+
+        @Override
+        public void onEditorAction(int actionCode) {
+            super.onEditorAction(actionCode);
+            if (actionCode == EditorInfo.IME_ACTION_DONE) {
+                clearFocus();
+            }
+        }
+    }
+
+    /**
+     * Command for beginning soft input on long press.
+     */
+    class BeginSoftInputOnLongPressCommand implements Runnable {
+
+        @Override
+        public void run() {
+            showSoftInput();
+            mIngonreMoveEvents = true;
+        }
+    }
+
+    /**
+     * Class for managing virtual view tree rooted at this picker.
+     */
+    class AccessibilityNodeProviderImpl extends AccessibilityNodeProvider {
+        private static final int UNDEFINED = Integer.MIN_VALUE;
+
+        private static final int VIRTUAL_VIEW_ID_INCREMENT = 1;
+
+        private static final int VIRTUAL_VIEW_ID_INPUT = 2;
+
+        private static final int VIRTUAL_VIEW_ID_DECREMENT = 3;
+
+        private final Rect mTempRect = new Rect();
+
+        private final int[] mTempArray = new int[2];
+
+        private int mAccessibilityFocusedView = UNDEFINED;
+
+        @Override
+        public AccessibilityNodeInfo createAccessibilityNodeInfo(int virtualViewId) {
+            switch (virtualViewId) {
+                case View.NO_ID:
+                    return createAccessibilityNodeInfoForNumberPicker( mScrollX, mScrollY,
+                            mScrollX + (mRight - mLeft), mScrollY + (mBottom - mTop));
+                case VIRTUAL_VIEW_ID_DECREMENT:
+                    return createAccessibilityNodeInfoForVirtualButton(VIRTUAL_VIEW_ID_DECREMENT,
+                            getVirtualDecrementButtonText(), mScrollX, mScrollY,
+                            mScrollX + (mRight - mLeft),
+                            mTopSelectionDividerTop + mSelectionDividerHeight);
+                case VIRTUAL_VIEW_ID_INPUT:
+                    return createAccessibiltyNodeInfoForInputText();
+                case VIRTUAL_VIEW_ID_INCREMENT:
+                    return createAccessibilityNodeInfoForVirtualButton(VIRTUAL_VIEW_ID_INCREMENT,
+                            getVirtualIncrementButtonText(), mScrollX,
+                            mBottomSelectionDividerBottom - mSelectionDividerHeight,
+                            mScrollX + (mRight - mLeft), mScrollY + (mBottom - mTop));
+            }
+            return super.createAccessibilityNodeInfo(virtualViewId);
+        }
+
+        @Override
+        public List<AccessibilityNodeInfo> findAccessibilityNodeInfosByText(String searched,
+                int virtualViewId) {
+            if (TextUtils.isEmpty(searched)) {
+                return Collections.emptyList();
+            }
+            String searchedLowerCase = searched.toLowerCase();
+            List<AccessibilityNodeInfo> result = new ArrayList<AccessibilityNodeInfo>();
+            switch (virtualViewId) {
+                case View.NO_ID: {
+                    findAccessibilityNodeInfosByTextInChild(searchedLowerCase,
+                            VIRTUAL_VIEW_ID_DECREMENT, result);
+                    findAccessibilityNodeInfosByTextInChild(searchedLowerCase,
+                            VIRTUAL_VIEW_ID_INPUT, result);
+                    findAccessibilityNodeInfosByTextInChild(searchedLowerCase,
+                            VIRTUAL_VIEW_ID_INCREMENT, result);
+                    return result;
+                }
+                case VIRTUAL_VIEW_ID_DECREMENT:
+                case VIRTUAL_VIEW_ID_INCREMENT:
+                case VIRTUAL_VIEW_ID_INPUT: {
+                    findAccessibilityNodeInfosByTextInChild(searchedLowerCase, virtualViewId,
+                            result);
+                    return result;
+                }
+            }
+            return super.findAccessibilityNodeInfosByText(searched, virtualViewId);
+        }
+
+        @Override
+        public boolean performAction(int virtualViewId, int action, Bundle arguments) {
+            switch (virtualViewId) {
+                case View.NO_ID: {
+                    switch (action) {
+                        case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS: {
+                            if (mAccessibilityFocusedView != virtualViewId) {
+                                mAccessibilityFocusedView = virtualViewId;
+                                requestAccessibilityFocus();
+                                return true;
+                            }
+                        } return false;
+                        case AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS: {
+                            if (mAccessibilityFocusedView == virtualViewId) {
+                                mAccessibilityFocusedView = UNDEFINED;
+                                clearAccessibilityFocus();
+                                return true;
+                            }
+                            return false;
+                        }
+                        case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD: {
+                            if (NumberPicker.this.isEnabled()
+                                    && (getWrapSelectorWheel() || getValue() < getMaxValue())) {
+                                changeValueByOne(true);
+                                return true;
+                            }
+                        } return false;
+                        case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD: {
+                            if (NumberPicker.this.isEnabled()
+                                    && (getWrapSelectorWheel() || getValue() > getMinValue())) {
+                                changeValueByOne(false);
+                                return true;
+                            }
+                        } return false;
+                    }
+                } break;
+                case VIRTUAL_VIEW_ID_INPUT: {
+                    switch (action) {
+                        case AccessibilityNodeInfo.ACTION_FOCUS: {
+                            if (NumberPicker.this.isEnabled() && !mInputText.isFocused()) {
+                                return mInputText.requestFocus();
+                            }
+                        } break;
+                        case AccessibilityNodeInfo.ACTION_CLEAR_FOCUS: {
+                            if (NumberPicker.this.isEnabled() && mInputText.isFocused()) {
+                                mInputText.clearFocus();
+                                return true;
+                            }
+                            return false;
+                        }
+                        case AccessibilityNodeInfo.ACTION_CLICK: {
+                            if (NumberPicker.this.isEnabled()) {
+                                showSoftInput();
+                                return true;
+                            }
+                            return false;
+                        }
+                        case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS: {
+                            if (mAccessibilityFocusedView != virtualViewId) {
+                                mAccessibilityFocusedView = virtualViewId;
+                                sendAccessibilityEventForVirtualView(virtualViewId,
+                                        AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
+                                mInputText.invalidate();
+                                return true;
+                            }
+                        } return false;
+                        case  AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS: {
+                            if (mAccessibilityFocusedView == virtualViewId) {
+                                mAccessibilityFocusedView = UNDEFINED;
+                                sendAccessibilityEventForVirtualView(virtualViewId,
+                                        AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
+                                mInputText.invalidate();
+                                return true;
+                            }
+                        } return false;
+                        default: {
+                            return mInputText.performAccessibilityAction(action, arguments);
+                        }
+                    }
+                } return false;
+                case VIRTUAL_VIEW_ID_INCREMENT: {
+                    switch (action) {
+                        case AccessibilityNodeInfo.ACTION_CLICK: {
+                            if (NumberPicker.this.isEnabled()) {
+                                NumberPicker.this.changeValueByOne(true);
+                                sendAccessibilityEventForVirtualView(virtualViewId,
+                                        AccessibilityEvent.TYPE_VIEW_CLICKED);
+                                return true;
+                            }
+                        } return false;
+                        case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS: {
+                            if (mAccessibilityFocusedView != virtualViewId) {
+                                mAccessibilityFocusedView = virtualViewId;
+                                sendAccessibilityEventForVirtualView(virtualViewId,
+                                        AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
+                                invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
+                                return true;
+                            }
+                        } return false;
+                        case  AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS: {
+                            if (mAccessibilityFocusedView == virtualViewId) {
+                                mAccessibilityFocusedView = UNDEFINED;
+                                sendAccessibilityEventForVirtualView(virtualViewId,
+                                        AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
+                                invalidate(0, mBottomSelectionDividerBottom, mRight, mBottom);
+                                return true;
+                            }
+                        } return false;
+                    }
+                } return false;
+                case VIRTUAL_VIEW_ID_DECREMENT: {
+                    switch (action) {
+                        case AccessibilityNodeInfo.ACTION_CLICK: {
+                            if (NumberPicker.this.isEnabled()) {
+                                final boolean increment = (virtualViewId == VIRTUAL_VIEW_ID_INCREMENT);
+                                NumberPicker.this.changeValueByOne(increment);
+                                sendAccessibilityEventForVirtualView(virtualViewId,
+                                        AccessibilityEvent.TYPE_VIEW_CLICKED);
+                                return true;
+                            }
+                        } return false;
+                        case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS: {
+                            if (mAccessibilityFocusedView != virtualViewId) {
+                                mAccessibilityFocusedView = virtualViewId;
+                                sendAccessibilityEventForVirtualView(virtualViewId,
+                                        AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
+                                invalidate(0, 0, mRight, mTopSelectionDividerTop);
+                                return true;
+                            }
+                        } return false;
+                        case  AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS: {
+                            if (mAccessibilityFocusedView == virtualViewId) {
+                                mAccessibilityFocusedView = UNDEFINED;
+                                sendAccessibilityEventForVirtualView(virtualViewId,
+                                        AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED);
+                                invalidate(0, 0, mRight, mTopSelectionDividerTop);
+                                return true;
+                            }
+                        } return false;
+                    }
+                } return false;
+            }
+            return super.performAction(virtualViewId, action, arguments);
+        }
+
+        @Override
+        public AccessibilityNodeInfo findAccessibilityFocus(int virtualViewId) {
+            return createAccessibilityNodeInfo(mAccessibilityFocusedView);
+        }
+
+        @Override
+        public AccessibilityNodeInfo accessibilityFocusSearch(int direction, int virtualViewId) {
+            switch (direction) {
+                case View.ACCESSIBILITY_FOCUS_DOWN:
+                case View.ACCESSIBILITY_FOCUS_FORWARD: {
+                    switch (mAccessibilityFocusedView) {
+                        case UNDEFINED: {
+                            return createAccessibilityNodeInfo(View.NO_ID);
+                        }
+                        case View.NO_ID: {
+                            if (hasVirtualDecrementButton()) {
+                                return createAccessibilityNodeInfo(VIRTUAL_VIEW_ID_DECREMENT);
+                            }
+                        }
+                        //$FALL-THROUGH$
+                        case VIRTUAL_VIEW_ID_DECREMENT: {
+                            return createAccessibilityNodeInfo(VIRTUAL_VIEW_ID_INPUT);
+                        }
+                        case VIRTUAL_VIEW_ID_INPUT: {
+                            if (hasVirtualIncrementButton()) {
+                                return createAccessibilityNodeInfo(VIRTUAL_VIEW_ID_INCREMENT);
+                            }
+                        }
+                        //$FALL-THROUGH$
+                        case VIRTUAL_VIEW_ID_INCREMENT: {
+                            View nextFocus = NumberPicker.this.focusSearch(direction);
+                            if (nextFocus != null) {
+                                return nextFocus.createAccessibilityNodeInfo();
+                            }
+                            return null;
+                        }
+                    }
+                } break;
+                case View.ACCESSIBILITY_FOCUS_UP:
+                case View.ACCESSIBILITY_FOCUS_BACKWARD: {
+                    switch (mAccessibilityFocusedView) {
+                        case UNDEFINED: {
+                            return createAccessibilityNodeInfo(View.NO_ID);
+                        }
+                        case View.NO_ID: {
+                            if (hasVirtualIncrementButton()) {
+                                return createAccessibilityNodeInfo(VIRTUAL_VIEW_ID_INCREMENT);
+                            }
+                        }
+                        //$FALL-THROUGH$
+                        case VIRTUAL_VIEW_ID_INCREMENT: {
+                            return createAccessibilityNodeInfo(VIRTUAL_VIEW_ID_INPUT);
+                        }
+                        case VIRTUAL_VIEW_ID_INPUT: {
+                            if (hasVirtualDecrementButton()) {
+                                return createAccessibilityNodeInfo(VIRTUAL_VIEW_ID_DECREMENT);
+                            }
+                        }
+                        //$FALL-THROUGH$
+                        case VIRTUAL_VIEW_ID_DECREMENT: {
+                            View nextFocus = NumberPicker.this.focusSearch(direction);
+                            if (nextFocus != null) {
+                                return nextFocus.createAccessibilityNodeInfo();
+                            }
+                            return null;
+                        }
+                    }
+                } break;
+            }
+            return null;
+        }
+
+        public void sendAccessibilityEventForVirtualView(int virtualViewId, int eventType) {
+            switch (virtualViewId) {
+                case VIRTUAL_VIEW_ID_DECREMENT: {
+                    if (hasVirtualDecrementButton()) {
+                        sendAccessibilityEventForVirtualButton(virtualViewId, eventType,
+                                getVirtualDecrementButtonText());
+                    }
+                } break;
+                case VIRTUAL_VIEW_ID_INPUT: {
+                    sendAccessibilityEventForVirtualText(eventType);
+                } break;
+                case VIRTUAL_VIEW_ID_INCREMENT: {
+                    if (hasVirtualIncrementButton()) {
+                        sendAccessibilityEventForVirtualButton(virtualViewId, eventType,
+                                getVirtualIncrementButtonText());
+                    }
+                } break;
+            }
+        }
+
+        private void sendAccessibilityEventForVirtualText(int eventType) {
+            AccessibilityEvent event = AccessibilityEvent.obtain(eventType);
+            mInputText.onInitializeAccessibilityEvent(event);
+            mInputText.onPopulateAccessibilityEvent(event);
+            event.setSource(NumberPicker.this, VIRTUAL_VIEW_ID_INPUT);
+            requestSendAccessibilityEvent(NumberPicker.this, event);
+        }
+
+        private void sendAccessibilityEventForVirtualButton(int virtualViewId, int eventType,
+                String text) {
+            AccessibilityEvent event = AccessibilityEvent.obtain(eventType);
+            event.setClassName(Button.class.getName());
+            event.setPackageName(mContext.getPackageName());
+            event.getText().add(text);
+            event.setEnabled(NumberPicker.this.isEnabled());
+            event.setSource(NumberPicker.this, virtualViewId);
+            requestSendAccessibilityEvent(NumberPicker.this, event);
+        }
+
+        private void findAccessibilityNodeInfosByTextInChild(String searchedLowerCase,
+                int virtualViewId, List<AccessibilityNodeInfo> outResult) {
+            switch (virtualViewId) {
+                case VIRTUAL_VIEW_ID_DECREMENT: {
+                    String text = getVirtualDecrementButtonText();
+                    if (!TextUtils.isEmpty(text)
+                            && text.toString().toLowerCase().contains(searchedLowerCase)) {
+                        outResult.add(createAccessibilityNodeInfo(VIRTUAL_VIEW_ID_DECREMENT));
+                    }
+                } return;
+                case VIRTUAL_VIEW_ID_INPUT: {
+                    CharSequence text = mInputText.getText();
+                    if (!TextUtils.isEmpty(text) &&
+                            text.toString().toLowerCase().contains(searchedLowerCase)) {
+                        outResult.add(createAccessibilityNodeInfo(VIRTUAL_VIEW_ID_INPUT));
+                        return;
+                    }
+                    CharSequence contentDesc = mInputText.getText();
+                    if (!TextUtils.isEmpty(contentDesc) &&
+                            contentDesc.toString().toLowerCase().contains(searchedLowerCase)) {
+                        outResult.add(createAccessibilityNodeInfo(VIRTUAL_VIEW_ID_INPUT));
+                        return;
+                    }
+                } break;
+                case VIRTUAL_VIEW_ID_INCREMENT: {
+                    String text = getVirtualIncrementButtonText();
+                    if (!TextUtils.isEmpty(text)
+                            && text.toString().toLowerCase().contains(searchedLowerCase)) {
+                        outResult.add(createAccessibilityNodeInfo(VIRTUAL_VIEW_ID_INCREMENT));
+                    }
+                } return;
+            }
+        }
+
+        private AccessibilityNodeInfo createAccessibiltyNodeInfoForInputText() {
+            AccessibilityNodeInfo info = mInputText.createAccessibilityNodeInfo();
+            info.setSource(NumberPicker.this, VIRTUAL_VIEW_ID_INPUT);
+            if (mAccessibilityFocusedView != VIRTUAL_VIEW_ID_INPUT) {
+                info.addAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);
+            }
+            if (mAccessibilityFocusedView == VIRTUAL_VIEW_ID_INPUT) {
+                info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS);
+            }
+            return info;
+        }
+
+        private AccessibilityNodeInfo createAccessibilityNodeInfoForVirtualButton(int virtualViewId,
+                String text, int left, int top, int right, int bottom) {
+            AccessibilityNodeInfo info = AccessibilityNodeInfo.obtain();
+            info.setClassName(Button.class.getName());
+            info.setPackageName(mContext.getPackageName());
+            info.setSource(NumberPicker.this, virtualViewId);
+            info.setParent(NumberPicker.this);
+            info.setText(text);
+            info.setClickable(true);
+            info.setLongClickable(true);
+            info.setEnabled(NumberPicker.this.isEnabled());
+            Rect boundsInParent = mTempRect;
+            boundsInParent.set(left, top, right, bottom);
+            info.setVisibleToUser(isVisibleToUser(boundsInParent));
+            info.setBoundsInParent(boundsInParent);
+            Rect boundsInScreen = boundsInParent;
+            int[] locationOnScreen = mTempArray;
+            getLocationOnScreen(locationOnScreen);
+            boundsInScreen.offset(locationOnScreen[0], locationOnScreen[1]);
+            info.setBoundsInScreen(boundsInScreen);
+
+            if (mAccessibilityFocusedView != virtualViewId) {
+                info.addAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);
+            }
+            if (mAccessibilityFocusedView == virtualViewId) {
+                info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS);
+            }
+            if (NumberPicker.this.isEnabled()) {
+                info.addAction(AccessibilityNodeInfo.ACTION_CLICK);
+            }
+
+            return info;
+        }
+
+        private AccessibilityNodeInfo createAccessibilityNodeInfoForNumberPicker(int left, int top,
+                int right, int bottom) {
+            AccessibilityNodeInfo info = AccessibilityNodeInfo.obtain();
+            info.setClassName(NumberPicker.class.getName());
+            info.setPackageName(mContext.getPackageName());
+            info.setSource(NumberPicker.this);
+
+            if (hasVirtualDecrementButton()) {
+                info.addChild(NumberPicker.this, VIRTUAL_VIEW_ID_DECREMENT);
+            }
+            info.addChild(NumberPicker.this, VIRTUAL_VIEW_ID_INPUT);
+            if (hasVirtualIncrementButton()) {
+                info.addChild(NumberPicker.this, VIRTUAL_VIEW_ID_INCREMENT);
+            }
+
+            info.setParent((View) getParentForAccessibility());
+            info.setEnabled(NumberPicker.this.isEnabled());
+            info.setScrollable(true);
+            Rect boundsInParent = mTempRect;
+            boundsInParent.set(left, top, right, bottom);
+            info.setBoundsInParent(boundsInParent);
+            info.setVisibleToUser(isVisibleToUser());
+            Rect boundsInScreen = boundsInParent;
+            int[] locationOnScreen = mTempArray;
+            getLocationOnScreen(locationOnScreen);
+            boundsInScreen.offset(locationOnScreen[0], locationOnScreen[1]);
+            info.setBoundsInScreen(boundsInScreen);
+
+            if (mAccessibilityFocusedView != View.NO_ID) {
+                info.addAction(AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS);
+            }
+            if (mAccessibilityFocusedView == View.NO_ID) {
+                info.addAction(AccessibilityNodeInfo.ACTION_CLEAR_ACCESSIBILITY_FOCUS);
+            }
+            if (NumberPicker.this.isEnabled()) {
+                if (getWrapSelectorWheel() || getValue() < getMaxValue()) {
+                    info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
+                }
+                if (getWrapSelectorWheel() || getValue() > getMinValue()) {
+                    info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
+                }
+            }
+
+            return info;
+        }
+
+        private boolean hasVirtualDecrementButton() {
+            return getWrapSelectorWheel() || getValue() > getMinValue();
+        }
+
+        private boolean hasVirtualIncrementButton() {
+            return getWrapSelectorWheel() || getValue() < getMaxValue();
+        }
+
+        private String getVirtualDecrementButtonText() {
+            int value = mValue - 1;
+            if (mWrapSelectorWheel) {
+                value = getWrappedSelectorIndex(value);
+            }
+            if (value >= mMinValue) {
+                return (mDisplayedValues == null) ? formatNumber(value)
+                        : mDisplayedValues[value - mMinValue];
+            }
+            return null;
+        }
+
+        private String getVirtualIncrementButtonText() {
+            int value = mValue + 1;
+            if (mWrapSelectorWheel) {
+                value = getWrappedSelectorIndex(value);
+            }
+            if (value <= mMaxValue) {
+                return (mDisplayedValues == null) ? formatNumber(value)
+                        : mDisplayedValues[value - mMinValue];
+            }
+            return null;
+        }
+    }
+}
diff --git a/src/frameworks/base/core/java/android/widget/PopupWindow.java b/src/frameworks/base/core/java/android/widget/PopupWindow.java
new file mode 100644
index 0000000..f442912
--- /dev/null
+++ b/src/frameworks/base/core/java/android/widget/PopupWindow.java
@@ -0,0 +1,1607 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.widget;
+
+import com.android.internal.R;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.graphics.PixelFormat;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.StateListDrawable;
+import android.os.Build;
+import android.os.IBinder;
+import android.util.AttributeSet;
+import android.view.Gravity;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.View.OnTouchListener;
+import android.view.ViewGroup;
+import android.view.ViewTreeObserver;
+import android.view.ViewTreeObserver.OnScrollChangedListener;
+import android.view.WindowManager;
+
+import java.lang.ref.WeakReference;
+
+/**
+ * <p>A popup window that can be used to display an arbitrary view. The popup
+ * windows is a floating container that appears on top of the current
+ * activity.</p>
+ * 
+ * @see android.widget.AutoCompleteTextView
+ * @see android.widget.Spinner
+ */
+public class PopupWindow {
+    /**
+     * Mode for {@link #setInputMethodMode(int)}: the requirements for the
+     * input method should be based on the focusability of the popup.  That is
+     * if it is focusable than it needs to work with the input method, else
+     * it doesn't.
+     */
+    public static final int INPUT_METHOD_FROM_FOCUSABLE = 0;
+    
+    /**
+     * Mode for {@link #setInputMethodMode(int)}: this popup always needs to
+     * work with an input method, regardless of whether it is focusable.  This
+     * means that it will always be displayed so that the user can also operate
+     * the input method while it is shown.
+     */
+    public static final int INPUT_METHOD_NEEDED = 1;
+    
+    /**
+     * Mode for {@link #setInputMethodMode(int)}: this popup never needs to
+     * work with an input method, regardless of whether it is focusable.  This
+     * means that it will always be displayed to use as much space on the
+     * screen as needed, regardless of whether this covers the input method.
+     */
+    public static final int INPUT_METHOD_NOT_NEEDED = 2;
+    
+    private Context mContext;
+    private WindowManager mWindowManager;
+    
+    private boolean mIsShowing;
+    private boolean mIsDropdown;
+
+    private View mContentView;
+    private View mPopupView;
+    private boolean mFocusable;
+    private int mInputMethodMode = INPUT_METHOD_FROM_FOCUSABLE;
+    private int mSoftInputMode = WindowManager.LayoutParams.SOFT_INPUT_STATE_UNCHANGED;
+    private boolean mTouchable = true;
+    private boolean mOutsideTouchable = false;
+    private boolean mClippingEnabled = true;
+    private int mSplitTouchEnabled = -1;
+    private boolean mLayoutInScreen;
+    private boolean mClipToScreen;
+    private boolean mAllowScrollingAnchorParent = true;
+    private boolean mLayoutInsetDecor = false;
+    private boolean mNotTouchModal;
+
+    private OnTouchListener mTouchInterceptor;
+    
+    private int mWidthMode;
+    private int mWidth;
+    private int mLastWidth;
+    private int mHeightMode;
+    private int mHeight;
+    private int mLastHeight;
+
+    private int mPopupWidth;
+    private int mPopupHeight;
+
+    private int[] mDrawingLocation = new int[2];
+    private int[] mScreenLocation = new int[2];
+    private Rect mTempRect = new Rect();
+    
+    private Drawable mBackground;
+    private Drawable mAboveAnchorBackgroundDrawable;
+    private Drawable mBelowAnchorBackgroundDrawable;
+
+    private boolean mAboveAnchor;
+    private int mWindowLayoutType = WindowManager.LayoutParams.TYPE_APPLICATION_PANEL;
+    
+    private OnDismissListener mOnDismissListener;
+    private boolean mIgnoreCheekPress = false;
+
+    private int mAnimationStyle = -1;
+    
+    private static final int[] ABOVE_ANCHOR_STATE_SET = new int[] {
+        com.android.internal.R.attr.state_above_anchor
+    };
+
+    private WeakReference<View> mAnchor;
+    private OnScrollChangedListener mOnScrollChangedListener =
+        new OnScrollChangedListener() {
+            public void onScrollChanged() {
+                View anchor = mAnchor != null ? mAnchor.get() : null;
+                if (anchor != null && mPopupView != null) {
+                    WindowManager.LayoutParams p = (WindowManager.LayoutParams)
+                            mPopupView.getLayoutParams();
+
+                    updateAboveAnchor(findDropDownPosition(anchor, p, mAnchorXoff, mAnchorYoff));
+                    update(p.x, p.y, -1, -1, true);
+                }
+            }
+        };
+    private int mAnchorXoff, mAnchorYoff;
+
+    /**
+     * <p>Create a new empty, non focusable popup window of dimension (0,0).</p>
+     *
+     * <p>The popup does provide a background.</p>
+     */
+    public PopupWindow(Context context) {
+        this(context, null);
+    }
+
+    /**
+     * <p>Create a new empty, non focusable popup window of dimension (0,0).</p>
+     *
+     * <p>The popup does provide a background.</p>
+     */
+    public PopupWindow(Context context, AttributeSet attrs) {
+        this(context, attrs, com.android.internal.R.attr.popupWindowStyle);
+    }
+
+    /**
+     * <p>Create a new empty, non focusable popup window of dimension (0,0).</p>
+     *
+     * <p>The popup does provide a background.</p>
+     */
+    public PopupWindow(Context context, AttributeSet attrs, int defStyle) {
+        this(context, attrs, defStyle, 0);
+    }
+    
+    /**
+     * <p>Create a new, empty, non focusable popup window of dimension (0,0).</p>
+     * 
+     * <p>The popup does not provide a background.</p>
+     */
+    public PopupWindow(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
+        mContext = context;
+        mWindowManager = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
+
+        TypedArray a =
+            context.obtainStyledAttributes(
+                attrs, com.android.internal.R.styleable.PopupWindow, defStyleAttr, defStyleRes);
+
+        mBackground = a.getDrawable(R.styleable.PopupWindow_popupBackground);
+
+        final int animStyle = a.getResourceId(R.styleable.PopupWindow_popupAnimationStyle, -1);
+        mAnimationStyle = animStyle == com.android.internal.R.style.Animation_PopupWindow ? -1 :
+                animStyle;
+
+        // If this is a StateListDrawable, try to find and store the drawable to be
+        // used when the drop-down is placed above its anchor view, and the one to be
+        // used when the drop-down is placed below its anchor view. We extract
+        // the drawables ourselves to work around a problem with using refreshDrawableState
+        // that it will take into account the padding of all drawables specified in a
+        // StateListDrawable, thus adding superfluous padding to drop-down views.
+        //
+        // We assume a StateListDrawable will have a drawable for ABOVE_ANCHOR_STATE_SET and
+        // at least one other drawable, intended for the 'below-anchor state'.
+        if (mBackground instanceof StateListDrawable) {
+            StateListDrawable background = (StateListDrawable) mBackground;
+
+            // Find the above-anchor view - this one's easy, it should be labeled as such.
+            int aboveAnchorStateIndex = background.getStateDrawableIndex(ABOVE_ANCHOR_STATE_SET);
+            
+            // Now, for the below-anchor view, look for any other drawable specified in the
+            // StateListDrawable which is not for the above-anchor state and use that.
+            int count = background.getStateCount();
+            int belowAnchorStateIndex = -1;
+            for (int i = 0; i < count; i++) {
+                if (i != aboveAnchorStateIndex) {
+                    belowAnchorStateIndex = i;
+                    break;
+                }
+            }
+            
+            // Store the drawables we found, if we found them. Otherwise, set them both
+            // to null so that we'll just use refreshDrawableState.
+            if (aboveAnchorStateIndex != -1 && belowAnchorStateIndex != -1) {
+                mAboveAnchorBackgroundDrawable = background.getStateDrawable(aboveAnchorStateIndex);
+                mBelowAnchorBackgroundDrawable = background.getStateDrawable(belowAnchorStateIndex);
+            } else {
+                mBelowAnchorBackgroundDrawable = null;
+                mAboveAnchorBackgroundDrawable = null;
+            }
+        }
+        
+        a.recycle();
+    }
+
+    /**
+     * <p>Create a new empty, non focusable popup window of dimension (0,0).</p>
+     *
+     * <p>The popup does not provide any background. This should be handled
+     * by the content view.</p>
+     */
+    public PopupWindow() {
+        this(null, 0, 0);
+    }
+
+    /**
+     * <p>Create a new non focusable popup window which can display the
+     * <tt>contentView</tt>. The dimension of the window are (0,0).</p>
+     *
+     * <p>The popup does not provide any background. This should be handled
+     * by the content view.</p>
+     *
+     * @param contentView the popup's content
+     */
+    public PopupWindow(View contentView) {
+        this(contentView, 0, 0);
+    }
+
+    /**
+     * <p>Create a new empty, non focusable popup window. The dimension of the
+     * window must be passed to this constructor.</p>
+     *
+     * <p>The popup does not provide any background. This should be handled
+     * by the content view.</p>
+     *
+     * @param width the popup's width
+     * @param height the popup's height
+     */
+    public PopupWindow(int width, int height) {
+        this(null, width, height);
+    }
+
+    /**
+     * <p>Create a new non focusable popup window which can display the
+     * <tt>contentView</tt>. The dimension of the window must be passed to
+     * this constructor.</p>
+     *
+     * <p>The popup does not provide any background. This should be handled
+     * by the content view.</p>
+     *
+     * @param contentView the popup's content
+     * @param width the popup's width
+     * @param height the popup's height
+     */
+    public PopupWindow(View contentView, int width, int height) {
+        this(contentView, width, height, false);
+    }
+
+    /**
+     * <p>Create a new popup window which can display the <tt>contentView</tt>.
+     * The dimension of the window must be passed to this constructor.</p>
+     *
+     * <p>The popup does not provide any background. This should be handled
+     * by the content view.</p>
+     *
+     * @param contentView the popup's content
+     * @param width the popup's width
+     * @param height the popup's height
+     * @param focusable true if the popup can be focused, false otherwise
+     */
+    public PopupWindow(View contentView, int width, int height, boolean focusable) {
+        if (contentView != null) {
+            mContext = contentView.getContext();
+            mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
+        }
+        setContentView(contentView);
+        setWidth(width);
+        setHeight(height);
+        setFocusable(focusable);
+    }
+
+    /**
+     * <p>Return the drawable used as the popup window's background.</p>
+     *
+     * @return the background drawable or null
+     */
+    public Drawable getBackground() {
+        return mBackground;
+    }
+
+    /**
+     * <p>Change the background drawable for this popup window. The background
+     * can be set to null.</p>
+     *
+     * @param background the popup's background
+     */
+    public void setBackgroundDrawable(Drawable background) {
+        mBackground = background;
+    }
+
+    /**
+     * <p>Return the animation style to use the popup appears and disappears</p>
+     *
+     * @return the animation style to use the popup appears and disappears
+     */
+    public int getAnimationStyle() {
+        return mAnimationStyle;
+    }
+    
+    /**
+     * Set the flag on popup to ignore cheek press eventt; by default this flag
+     * is set to false
+     * which means the pop wont ignore cheek press dispatch events.
+     * 
+     * <p>If the popup is showing, calling this method will take effect only
+     * the next time the popup is shown or through a manual call to one of
+     * the {@link #update()} methods.</p>
+     * 
+     * @see #update()
+     */
+    public void setIgnoreCheekPress() {
+        mIgnoreCheekPress = true;
+    }
+    
+
+    /**
+     * <p>Change the animation style resource for this popup.</p>
+     *
+     * <p>If the popup is showing, calling this method will take effect only
+     * the next time the popup is shown or through a manual call to one of
+     * the {@link #update()} methods.</p>
+     *
+     * @param animationStyle animation style to use when the popup appears
+     *      and disappears.  Set to -1 for the default animation, 0 for no
+     *      animation, or a resource identifier for an explicit animation.
+     *      
+     * @see #update()
+     */
+    public void setAnimationStyle(int animationStyle) {
+        mAnimationStyle = animationStyle;
+    }
+    
+    /**
+     * <p>Return the view used as the content of the popup window.</p>
+     *
+     * @return a {@link android.view.View} representing the popup's content
+     *
+     * @see #setContentView(android.view.View)
+     */
+    public View getContentView() {
+        return mContentView;
+    }
+
+    /**
+     * <p>Change the popup's content. The content is represented by an instance
+     * of {@link android.view.View}.</p>
+     *
+     * <p>This method has no effect if called when the popup is showing.</p>
+     *
+     * @param contentView the new content for the popup
+     *
+     * @see #getContentView()
+     * @see #isShowing()
+     */
+    public void setContentView(View contentView) {
+        if (isShowing()) {
+            return;
+        }
+
+        mContentView = contentView;
+
+        if (mContext == null && mContentView != null) {
+            mContext = mContentView.getContext();
+        }
+
+        if (mWindowManager == null && mContentView != null) {
+            mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
+        }
+    }
+
+    /**
+     * Set a callback for all touch events being dispatched to the popup
+     * window.
+     */
+    public void setTouchInterceptor(OnTouchListener l) {
+        mTouchInterceptor = l;
+    }
+    
+    /**
+     * <p>Indicate whether the popup window can grab the focus.</p>
+     *
+     * @return true if the popup is focusable, false otherwise
+     *
+     * @see #setFocusable(boolean)
+     */
+    public boolean isFocusable() {
+        return mFocusable;
+    }
+
+    /**
+     * <p>Changes the focusability of the popup window. When focusable, the
+     * window will grab the focus from the current focused widget if the popup
+     * contains a focusable {@link android.view.View}.  By default a popup
+     * window is not focusable.</p>
+     *
+     * <p>If the popup is showing, calling this method will take effect only
+     * the next time the popup is shown or through a manual call to one of
+     * the {@link #update()} methods.</p>
+     *
+     * @param focusable true if the popup should grab focus, false otherwise.
+     *
+     * @see #isFocusable()
+     * @see #isShowing() 
+     * @see #update()
+     */
+    public void setFocusable(boolean focusable) {
+        mFocusable = focusable;
+    }
+
+    /**
+     * Return the current value in {@link #setInputMethodMode(int)}.
+     * 
+     * @see #setInputMethodMode(int)
+     */
+    public int getInputMethodMode() {
+        return mInputMethodMode;
+        
+    }
+    
+    /**
+     * Control how the popup operates with an input method: one of
+     * {@link #INPUT_METHOD_FROM_FOCUSABLE}, {@link #INPUT_METHOD_NEEDED},
+     * or {@link #INPUT_METHOD_NOT_NEEDED}.
+     * 
+     * <p>If the popup is showing, calling this method will take effect only
+     * the next time the popup is shown or through a manual call to one of
+     * the {@link #update()} methods.</p>
+     * 
+     * @see #getInputMethodMode()
+     * @see #update()
+     */
+    public void setInputMethodMode(int mode) {
+        mInputMethodMode = mode;
+    }
+
+    /**
+     * Sets the operating mode for the soft input area.
+     *
+     * @param mode The desired mode, see
+     *        {@link android.view.WindowManager.LayoutParams#softInputMode}
+     *        for the full list
+     *
+     * @see android.view.WindowManager.LayoutParams#softInputMode
+     * @see #getSoftInputMode()
+     */
+    public void setSoftInputMode(int mode) {
+        mSoftInputMode = mode;
+    }
+
+    /**
+     * Returns the current value in {@link #setSoftInputMode(int)}.
+     *
+     * @see #setSoftInputMode(int)
+     * @see android.view.WindowManager.LayoutParams#softInputMode
+     */
+    public int getSoftInputMode() {
+        return mSoftInputMode;
+    }
+    
+    /**
+     * <p>Indicates whether the popup window receives touch events.</p>
+     * 
+     * @return true if the popup is touchable, false otherwise
+     * 
+     * @see #setTouchable(boolean)
+     */
+    public boolean isTouchable() {
+        return mTouchable;
+    }
+
+    /**
+     * <p>Changes the touchability of the popup window. When touchable, the
+     * window will receive touch events, otherwise touch events will go to the
+     * window below it. By default the window is touchable.</p>
+     *
+     * <p>If the popup is showing, calling this method will take effect only
+     * the next time the popup is shown or through a manual call to one of
+     * the {@link #update()} methods.</p>
+     *
+     * @param touchable true if the popup should receive touch events, false otherwise
+     *
+     * @see #isTouchable()
+     * @see #isShowing() 
+     * @see #update()
+     */
+    public void setTouchable(boolean touchable) {
+        mTouchable = touchable;
+    }
+
+    /**
+     * <p>Indicates whether the popup window will be informed of touch events
+     * outside of its window.</p>
+     * 
+     * @return true if the popup is outside touchable, false otherwise
+     * 
+     * @see #setOutsideTouchable(boolean)
+     */
+    public boolean isOutsideTouchable() {
+        return mOutsideTouchable;
+    }
+
+    /**
+     * <p>Controls whether the pop-up will be informed of touch events outside
+     * of its window.  This only makes sense for pop-ups that are touchable
+     * but not focusable, which means touches outside of the window will
+     * be delivered to the window behind.  The default is false.</p>
+     *
+     * <p>If the popup is showing, calling this method will take effect only
+     * the next time the popup is shown or through a manual call to one of
+     * the {@link #update()} methods.</p>
+     *
+     * @param touchable true if the popup should receive outside
+     * touch events, false otherwise
+     *
+     * @see #isOutsideTouchable()
+     * @see #isShowing() 
+     * @see #update()
+     */
+    public void setOutsideTouchable(boolean touchable) {
+        mOutsideTouchable = touchable;
+    }
+
+    /**
+     * <p>Indicates whether clipping of the popup window is enabled.</p>
+     * 
+     * @return true if the clipping is enabled, false otherwise
+     * 
+     * @see #setClippingEnabled(boolean)
+     */
+    public boolean isClippingEnabled() {
+        return mClippingEnabled;
+    }
+
+    /**
+     * <p>Allows the popup window to extend beyond the bounds of the screen. By default the
+     * window is clipped to the screen boundaries. Setting this to false will allow windows to be
+     * accurately positioned.</p>
+     * 
+     * <p>If the popup is showing, calling this method will take effect only
+     * the next time the popup is shown or through a manual call to one of
+     * the {@link #update()} methods.</p>
+     *
+     * @param enabled false if the window should be allowed to extend outside of the screen
+     * @see #isShowing() 
+     * @see #isClippingEnabled()
+     * @see #update()
+     */
+    public void setClippingEnabled(boolean enabled) {
+        mClippingEnabled = enabled;
+    }
+
+    /**
+     * Clip this popup window to the screen, but not to the containing window.
+     *
+     * @param enabled True to clip to the screen.
+     * @hide
+     */
+    public void setClipToScreenEnabled(boolean enabled) {
+        mClipToScreen = enabled;
+        setClippingEnabled(!enabled);
+    }
+
+    /**
+     * Allow PopupWindow to scroll the anchor's parent to provide more room
+     * for the popup. Enabled by default.
+     *
+     * @param enabled True to scroll the anchor's parent when more room is desired by the popup.
+     */
+    void setAllowScrollingAnchorParent(boolean enabled) {
+        mAllowScrollingAnchorParent = enabled;
+    }
+    
+    /**
+     * <p>Indicates whether the popup window supports splitting touches.</p>
+     * 
+     * @return true if the touch splitting is enabled, false otherwise
+     * 
+     * @see #setSplitTouchEnabled(boolean)
+     */
+    public boolean isSplitTouchEnabled() {
+        if (mSplitTouchEnabled < 0 && mContext != null) {
+            return mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.HONEYCOMB;
+        }
+        return mSplitTouchEnabled == 1;
+    }
+
+    /**
+     * <p>Allows the popup window to split touches across other windows that also
+     * support split touch.  When this flag is false, the first pointer
+     * that goes down determines the window to which all subsequent touches
+     * go until all pointers go up.  When this flag is true, each pointer
+     * (not necessarily the first) that goes down determines the window
+     * to which all subsequent touches of that pointer will go until that
+     * pointer goes up thereby enabling touches with multiple pointers
+     * to be split across multiple windows.</p>
+     *
+     * @param enabled true if the split touches should be enabled, false otherwise
+     * @see #isSplitTouchEnabled()
+     */
+    public void setSplitTouchEnabled(boolean enabled) {
+        mSplitTouchEnabled = enabled ? 1 : 0;
+    }
+
+    /**
+     * <p>Indicates whether the popup window will be forced into using absolute screen coordinates
+     * for positioning.</p>
+     *
+     * @return true if the window will always be positioned in screen coordinates.
+     * @hide
+     */
+    public boolean isLayoutInScreenEnabled() {
+        return mLayoutInScreen;
+    }
+
+    /**
+     * <p>Allows the popup window to force the flag
+     * {@link WindowManager.LayoutParams#FLAG_LAYOUT_IN_SCREEN}, overriding default behavior.
+     * This will cause the popup to be positioned in absolute screen coordinates.</p>
+     *
+     * @param enabled true if the popup should always be positioned in screen coordinates
+     * @hide
+     */
+    public void setLayoutInScreenEnabled(boolean enabled) {
+        mLayoutInScreen = enabled;
+    }
+
+    /**
+     * Allows the popup window to force the flag
+     * {@link WindowManager.LayoutParams#FLAG_LAYOUT_INSET_DECOR}, overriding default behavior.
+     * This will cause the popup to inset its content to account for system windows overlaying
+     * the screen, such as the status bar.
+     *
+     * <p>This will often be combined with {@link #setLayoutInScreenEnabled(boolean)}.
+     *
+     * @param enabled true if the popup's views should inset content to account for system windows,
+     *                the way that decor views behave for full-screen windows.
+     * @hide
+     */
+    public void setLayoutInsetDecor(boolean enabled) {
+        mLayoutInsetDecor = enabled;
+    }
+
+    /**
+     * Set the layout type for this window. Should be one of the TYPE constants defined in
+     * {@link WindowManager.LayoutParams}.
+     *
+     * @param layoutType Layout type for this window.
+     * @hide
+     */
+    public void setWindowLayoutType(int layoutType) {
+        mWindowLayoutType = layoutType;
+    }
+
+    /**
+     * @return The layout type for this window.
+     * @hide
+     */
+    public int getWindowLayoutType() {
+        return mWindowLayoutType;
+    }
+
+    /**
+     * Set whether this window is touch modal or if outside touches will be sent to
+     * other windows behind it.
+     * @hide
+     */
+    public void setTouchModal(boolean touchModal) {
+        mNotTouchModal = !touchModal;
+    }
+
+    /**
+     * <p>Change the width and height measure specs that are given to the
+     * window manager by the popup.  By default these are 0, meaning that
+     * the current width or height is requested as an explicit size from
+     * the window manager.  You can supply
+     * {@link ViewGroup.LayoutParams#WRAP_CONTENT} or 
+     * {@link ViewGroup.LayoutParams#MATCH_PARENT} to have that measure
+     * spec supplied instead, replacing the absolute width and height that
+     * has been set in the popup.</p>
+     *
+     * <p>If the popup is showing, calling this method will take effect only
+     * the next time the popup is shown.</p>
+     *
+     * @param widthSpec an explicit width measure spec mode, either
+     * {@link ViewGroup.LayoutParams#WRAP_CONTENT},
+     * {@link ViewGroup.LayoutParams#MATCH_PARENT}, or 0 to use the absolute
+     * width.
+     * @param heightSpec an explicit height measure spec mode, either
+     * {@link ViewGroup.LayoutParams#WRAP_CONTENT},
+     * {@link ViewGroup.LayoutParams#MATCH_PARENT}, or 0 to use the absolute
+     * height.
+     */
+    public void setWindowLayoutMode(int widthSpec, int heightSpec) {
+        mWidthMode = widthSpec;
+        mHeightMode = heightSpec;
+    }
+    
+    /**
+     * <p>Return this popup's height MeasureSpec</p>
+     *
+     * @return the height MeasureSpec of the popup
+     *
+     * @see #setHeight(int)
+     */
+    public int getHeight() {
+        return mHeight;
+    }
+
+    /**
+     * <p>Change the popup's height MeasureSpec</p>
+     *
+     * <p>If the popup is showing, calling this method will take effect only
+     * the next time the popup is shown.</p>
+     *
+     * @param height the height MeasureSpec of the popup
+     *
+     * @see #getHeight()
+     * @see #isShowing() 
+     */
+    public void setHeight(int height) {
+        mHeight = height;
+    }
+
+    /**
+     * <p>Return this popup's width MeasureSpec</p>
+     *
+     * @return the width MeasureSpec of the popup
+     *
+     * @see #setWidth(int) 
+     */
+    public int getWidth() {
+        return mWidth;
+    }
+
+    /**
+     * <p>Change the popup's width MeasureSpec</p>
+     *
+     * <p>If the popup is showing, calling this method will take effect only
+     * the next time the popup is shown.</p>
+     *
+     * @param width the width MeasureSpec of the popup
+     *
+     * @see #getWidth()
+     * @see #isShowing()
+     */
+    public void setWidth(int width) {
+        mWidth = width;
+    }
+
+    /**
+     * <p>Indicate whether this popup window is showing on screen.</p>
+     *
+     * @return true if the popup is showing, false otherwise
+     */
+    public boolean isShowing() {
+        return mIsShowing;
+    }
+
+    /**
+     * <p>
+     * Display the content view in a popup window at the specified location. If the popup window
+     * cannot fit on screen, it will be clipped. See {@link android.view.WindowManager.LayoutParams}
+     * for more information on how gravity and the x and y parameters are related. Specifying
+     * a gravity of {@link android.view.Gravity#NO_GRAVITY} is similar to specifying
+     * <code>Gravity.LEFT | Gravity.TOP</code>.
+     * </p>
+     * 
+     * @param parent a parent view to get the {@link android.view.View#getWindowToken()} token from
+     * @param gravity the gravity which controls the placement of the popup window
+     * @param x the popup's x location offset
+     * @param y the popup's y location offset
+     */
+    public void showAtLocation(View parent, int gravity, int x, int y) {
+        showAtLocation(parent.getWindowToken(), gravity, x, y);
+    }
+
+    /**
+     * Display the content view in a popup window at the specified location.
+     *
+     * @param token Window token to use for creating the new window
+     * @param gravity the gravity which controls the placement of the popup window
+     * @param x the popup's x location offset
+     * @param y the popup's y location offset
+     *
+     * @hide Internal use only. Applications should use
+     *       {@link #showAtLocation(View, int, int, int)} instead.
+     */
+    public void showAtLocation(IBinder token, int gravity, int x, int y) {
+        if (isShowing() || mContentView == null) {
+            return;
+        }
+
+        unregisterForScrollChanged();
+
+        mIsShowing = true;
+        mIsDropdown = false;
+
+        WindowManager.LayoutParams p = createPopupLayout(token);
+        p.windowAnimations = computeAnimationResource();
+       
+        preparePopup(p);
+        if (gravity == Gravity.NO_GRAVITY) {
+            gravity = Gravity.TOP | Gravity.LEFT;
+        }
+        p.gravity = gravity;
+        p.x = x;
+        p.y = y;
+        if (mHeightMode < 0) p.height = mLastHeight = mHeightMode;
+        if (mWidthMode < 0) p.width = mLastWidth = mWidthMode;
+        invokePopup(p);
+    }
+
+    /**
+     * <p>Display the content view in a popup window anchored to the bottom-left
+     * corner of the anchor view. If there is not enough room on screen to show
+     * the popup in its entirety, this method tries to find a parent scroll
+     * view to scroll. If no parent scroll view can be scrolled, the bottom-left
+     * corner of the popup is pinned at the top left corner of the anchor view.</p>
+     *
+     * @param anchor the view on which to pin the popup window
+     *
+     * @see #dismiss()
+     */
+    public void showAsDropDown(View anchor) {
+        showAsDropDown(anchor, 0, 0);
+    }
+
+    /**
+     * <p>Display the content view in a popup window anchored to the bottom-left
+     * corner of the anchor view offset by the specified x and y coordinates.
+     * If there is not enough room on screen to show
+     * the popup in its entirety, this method tries to find a parent scroll
+     * view to scroll. If no parent scroll view can be scrolled, the bottom-left
+     * corner of the popup is pinned at the top left corner of the anchor view.</p>
+     * <p>If the view later scrolls to move <code>anchor</code> to a different
+     * location, the popup will be moved correspondingly.</p>
+     *
+     * @param anchor the view on which to pin the popup window
+     *
+     * @see #dismiss()
+     */
+    public void showAsDropDown(View anchor, int xoff, int yoff) {
+        if (isShowing() || mContentView == null) {
+            return;
+        }
+
+        registerForScrollChanged(anchor, xoff, yoff);
+
+        mIsShowing = true;
+        mIsDropdown = true;
+
+        WindowManager.LayoutParams p = createPopupLayout(anchor.getWindowToken());
+        preparePopup(p);
+
+        updateAboveAnchor(findDropDownPosition(anchor, p, xoff, yoff));
+
+        if (mHeightMode < 0) p.height = mLastHeight = mHeightMode;
+        if (mWidthMode < 0) p.width = mLastWidth = mWidthMode;
+
+        p.windowAnimations = computeAnimationResource();
+
+        invokePopup(p);
+    }
+
+    private void updateAboveAnchor(boolean aboveAnchor) {
+        if (aboveAnchor != mAboveAnchor) {
+            mAboveAnchor = aboveAnchor;
+
+            if (mBackground != null) {
+                // If the background drawable provided was a StateListDrawable with above-anchor
+                // and below-anchor states, use those. Otherwise rely on refreshDrawableState to
+                // do the job.
+                if (mAboveAnchorBackgroundDrawable != null) {
+                    if (mAboveAnchor) {
+                        mPopupView.setBackgroundDrawable(mAboveAnchorBackgroundDrawable);
+                    } else {
+                        mPopupView.setBackgroundDrawable(mBelowAnchorBackgroundDrawable);
+                    }
+                } else {
+                    mPopupView.refreshDrawableState();
+                }
+            }
+        }
+    }
+
+    /**
+     * Indicates whether the popup is showing above (the y coordinate of the popup's bottom
+     * is less than the y coordinate of the anchor) or below the anchor view (the y coordinate
+     * of the popup is greater than y coordinate of the anchor's bottom).
+     *
+     * The value returned
+     * by this method is meaningful only after {@link #showAsDropDown(android.view.View)}
+     * or {@link #showAsDropDown(android.view.View, int, int)} was invoked.
+     *
+     * @return True if this popup is showing above the anchor view, false otherwise.
+     */
+    public boolean isAboveAnchor() {
+        return mAboveAnchor;
+    }
+
+    /**
+     * <p>Prepare the popup by embedding in into a new ViewGroup if the
+     * background drawable is not null. If embedding is required, the layout
+     * parameters' height is mnodified to take into account the background's
+     * padding.</p>
+     *
+     * @param p the layout parameters of the popup's content view
+     */
+    private void preparePopup(WindowManager.LayoutParams p) {
+        if (mContentView == null || mContext == null || mWindowManager == null) {
+            throw new IllegalStateException("You must specify a valid content view by "
+                    + "calling setContentView() before attempting to show the popup.");
+        }
+
+        if (mBackground != null) {
+            final ViewGroup.LayoutParams layoutParams = mContentView.getLayoutParams();
+            int height = ViewGroup.LayoutParams.MATCH_PARENT;
+            if (layoutParams != null &&
+                    layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
+                height = ViewGroup.LayoutParams.WRAP_CONTENT;
+            }
+
+            // when a background is available, we embed the content view
+            // within another view that owns the background drawable
+            PopupViewContainer popupViewContainer = new PopupViewContainer(mContext);
+            PopupViewContainer.LayoutParams listParams = new PopupViewContainer.LayoutParams(
+                    ViewGroup.LayoutParams.MATCH_PARENT, height
+            );
+            popupViewContainer.setBackgroundDrawable(mBackground);
+            popupViewContainer.addView(mContentView, listParams);
+
+            mPopupView = popupViewContainer;
+        } else {
+            mPopupView = mContentView;
+        }
+        mPopupWidth = p.width;
+        mPopupHeight = p.height;
+    }
+
+    /**
+     * <p>Invoke the popup window by adding the content view to the window
+     * manager.</p>
+     *
+     * <p>The content view must be non-null when this method is invoked.</p>
+     *
+     * @param p the layout parameters of the popup's content view
+     */
+    private void invokePopup(WindowManager.LayoutParams p) {
+        if (mContext != null) {
+            p.packageName = mContext.getPackageName();
+        }
+        mPopupView.setFitsSystemWindows(mLayoutInsetDecor);
+        mWindowManager.addView(mPopupView, p);
+    }
+
+    /**
+     * <p>Generate the layout parameters for the popup window.</p>
+     *
+     * @param token the window token used to bind the popup's window
+     *
+     * @return the layout parameters to pass to the window manager
+     */
+    private WindowManager.LayoutParams createPopupLayout(IBinder token) {
+        // generates the layout parameters for the drop down
+        // we want a fixed size view located at the bottom left of the anchor
+        WindowManager.LayoutParams p = new WindowManager.LayoutParams();
+        // these gravity settings put the view at the top left corner of the
+        // screen. The view is then positioned to the appropriate location
+        // by setting the x and y offsets to match the anchor's bottom
+        // left corner
+        p.gravity = Gravity.LEFT | Gravity.TOP;
+        p.width = mLastWidth = mWidth;
+        p.height = mLastHeight = mHeight;
+        if (mBackground != null) {
+            p.format = mBackground.getOpacity();
+        } else {
+            p.format = PixelFormat.TRANSLUCENT;
+        }
+        p.flags = computeFlags(p.flags);
+        p.type = mWindowLayoutType;
+        p.token = token;
+        p.softInputMode = mSoftInputMode;
+        p.setTitle("PopupWindow:" + Integer.toHexString(hashCode()));
+
+        return p;
+    }
+
+    private int computeFlags(int curFlags) {
+        curFlags &= ~(
+                WindowManager.LayoutParams.FLAG_IGNORE_CHEEK_PRESSES |
+                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE |
+                WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE |
+                WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH |
+                WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS |
+                WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM |
+                WindowManager.LayoutParams.FLAG_SPLIT_TOUCH);
+        if(mIgnoreCheekPress) {
+            curFlags |= WindowManager.LayoutParams.FLAG_IGNORE_CHEEK_PRESSES;
+        }
+        if (!mFocusable) {
+            curFlags |= WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
+            if (mInputMethodMode == INPUT_METHOD_NEEDED) {
+                curFlags |= WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
+            }
+        } else if (mInputMethodMode == INPUT_METHOD_NOT_NEEDED) {
+            curFlags |= WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
+        }
+        if (!mTouchable) {
+            curFlags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
+        }
+        if (mOutsideTouchable) {
+            curFlags |= WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH;
+        }
+        if (!mClippingEnabled) {
+            curFlags |= WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS;
+        }
+        if (isSplitTouchEnabled()) {
+            curFlags |= WindowManager.LayoutParams.FLAG_SPLIT_TOUCH;
+        }
+        if (mLayoutInScreen) {
+            curFlags |= WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;
+        }
+        if (mLayoutInsetDecor) {
+            curFlags |= WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR;
+        }
+        if (mNotTouchModal) {
+            curFlags |= WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL;
+        }
+        return curFlags;
+    }
+    
+    private int computeAnimationResource() {
+        if (mAnimationStyle == -1) {
+            if (mIsDropdown) {
+                return mAboveAnchor
+                        ? com.android.internal.R.style.Animation_DropDownUp
+                        : com.android.internal.R.style.Animation_DropDownDown;
+            }
+            return 0;
+        }
+        return mAnimationStyle;
+    }
+    
+    /**
+     * <p>Positions the popup window on screen. When the popup window is too
+     * tall to fit under the anchor, a parent scroll view is seeked and scrolled
+     * up to reclaim space. If scrolling is not possible or not enough, the
+     * popup window gets moved on top of the anchor.</p>
+     *
+     * <p>The height must have been set on the layout parameters prior to
+     * calling this method.</p>
+     *
+     * @param anchor the view on which the popup window must be anchored
+     * @param p the layout parameters used to display the drop down
+     *
+     * @return true if the popup is translated upwards to fit on screen
+     */
+    private boolean findDropDownPosition(View anchor, WindowManager.LayoutParams p,
+            int xoff, int yoff) {
+
+        final int anchorHeight = anchor.getHeight();
+        anchor.getLocationInWindow(mDrawingLocation);
+        p.x = mDrawingLocation[0] + xoff;
+        p.y = mDrawingLocation[1] + anchorHeight + yoff;
+        
+        boolean onTop = false;
+
+        p.gravity = Gravity.LEFT | Gravity.TOP;
+        
+        anchor.getLocationOnScreen(mScreenLocation);
+        final Rect displayFrame = new Rect();
+        anchor.getWindowVisibleDisplayFrame(displayFrame);
+
+        int screenY = mScreenLocation[1] + anchorHeight + yoff;
+        
+        final View root = anchor.getRootView();
+        if (screenY + mPopupHeight > displayFrame.bottom ||
+                p.x + mPopupWidth - root.getWidth() > 0) {
+            // if the drop down disappears at the bottom of the screen. we try to
+            // scroll a parent scrollview or move the drop down back up on top of
+            // the edit box
+            if (mAllowScrollingAnchorParent) {
+                int scrollX = anchor.getScrollX();
+                int scrollY = anchor.getScrollY();
+                Rect r = new Rect(scrollX, scrollY,  scrollX + mPopupWidth + xoff,
+                        scrollY + mPopupHeight + anchor.getHeight() + yoff);
+                anchor.requestRectangleOnScreen(r, true);
+            }
+
+            // now we re-evaluate the space available, and decide from that
+            // whether the pop-up will go above or below the anchor.
+            anchor.getLocationInWindow(mDrawingLocation);
+            p.x = mDrawingLocation[0] + xoff;
+            p.y = mDrawingLocation[1] + anchor.getHeight() + yoff;
+            
+            // determine whether there is more space above or below the anchor
+            anchor.getLocationOnScreen(mScreenLocation);
+            
+            onTop = (displayFrame.bottom - mScreenLocation[1] - anchor.getHeight() - yoff) <
+                    (mScreenLocation[1] - yoff - displayFrame.top);
+            if (onTop) {
+                p.gravity = Gravity.LEFT | Gravity.BOTTOM;
+                p.y = root.getHeight() - mDrawingLocation[1] + yoff;
+            } else {
+                p.y = mDrawingLocation[1] + anchor.getHeight() + yoff;
+            }
+        }
+
+        if (mClipToScreen) {
+            final int displayFrameWidth = displayFrame.right - displayFrame.left;
+
+            int right = p.x + p.width;
+            if (right > displayFrameWidth) {
+                p.x -= right - displayFrameWidth;
+            }
+            if (p.x < displayFrame.left) {
+                p.x = displayFrame.left;
+                p.width = Math.min(p.width, displayFrameWidth);
+            }
+
+            if (onTop) {
+                int popupTop = mScreenLocation[1] + yoff - mPopupHeight;
+                if (popupTop < 0) {
+                    p.y += popupTop;
+                }
+            } else {
+                p.y = Math.max(p.y, displayFrame.top);
+            }
+        }
+
+        p.gravity |= Gravity.DISPLAY_CLIP_VERTICAL;
+        
+        return onTop;
+    }
+    
+    /**
+     * Returns the maximum height that is available for the popup to be
+     * completely shown. It is recommended that this height be the maximum for
+     * the popup's height, otherwise it is possible that the popup will be
+     * clipped.
+     * 
+     * @param anchor The view on which the popup window must be anchored.
+     * @return The maximum available height for the popup to be completely
+     *         shown.
+     */
+    public int getMaxAvailableHeight(View anchor) {
+        return getMaxAvailableHeight(anchor, 0);
+    }
+
+    /**
+     * Returns the maximum height that is available for the popup to be
+     * completely shown. It is recommended that this height be the maximum for
+     * the popup's height, otherwise it is possible that the popup will be
+     * clipped.
+     *
+     * @param anchor The view on which the popup window must be anchored.
+     * @param yOffset y offset from the view's bottom edge
+     * @return The maximum available height for the popup to be completely
+     *         shown.
+     */
+    public int getMaxAvailableHeight(View anchor, int yOffset) {
+        return getMaxAvailableHeight(anchor, yOffset, false);
+    }
+    
+    /**
+     * Returns the maximum height that is available for the popup to be
+     * completely shown, optionally ignoring any bottom decorations such as
+     * the input method. It is recommended that this height be the maximum for
+     * the popup's height, otherwise it is possible that the popup will be
+     * clipped.
+     * 
+     * @param anchor The view on which the popup window must be anchored.
+     * @param yOffset y offset from the view's bottom edge
+     * @param ignoreBottomDecorations if true, the height returned will be
+     *        all the way to the bottom of the display, ignoring any
+     *        bottom decorations
+     * @return The maximum available height for the popup to be completely
+     *         shown.
+     *         
+     * @hide Pending API council approval.
+     */
+    public int getMaxAvailableHeight(View anchor, int yOffset, boolean ignoreBottomDecorations) {
+        final Rect displayFrame = new Rect();
+        anchor.getWindowVisibleDisplayFrame(displayFrame);
+
+        final int[] anchorPos = mDrawingLocation;
+        anchor.getLocationOnScreen(anchorPos);
+        
+        int bottomEdge = displayFrame.bottom;
+        if (ignoreBottomDecorations) {
+            Resources res = anchor.getContext().getResources();
+            bottomEdge = res.getDisplayMetrics().heightPixels;
+        }
+        final int distanceToBottom = bottomEdge - (anchorPos[1] + anchor.getHeight()) - yOffset;
+        final int distanceToTop = anchorPos[1] - displayFrame.top + yOffset;
+
+        // anchorPos[1] is distance from anchor to top of screen
+        int returnedHeight = Math.max(distanceToBottom, distanceToTop);
+        if (mBackground != null) {
+            mBackground.getPadding(mTempRect);
+            returnedHeight -= mTempRect.top + mTempRect.bottom; 
+        }
+        
+        return returnedHeight;
+    }
+    
+    /**
+     * <p>Dispose of the popup window. This method can be invoked only after
+     * {@link #showAsDropDown(android.view.View)} has been executed. Failing that, calling
+     * this method will have no effect.</p>
+     *
+     * @see #showAsDropDown(android.view.View) 
+     */
+    public void dismiss() {
+        if (isShowing() && mPopupView != null) {
+            mIsShowing = false;
+
+            unregisterForScrollChanged();
+
+            try {
+                mWindowManager.removeViewImmediate(mPopupView);
+            } finally {
+                if (mPopupView != mContentView && mPopupView instanceof ViewGroup) {
+                    ((ViewGroup) mPopupView).removeView(mContentView);
+                }
+                mPopupView = null;
+
+                if (mOnDismissListener != null) {
+                    mOnDismissListener.onDismiss();
+                }
+            }
+        }
+    }
+
+    /**
+     * Sets the listener to be called when the window is dismissed.
+     * 
+     * @param onDismissListener The listener.
+     */
+    public void setOnDismissListener(OnDismissListener onDismissListener) {
+        mOnDismissListener = onDismissListener;
+    }
+    
+    /**
+     * Updates the state of the popup window, if it is currently being displayed,
+     * from the currently set state.  This include:
+     * {@link #setClippingEnabled(boolean)}, {@link #setFocusable(boolean)},
+     * {@link #setIgnoreCheekPress()}, {@link #setInputMethodMode(int)},
+     * {@link #setTouchable(boolean)}, and {@link #setAnimationStyle(int)}.
+     */
+    public void update() {
+        if (!isShowing() || mContentView == null) {
+            return;
+        }
+        
+        WindowManager.LayoutParams p = (WindowManager.LayoutParams)
+                mPopupView.getLayoutParams();
+        
+        boolean update = false;
+        
+        final int newAnim = computeAnimationResource();
+        if (newAnim != p.windowAnimations) {
+            p.windowAnimations = newAnim;
+            update = true;
+        }
+
+        final int newFlags = computeFlags(p.flags);
+        if (newFlags != p.flags) {
+            p.flags = newFlags;
+            update = true;
+        }
+        
+        if (update) {
+            mWindowManager.updateViewLayout(mPopupView, p);
+        }
+    }
+
+    /**
+     * <p>Updates the dimension of the popup window. Calling this function
+     * also updates the window with the current popup state as described
+     * for {@link #update()}.</p>
+     *
+     * @param width the new width
+     * @param height the new height
+     */
+    public void update(int width, int height) {
+        WindowManager.LayoutParams p = (WindowManager.LayoutParams)
+                mPopupView.getLayoutParams();
+        update(p.x, p.y, width, height, false);
+    }
+    
+    /**
+     * <p>Updates the position and the dimension of the popup window. Width and
+     * height can be set to -1 to update location only.  Calling this function
+     * also updates the window with the current popup state as
+     * described for {@link #update()}.</p>
+     *
+     * @param x the new x location
+     * @param y the new y location
+     * @param width the new width, can be -1 to ignore
+     * @param height the new height, can be -1 to ignore
+     */
+    public void update(int x, int y, int width, int height) {
+        update(x, y, width, height, false);
+    }
+
+    /**
+     * <p>Updates the position and the dimension of the popup window. Width and
+     * height can be set to -1 to update location only.  Calling this function
+     * also updates the window with the current popup state as
+     * described for {@link #update()}.</p>
+     *
+     * @param x the new x location
+     * @param y the new y location
+     * @param width the new width, can be -1 to ignore
+     * @param height the new height, can be -1 to ignore
+     * @param force reposition the window even if the specified position
+     *              already seems to correspond to the LayoutParams
+     */
+    public void update(int x, int y, int width, int height, boolean force) {
+        if (width != -1) {
+            mLastWidth = width;
+            setWidth(width);
+        }
+
+        if (height != -1) {
+            mLastHeight = height;
+            setHeight(height);
+        }
+
+        if (!isShowing() || mContentView == null) {
+            return;
+        }
+
+        WindowManager.LayoutParams p = (WindowManager.LayoutParams) mPopupView.getLayoutParams();
+
+        boolean update = force;
+
+        final int finalWidth = mWidthMode < 0 ? mWidthMode : mLastWidth;
+        if (width != -1 && p.width != finalWidth) {
+            p.width = mLastWidth = finalWidth;
+            update = true;
+        }
+
+        final int finalHeight = mHeightMode < 0 ? mHeightMode : mLastHeight;
+        if (height != -1 && p.height != finalHeight) {
+            p.height = mLastHeight = finalHeight;
+            update = true;
+        }
+
+        if (p.x != x) {
+            p.x = x;
+            update = true;
+        }
+
+        if (p.y != y) {
+            p.y = y;
+            update = true;
+        }
+
+        final int newAnim = computeAnimationResource();
+        if (newAnim != p.windowAnimations) {
+            p.windowAnimations = newAnim;
+            update = true;
+        }
+
+        final int newFlags = computeFlags(p.flags);
+        if (newFlags != p.flags) {
+            p.flags = newFlags;
+            update = true;
+        }
+
+        if (update) {
+            mWindowManager.updateViewLayout(mPopupView, p);
+        }
+    }
+
+    /**
+     * <p>Updates the position and the dimension of the popup window. Calling this
+     * function also updates the window with the current popup state as described
+     * for {@link #update()}.</p>
+     *
+     * @param anchor the popup's anchor view
+     * @param width the new width, can be -1 to ignore
+     * @param height the new height, can be -1 to ignore
+     */
+    public void update(View anchor, int width, int height) {
+        update(anchor, false, 0, 0, true, width, height);
+    }
+
+    /**
+     * <p>Updates the position and the dimension of the popup window. Width and
+     * height can be set to -1 to update location only.  Calling this function
+     * also updates the window with the current popup state as
+     * described for {@link #update()}.</p>
+     *
+     * <p>If the view later scrolls to move <code>anchor</code> to a different
+     * location, the popup will be moved correspondingly.</p>
+     *
+     * @param anchor the popup's anchor view
+     * @param xoff x offset from the view's left edge
+     * @param yoff y offset from the view's bottom edge
+     * @param width the new width, can be -1 to ignore
+     * @param height the new height, can be -1 to ignore
+     */
+    public void update(View anchor, int xoff, int yoff, int width, int height) {
+        update(anchor, true, xoff, yoff, true, width, height);
+    }
+
+    private void update(View anchor, boolean updateLocation, int xoff, int yoff,
+            boolean updateDimension, int width, int height) {
+
+        if (!isShowing() || mContentView == null) {
+            return;
+        }
+
+        WeakReference<View> oldAnchor = mAnchor;
+        final boolean needsUpdate = updateLocation && (mAnchorXoff != xoff || mAnchorYoff != yoff);
+        if (oldAnchor == null || oldAnchor.get() != anchor || (needsUpdate && !mIsDropdown)) {
+            registerForScrollChanged(anchor, xoff, yoff);
+        } else if (needsUpdate) {
+            // No need to register again if this is a DropDown, showAsDropDown already did.
+            mAnchorXoff = xoff;
+            mAnchorYoff = yoff;
+        }
+
+        WindowManager.LayoutParams p = (WindowManager.LayoutParams) mPopupView.getLayoutParams();
+
+        if (updateDimension) {
+            if (width == -1) {
+                width = mPopupWidth;
+            } else {
+                mPopupWidth = width;
+            }
+            if (height == -1) {
+                height = mPopupHeight;
+            } else {
+                mPopupHeight = height;
+            }
+        }
+
+        int x = p.x;
+        int y = p.y;
+
+        if (updateLocation) {
+            updateAboveAnchor(findDropDownPosition(anchor, p, xoff, yoff));
+        } else {
+            updateAboveAnchor(findDropDownPosition(anchor, p, mAnchorXoff, mAnchorYoff));            
+        }
+        
+        update(p.x, p.y, width, height, x != p.x || y != p.y);
+    }
+
+    /**
+     * Listener that is called when this popup window is dismissed.
+     */
+    public interface OnDismissListener {
+        /**
+         * Called when this popup window is dismissed.
+         */
+        public void onDismiss();
+    }
+
+    private void unregisterForScrollChanged() {
+        WeakReference<View> anchorRef = mAnchor;
+        View anchor = null;
+        if (anchorRef != null) {
+            anchor = anchorRef.get();
+        }
+        if (anchor != null) {
+            ViewTreeObserver vto = anchor.getViewTreeObserver();
+            vto.removeOnScrollChangedListener(mOnScrollChangedListener);
+        }
+        mAnchor = null;
+    }
+
+    private void registerForScrollChanged(View anchor, int xoff, int yoff) {
+        unregisterForScrollChanged();
+
+        mAnchor = new WeakReference<View>(anchor);
+        ViewTreeObserver vto = anchor.getViewTreeObserver();
+        if (vto != null) {
+            vto.addOnScrollChangedListener(mOnScrollChangedListener);
+        }
+
+        mAnchorXoff = xoff;
+        mAnchorYoff = yoff;
+    }
+
+    private class PopupViewContainer extends FrameLayout {
+        private static final String TAG = "PopupWindow.PopupViewContainer";
+
+        public PopupViewContainer(Context context) {
+            super(context);
+        }
+
+        @Override
+        protected int[] onCreateDrawableState(int extraSpace) {
+            if (mAboveAnchor) {
+                // 1 more needed for the above anchor state
+                final int[] drawableState = super.onCreateDrawableState(extraSpace + 1);
+                View.mergeDrawableStates(drawableState, ABOVE_ANCHOR_STATE_SET);
+                return drawableState;
+            } else {
+                return super.onCreateDrawableState(extraSpace);
+            }
+        }
+
+        @Override
+        public boolean dispatchKeyEvent(KeyEvent event) {
+            if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
+                if (getKeyDispatcherState() == null) {
+                    return super.dispatchKeyEvent(event);
+                }
+
+                if (event.getAction() == KeyEvent.ACTION_DOWN
+                        && event.getRepeatCount() == 0) {
+                    KeyEvent.DispatcherState state = getKeyDispatcherState();
+                    if (state != null) {
+                        state.startTracking(event, this);
+                    }
+                    return true;
+                } else if (event.getAction() == KeyEvent.ACTION_UP) {
+                    KeyEvent.DispatcherState state = getKeyDispatcherState();
+                    if (state != null && state.isTracking(event) && !event.isCanceled()) {
+                        dismiss();
+                        return true;
+                    }
+                }
+                return super.dispatchKeyEvent(event);
+            } else {
+                return super.dispatchKeyEvent(event);
+            }
+        }
+
+        @Override
+        public boolean dispatchTouchEvent(MotionEvent ev) {
+            if (mTouchInterceptor != null && mTouchInterceptor.onTouch(this, ev)) {
+                return true;
+            }
+            return super.dispatchTouchEvent(ev);
+        }
+
+        @Override
+        public boolean onTouchEvent(MotionEvent event) {
+            final int x = (int) event.getX();
+            final int y = (int) event.getY();
+            
+            if ((event.getAction() == MotionEvent.ACTION_DOWN)
+                    && ((x < 0) || (x >= getWidth()) || (y < 0) || (y >= getHeight()))) {
+                dismiss();
+                return true;
+            } else if (event.getAction() == MotionEvent.ACTION_OUTSIDE) {
+                dismiss();
+                return true;
+            } else {
+                return super.onTouchEvent(event);
+            }
+        }
+
+        @Override
+        public void sendAccessibilityEvent(int eventType) {
+            // clinets are interested in the content not the container, make it event source
+            if (mContentView != null) {
+                mContentView.sendAccessibilityEvent(eventType);
+            } else {
+                super.sendAccessibilityEvent(eventType);
+            }
+        }
+    }
+    
+}
diff --git a/src/frameworks/base/core/java/android/widget/ProgressBar.java b/src/frameworks/base/core/java/android/widget/ProgressBar.java
new file mode 100644
index 0000000..f3f18d5
--- /dev/null
+++ b/src/frameworks/base/core/java/android/widget/ProgressBar.java
@@ -0,0 +1,1235 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.widget;
+
+import com.android.internal.R;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.Bitmap;
+import android.graphics.BitmapShader;
+import android.graphics.Canvas;
+import android.graphics.Rect;
+import android.graphics.Shader;
+import android.graphics.drawable.Animatable;
+import android.graphics.drawable.AnimationDrawable;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.ClipDrawable;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.LayerDrawable;
+import android.graphics.drawable.ShapeDrawable;
+import android.graphics.drawable.StateListDrawable;
+import android.graphics.drawable.shapes.RoundRectShape;
+import android.graphics.drawable.shapes.Shape;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.AttributeSet;
+import android.util.Pool;
+import android.util.Poolable;
+import android.util.PoolableManager;
+import android.util.Pools;
+import android.view.Gravity;
+import android.view.RemotableViewMethod;
+import android.view.View;
+import android.view.ViewDebug;
+import android.view.accessibility.AccessibilityEvent;
+import android.view.accessibility.AccessibilityManager;
+import android.view.accessibility.AccessibilityNodeInfo;
+import android.view.animation.AlphaAnimation;
+import android.view.animation.Animation;
+import android.view.animation.AnimationUtils;
+import android.view.animation.Interpolator;
+import android.view.animation.LinearInterpolator;
+import android.view.animation.Transformation;
+import android.widget.RemoteViews.RemoteView;
+
+import java.util.ArrayList;
+
+
+/**
+ * <p>
+ * Visual indicator of progress in some operation.  Displays a bar to the user
+ * representing how far the operation has progressed; the application can 
+ * change the amount of progress (modifying the length of the bar) as it moves 
+ * forward.  There is also a secondary progress displayable on a progress bar
+ * which is useful for displaying intermediate progress, such as the buffer
+ * level during a streaming playback progress bar.
+ * </p>
+ *
+ * <p>
+ * A progress bar can also be made indeterminate. In indeterminate mode, the
+ * progress bar shows a cyclic animation without an indication of progress. This mode is used by
+ * applications when the length of the task is unknown. The indeterminate progress bar can be either
+ * a spinning wheel or a horizontal bar.
+ * </p>
+ *
+ * <p>The following code example shows how a progress bar can be used from
+ * a worker thread to update the user interface to notify the user of progress:
+ * </p>
+ * 
+ * <pre>
+ * public class MyActivity extends Activity {
+ *     private static final int PROGRESS = 0x1;
+ *
+ *     private ProgressBar mProgress;
+ *     private int mProgressStatus = 0;
+ *
+ *     private Handler mHandler = new Handler();
+ *
+ *     protected void onCreate(Bundle icicle) {
+ *         super.onCreate(icicle);
+ *
+ *         setContentView(R.layout.progressbar_activity);
+ *
+ *         mProgress = (ProgressBar) findViewById(R.id.progress_bar);
+ *
+ *         // Start lengthy operation in a background thread
+ *         new Thread(new Runnable() {
+ *             public void run() {
+ *                 while (mProgressStatus &lt; 100) {
+ *                     mProgressStatus = doWork();
+ *
+ *                     // Update the progress bar
+ *                     mHandler.post(new Runnable() {
+ *                         public void run() {
+ *                             mProgress.setProgress(mProgressStatus);
+ *                         }
+ *                     });
+ *                 }
+ *             }
+ *         }).start();
+ *     }
+ * }</pre>
+ *
+ * <p>To add a progress bar to a layout file, you can use the {@code &lt;ProgressBar&gt;} element.
+ * By default, the progress bar is a spinning wheel (an indeterminate indicator). To change to a
+ * horizontal progress bar, apply the {@link android.R.style#Widget_ProgressBar_Horizontal
+ * Widget.ProgressBar.Horizontal} style, like so:</p>
+ *
+ * <pre>
+ * &lt;ProgressBar
+ *     style="@android:style/Widget.ProgressBar.Horizontal"
+ *     ... /&gt;</pre>
+ *
+ * <p>If you will use the progress bar to show real progress, you must use the horizontal bar. You
+ * can then increment the  progress with {@link #incrementProgressBy incrementProgressBy()} or
+ * {@link #setProgress setProgress()}. By default, the progress bar is full when it reaches 100. If
+ * necessary, you can adjust the maximum value (the value for a full bar) using the {@link
+ * android.R.styleable#ProgressBar_max android:max} attribute. Other attributes available are listed
+ * below.</p>
+ *
+ * <p>Another common style to apply to the progress bar is {@link
+ * android.R.style#Widget_ProgressBar_Small Widget.ProgressBar.Small}, which shows a smaller
+ * version of the spinning wheel&mdash;useful when waiting for content to load.
+ * For example, you can insert this kind of progress bar into your default layout for
+ * a view that will be populated by some content fetched from the Internet&mdash;the spinning wheel
+ * appears immediately and when your application receives the content, it replaces the progress bar
+ * with the loaded content. For example:</p>
+ *
+ * <pre>
+ * &lt;LinearLayout
+ *     android:orientation="horizontal"
+ *     ... &gt;
+ *     &lt;ProgressBar
+ *         android:layout_width="wrap_content"
+ *         android:layout_height="wrap_content"
+ *         style="@android:style/Widget.ProgressBar.Small"
+ *         android:layout_marginRight="5dp" /&gt;
+ *     &lt;TextView
+ *         android:layout_width="wrap_content"
+ *         android:layout_height="wrap_content"
+ *         android:text="@string/loading" /&gt;
+ * &lt;/LinearLayout&gt;</pre>
+ *
+ * <p>Other progress bar styles provided by the system include:</p>
+ * <ul>
+ * <li>{@link android.R.style#Widget_ProgressBar_Horizontal Widget.ProgressBar.Horizontal}</li>
+ * <li>{@link android.R.style#Widget_ProgressBar_Small Widget.ProgressBar.Small}</li>
+ * <li>{@link android.R.style#Widget_ProgressBar_Large Widget.ProgressBar.Large}</li>
+ * <li>{@link android.R.style#Widget_ProgressBar_Inverse Widget.ProgressBar.Inverse}</li>
+ * <li>{@link android.R.style#Widget_ProgressBar_Small_Inverse
+ * Widget.ProgressBar.Small.Inverse}</li>
+ * <li>{@link android.R.style#Widget_ProgressBar_Large_Inverse
+ * Widget.ProgressBar.Large.Inverse}</li>
+ * </ul>
+ * <p>The "inverse" styles provide an inverse color scheme for the spinner, which may be necessary
+ * if your application uses a light colored theme (a white background).</p>
+ *  
+ * <p><strong>XML attributes</b></strong> 
+ * <p> 
+ * See {@link android.R.styleable#ProgressBar ProgressBar Attributes}, 
+ * {@link android.R.styleable#View View Attributes}
+ * </p>
+ * 
+ * @attr ref android.R.styleable#ProgressBar_animationResolution
+ * @attr ref android.R.styleable#ProgressBar_indeterminate
+ * @attr ref android.R.styleable#ProgressBar_indeterminateBehavior
+ * @attr ref android.R.styleable#ProgressBar_indeterminateDrawable
+ * @attr ref android.R.styleable#ProgressBar_indeterminateDuration
+ * @attr ref android.R.styleable#ProgressBar_indeterminateOnly
+ * @attr ref android.R.styleable#ProgressBar_interpolator
+ * @attr ref android.R.styleable#ProgressBar_max
+ * @attr ref android.R.styleable#ProgressBar_maxHeight
+ * @attr ref android.R.styleable#ProgressBar_maxWidth
+ * @attr ref android.R.styleable#ProgressBar_minHeight
+ * @attr ref android.R.styleable#ProgressBar_minWidth
+ * @attr ref android.R.styleable#ProgressBar_progress
+ * @attr ref android.R.styleable#ProgressBar_progressDrawable
+ * @attr ref android.R.styleable#ProgressBar_secondaryProgress
+ */
+@RemoteView
+public class ProgressBar extends View {
+    private static final int MAX_LEVEL = 10000;
+    private static final int TIMEOUT_SEND_ACCESSIBILITY_EVENT = 200;
+
+    int mMinWidth;
+    int mMaxWidth;
+    int mMinHeight;
+    int mMaxHeight;
+
+    private int mProgress;
+    private int mSecondaryProgress;
+    private int mMax;
+
+    private int mBehavior;
+    private int mDuration;
+    private boolean mIndeterminate;
+    private boolean mOnlyIndeterminate;
+    private Transformation mTransformation;
+    private AlphaAnimation mAnimation;
+    private boolean mHasAnimation;
+    private Drawable mIndeterminateDrawable;
+    private Drawable mProgressDrawable;
+    private Drawable mCurrentDrawable;
+    Bitmap mSampleTile;
+    private boolean mNoInvalidate;
+    private Interpolator mInterpolator;
+    private RefreshProgressRunnable mRefreshProgressRunnable;
+    private long mUiThreadId;
+    private boolean mShouldStartAnimationDrawable;
+
+    private boolean mInDrawing;
+    private boolean mAttached;
+    private boolean mRefreshIsPosted;
+
+    private final ArrayList<RefreshData> mRefreshData = new ArrayList<RefreshData>();
+
+    private AccessibilityEventSender mAccessibilityEventSender;
+
+    /**
+     * Create a new progress bar with range 0...100 and initial progress of 0.
+     * @param context the application environment
+     */
+    public ProgressBar(Context context) {
+        this(context, null);
+    }
+    
+    public ProgressBar(Context context, AttributeSet attrs) {
+        this(context, attrs, com.android.internal.R.attr.progressBarStyle);
+    }
+
+    public ProgressBar(Context context, AttributeSet attrs, int defStyle) {
+        this(context, attrs, defStyle, 0);
+    }
+
+    /**
+     * @hide
+     */
+    public ProgressBar(Context context, AttributeSet attrs, int defStyle, int styleRes) {
+        super(context, attrs, defStyle);
+        mUiThreadId = Thread.currentThread().getId();
+        initProgressBar();
+
+        TypedArray a =
+            context.obtainStyledAttributes(attrs, R.styleable.ProgressBar, defStyle, styleRes);
+        
+        mNoInvalidate = true;
+        
+        Drawable drawable = a.getDrawable(R.styleable.ProgressBar_progressDrawable);
+        if (drawable != null) {
+            drawable = tileify(drawable, false);
+            // Calling this method can set mMaxHeight, make sure the corresponding
+            // XML attribute for mMaxHeight is read after calling this method
+            setProgressDrawable(drawable);
+        }
+
+
+        mDuration = a.getInt(R.styleable.ProgressBar_indeterminateDuration, mDuration);
+
+        mMinWidth = a.getDimensionPixelSize(R.styleable.ProgressBar_minWidth, mMinWidth);
+        mMaxWidth = a.getDimensionPixelSize(R.styleable.ProgressBar_maxWidth, mMaxWidth);
+        mMinHeight = a.getDimensionPixelSize(R.styleable.ProgressBar_minHeight, mMinHeight);
+        mMaxHeight = a.getDimensionPixelSize(R.styleable.ProgressBar_maxHeight, mMaxHeight);
+
+        mBehavior = a.getInt(R.styleable.ProgressBar_indeterminateBehavior, mBehavior);
+
+        final int resID = a.getResourceId(
+                com.android.internal.R.styleable.ProgressBar_interpolator, 
+                android.R.anim.linear_interpolator); // default to linear interpolator
+        if (resID > 0) {
+            setInterpolator(context, resID);
+        } 
+
+        setMax(a.getInt(R.styleable.ProgressBar_max, mMax));
+
+        setProgress(a.getInt(R.styleable.ProgressBar_progress, mProgress));
+
+        setSecondaryProgress(
+                a.getInt(R.styleable.ProgressBar_secondaryProgress, mSecondaryProgress));
+
+        drawable = a.getDrawable(R.styleable.ProgressBar_indeterminateDrawable);
+        if (drawable != null) {
+            drawable = tileifyIndeterminate(drawable);
+            setIndeterminateDrawable(drawable);
+        }
+
+        mOnlyIndeterminate = a.getBoolean(
+                R.styleable.ProgressBar_indeterminateOnly, mOnlyIndeterminate);
+
+        mNoInvalidate = false;
+
+        setIndeterminate(mOnlyIndeterminate || a.getBoolean(
+                R.styleable.ProgressBar_indeterminate, mIndeterminate));
+
+        a.recycle();
+    }
+
+    /**
+     * Converts a drawable to a tiled version of itself. It will recursively
+     * traverse layer and state list drawables.
+     */
+    private Drawable tileify(Drawable drawable, boolean clip) {
+        
+        if (drawable instanceof LayerDrawable) {
+            LayerDrawable background = (LayerDrawable) drawable;
+            final int N = background.getNumberOfLayers();
+            Drawable[] outDrawables = new Drawable[N];
+            
+            for (int i = 0; i < N; i++) {
+                int id = background.getId(i);
+                outDrawables[i] = tileify(background.getDrawable(i),
+                        (id == R.id.progress || id == R.id.secondaryProgress));
+            }
+
+            LayerDrawable newBg = new LayerDrawable(outDrawables);
+            
+            for (int i = 0; i < N; i++) {
+                newBg.setId(i, background.getId(i));
+            }
+            
+            return newBg;
+            
+        } else if (drawable instanceof StateListDrawable) {
+            StateListDrawable in = (StateListDrawable) drawable;
+            StateListDrawable out = new StateListDrawable();
+            int numStates = in.getStateCount();
+            for (int i = 0; i < numStates; i++) {
+                out.addState(in.getStateSet(i), tileify(in.getStateDrawable(i), clip));
+            }
+            return out;
+            
+        } else if (drawable instanceof BitmapDrawable) {
+            final Bitmap tileBitmap = ((BitmapDrawable) drawable).getBitmap();
+            if (mSampleTile == null) {
+                mSampleTile = tileBitmap;
+            }
+            
+            final ShapeDrawable shapeDrawable = new ShapeDrawable(getDrawableShape());
+
+            final BitmapShader bitmapShader = new BitmapShader(tileBitmap,
+                    Shader.TileMode.REPEAT, Shader.TileMode.CLAMP);
+            shapeDrawable.getPaint().setShader(bitmapShader);
+
+            return (clip) ? new ClipDrawable(shapeDrawable, Gravity.LEFT,
+                    ClipDrawable.HORIZONTAL) : shapeDrawable;
+        }
+        
+        return drawable;
+    }
+
+    Shape getDrawableShape() {
+        final float[] roundedCorners = new float[] { 5, 5, 5, 5, 5, 5, 5, 5 };
+        return new RoundRectShape(roundedCorners, null, null);
+    }
+    
+    /**
+     * Convert a AnimationDrawable for use as a barberpole animation.
+     * Each frame of the animation is wrapped in a ClipDrawable and
+     * given a tiling BitmapShader.
+     */
+    private Drawable tileifyIndeterminate(Drawable drawable) {
+        if (drawable instanceof AnimationDrawable) {
+            AnimationDrawable background = (AnimationDrawable) drawable;
+            final int N = background.getNumberOfFrames();
+            AnimationDrawable newBg = new AnimationDrawable();
+            newBg.setOneShot(background.isOneShot());
+            
+            for (int i = 0; i < N; i++) {
+                Drawable frame = tileify(background.getFrame(i), true);
+                frame.setLevel(10000);
+                newBg.addFrame(frame, background.getDuration(i));
+            }
+            newBg.setLevel(10000);
+            drawable = newBg;
+        }
+        return drawable;
+    }
+    
+    /**
+     * <p>
+     * Initialize the progress bar's default values:
+     * </p>
+     * <ul>
+     * <li>progress = 0</li>
+     * <li>max = 100</li>
+     * <li>animation duration = 4000 ms</li>
+     * <li>indeterminate = false</li>
+     * <li>behavior = repeat</li>
+     * </ul>
+     */
+    private void initProgressBar() {
+        mMax = 100;
+        mProgress = 0;
+        mSecondaryProgress = 0;
+        mIndeterminate = false;
+        mOnlyIndeterminate = false;
+        mDuration = 4000;
+        mBehavior = AlphaAnimation.RESTART;
+        mMinWidth = 24;
+        mMaxWidth = 48;
+        mMinHeight = 24;
+        mMaxHeight = 48;
+    }
+
+    /**
+     * <p>Indicate whether this progress bar is in indeterminate mode.</p>
+     *
+     * @return true if the progress bar is in indeterminate mode
+     */
+    @ViewDebug.ExportedProperty(category = "progress")
+    public synchronized boolean isIndeterminate() {
+        return mIndeterminate;
+    }
+
+    /**
+     * <p>Change the indeterminate mode for this progress bar. In indeterminate
+     * mode, the progress is ignored and the progress bar shows an infinite
+     * animation instead.</p>
+     * 
+     * If this progress bar's style only supports indeterminate mode (such as the circular
+     * progress bars), then this will be ignored.
+     *
+     * @param indeterminate true to enable the indeterminate mode
+     */
+    @android.view.RemotableViewMethod
+    public synchronized void setIndeterminate(boolean indeterminate) {
+        if ((!mOnlyIndeterminate || !mIndeterminate) && indeterminate != mIndeterminate) {
+            mIndeterminate = indeterminate;
+
+            if (indeterminate) {
+                // swap between indeterminate and regular backgrounds
+                mCurrentDrawable = mIndeterminateDrawable;
+                startAnimation();
+            } else {
+                mCurrentDrawable = mProgressDrawable;
+                stopAnimation();
+            }
+        }
+    }
+
+    /**
+     * <p>Get the drawable used to draw the progress bar in
+     * indeterminate mode.</p>
+     *
+     * @return a {@link android.graphics.drawable.Drawable} instance
+     *
+     * @see #setIndeterminateDrawable(android.graphics.drawable.Drawable)
+     * @see #setIndeterminate(boolean)
+     */
+    public Drawable getIndeterminateDrawable() {
+        return mIndeterminateDrawable;
+    }
+
+    /**
+     * <p>Define the drawable used to draw the progress bar in
+     * indeterminate mode.</p>
+     *
+     * @param d the new drawable
+     *
+     * @see #getIndeterminateDrawable()
+     * @see #setIndeterminate(boolean)
+     */
+    public void setIndeterminateDrawable(Drawable d) {
+        if (d != null) {
+            d.setCallback(this);
+        }
+        mIndeterminateDrawable = d;
+        if (mIndeterminate) {
+            mCurrentDrawable = d;
+            postInvalidate();
+        }
+    }
+    
+    /**
+     * <p>Get the drawable used to draw the progress bar in
+     * progress mode.</p>
+     *
+     * @return a {@link android.graphics.drawable.Drawable} instance
+     *
+     * @see #setProgressDrawable(android.graphics.drawable.Drawable)
+     * @see #setIndeterminate(boolean)
+     */
+    public Drawable getProgressDrawable() {
+        return mProgressDrawable;
+    }
+
+    /**
+     * <p>Define the drawable used to draw the progress bar in
+     * progress mode.</p>
+     *
+     * @param d the new drawable
+     *
+     * @see #getProgressDrawable()
+     * @see #setIndeterminate(boolean)
+     */
+    public void setProgressDrawable(Drawable d) {
+        boolean needUpdate;
+        if (mProgressDrawable != null && d != mProgressDrawable) {
+            mProgressDrawable.setCallback(null);
+            needUpdate = true;
+        } else {
+            needUpdate = false;
+        }
+
+        if (d != null) {
+            d.setCallback(this);
+
+            // Make sure the ProgressBar is always tall enough
+            int drawableHeight = d.getMinimumHeight();
+            if (mMaxHeight < drawableHeight) {
+                mMaxHeight = drawableHeight;
+                requestLayout();
+            }
+        }
+        mProgressDrawable = d;
+        if (!mIndeterminate) {
+            mCurrentDrawable = d;
+            postInvalidate();
+        }
+
+        if (needUpdate) {
+            updateDrawableBounds(getWidth(), getHeight());
+            updateDrawableState();
+            doRefreshProgress(R.id.progress, mProgress, false, false);
+            doRefreshProgress(R.id.secondaryProgress, mSecondaryProgress, false, false);
+        }
+    }
+    
+    /**
+     * @return The drawable currently used to draw the progress bar
+     */
+    Drawable getCurrentDrawable() {
+        return mCurrentDrawable;
+    }
+
+    @Override
+    protected boolean verifyDrawable(Drawable who) {
+        return who == mProgressDrawable || who == mIndeterminateDrawable
+                || super.verifyDrawable(who);
+    }
+
+    @Override
+    public void jumpDrawablesToCurrentState() {
+        super.jumpDrawablesToCurrentState();
+        if (mProgressDrawable != null) mProgressDrawable.jumpToCurrentState();
+        if (mIndeterminateDrawable != null) mIndeterminateDrawable.jumpToCurrentState();
+    }
+
+    @Override
+    public void postInvalidate() {
+        if (!mNoInvalidate) {
+            super.postInvalidate();
+        }
+    }
+
+    private class RefreshProgressRunnable implements Runnable {
+        public void run() {
+            synchronized (ProgressBar.this) {
+                final int count = mRefreshData.size();
+                for (int i = 0; i < count; i++) {
+                    final RefreshData rd = mRefreshData.get(i);
+                    doRefreshProgress(rd.id, rd.progress, rd.fromUser, true);
+                    rd.recycle();
+                }
+                mRefreshData.clear();
+                mRefreshIsPosted = false;
+            }
+        }
+    }
+
+    private static class RefreshData implements Poolable<RefreshData> {
+        public int id;
+        public int progress;
+        public boolean fromUser;
+        
+        private RefreshData mNext;
+        private boolean mIsPooled;
+        
+        private static final int POOL_MAX = 24;
+        private static final Pool<RefreshData> sPool = Pools.synchronizedPool(
+                Pools.finitePool(new PoolableManager<RefreshData>() {
+                    @Override
+                    public RefreshData newInstance() {
+                        return new RefreshData();
+                    }
+
+                    @Override
+                    public void onAcquired(RefreshData element) {
+                    }
+
+                    @Override
+                    public void onReleased(RefreshData element) {
+                    }
+                }, POOL_MAX));
+
+        public static RefreshData obtain(int id, int progress, boolean fromUser) {
+            RefreshData rd = sPool.acquire();
+            rd.id = id;
+            rd.progress = progress;
+            rd.fromUser = fromUser;
+            return rd;
+        }
+        
+        public void recycle() {
+            sPool.release(this);
+        }
+
+        @Override
+        public void setNextPoolable(RefreshData element) {
+            mNext = element;
+        }
+
+        @Override
+        public RefreshData getNextPoolable() {
+            return mNext;
+        }
+
+        @Override
+        public boolean isPooled() {
+            return mIsPooled;
+        }
+
+        @Override
+        public void setPooled(boolean isPooled) {
+            mIsPooled = isPooled;
+        }
+    }
+    
+    private synchronized void doRefreshProgress(int id, int progress, boolean fromUser,
+            boolean callBackToApp) {
+        float scale = mMax > 0 ? (float) progress / (float) mMax : 0;
+        final Drawable d = mCurrentDrawable;
+        if (d != null) {
+            Drawable progressDrawable = null;
+
+            if (d instanceof LayerDrawable) {
+                progressDrawable = ((LayerDrawable) d).findDrawableByLayerId(id);
+            }
+
+            final int level = (int) (scale * MAX_LEVEL);
+            (progressDrawable != null ? progressDrawable : d).setLevel(level);
+        } else {
+            invalidate();
+        }
+        
+        if (callBackToApp && id == R.id.progress) {
+            onProgressRefresh(scale, fromUser);
+        }
+    }
+
+    void onProgressRefresh(float scale, boolean fromUser) {
+        if (AccessibilityManager.getInstance(mContext).isEnabled()) {
+            scheduleAccessibilityEventSender();
+        }
+    }
+
+    private synchronized void refreshProgress(int id, int progress, boolean fromUser) {
+        if (mUiThreadId == Thread.currentThread().getId()) {
+            doRefreshProgress(id, progress, fromUser, true);
+        } else {
+            if (mRefreshProgressRunnable == null) {
+                mRefreshProgressRunnable = new RefreshProgressRunnable();
+            }
+
+            final RefreshData rd = RefreshData.obtain(id, progress, fromUser);
+            mRefreshData.add(rd);
+            if (mAttached && !mRefreshIsPosted) {
+                post(mRefreshProgressRunnable);
+                mRefreshIsPosted = true;
+            }
+        }
+    }
+    
+    /**
+     * <p>Set the current progress to the specified value. Does not do anything
+     * if the progress bar is in indeterminate mode.</p>
+     *
+     * @param progress the new progress, between 0 and {@link #getMax()}
+     *
+     * @see #setIndeterminate(boolean)
+     * @see #isIndeterminate()
+     * @see #getProgress()
+     * @see #incrementProgressBy(int) 
+     */
+    @android.view.RemotableViewMethod
+    public synchronized void setProgress(int progress) {
+        setProgress(progress, false);
+    }
+    
+    @android.view.RemotableViewMethod
+    synchronized void setProgress(int progress, boolean fromUser) {
+        if (mIndeterminate) {
+            return;
+        }
+
+        if (progress < 0) {
+            progress = 0;
+        }
+
+        if (progress > mMax) {
+            progress = mMax;
+        }
+
+        if (progress != mProgress) {
+            mProgress = progress;
+            refreshProgress(R.id.progress, mProgress, fromUser);
+        }
+    }
+
+    /**
+     * <p>
+     * Set the current secondary progress to the specified value. Does not do
+     * anything if the progress bar is in indeterminate mode.
+     * </p>
+     * 
+     * @param secondaryProgress the new secondary progress, between 0 and {@link #getMax()}
+     * @see #setIndeterminate(boolean)
+     * @see #isIndeterminate()
+     * @see #getSecondaryProgress()
+     * @see #incrementSecondaryProgressBy(int)
+     */
+    @android.view.RemotableViewMethod
+    public synchronized void setSecondaryProgress(int secondaryProgress) {
+        if (mIndeterminate) {
+            return;
+        }
+
+        if (secondaryProgress < 0) {
+            secondaryProgress = 0;
+        }
+
+        if (secondaryProgress > mMax) {
+            secondaryProgress = mMax;
+        }
+
+        if (secondaryProgress != mSecondaryProgress) {
+            mSecondaryProgress = secondaryProgress;
+            refreshProgress(R.id.secondaryProgress, mSecondaryProgress, false);
+        }
+    }
+
+    /**
+     * <p>Get the progress bar's current level of progress. Return 0 when the
+     * progress bar is in indeterminate mode.</p>
+     *
+     * @return the current progress, between 0 and {@link #getMax()}
+     *
+     * @see #setIndeterminate(boolean)
+     * @see #isIndeterminate()
+     * @see #setProgress(int)
+     * @see #setMax(int)
+     * @see #getMax()
+     */
+    @ViewDebug.ExportedProperty(category = "progress")
+    public synchronized int getProgress() {
+        return mIndeterminate ? 0 : mProgress;
+    }
+
+    /**
+     * <p>Get the progress bar's current level of secondary progress. Return 0 when the
+     * progress bar is in indeterminate mode.</p>
+     *
+     * @return the current secondary progress, between 0 and {@link #getMax()}
+     *
+     * @see #setIndeterminate(boolean)
+     * @see #isIndeterminate()
+     * @see #setSecondaryProgress(int)
+     * @see #setMax(int)
+     * @see #getMax()
+     */
+    @ViewDebug.ExportedProperty(category = "progress")
+    public synchronized int getSecondaryProgress() {
+        return mIndeterminate ? 0 : mSecondaryProgress;
+    }
+
+    /**
+     * <p>Return the upper limit of this progress bar's range.</p>
+     *
+     * @return a positive integer
+     *
+     * @see #setMax(int)
+     * @see #getProgress()
+     * @see #getSecondaryProgress()
+     */
+    @ViewDebug.ExportedProperty(category = "progress")
+    public synchronized int getMax() {
+        return mMax;
+    }
+
+    /**
+     * <p>Set the range of the progress bar to 0...<tt>max</tt>.</p>
+     *
+     * @param max the upper range of this progress bar
+     *
+     * @see #getMax()
+     * @see #setProgress(int) 
+     * @see #setSecondaryProgress(int) 
+     */
+    @android.view.RemotableViewMethod
+    public synchronized void setMax(int max) {
+        if (max < 0) {
+            max = 0;
+        }
+        if (max != mMax) {
+            mMax = max;
+            postInvalidate();
+
+            if (mProgress > max) {
+                mProgress = max;
+            }
+            refreshProgress(R.id.progress, mProgress, false);
+        }
+    }
+    
+    /**
+     * <p>Increase the progress bar's progress by the specified amount.</p>
+     *
+     * @param diff the amount by which the progress must be increased
+     *
+     * @see #setProgress(int) 
+     */
+    public synchronized final void incrementProgressBy(int diff) {
+        setProgress(mProgress + diff);
+    }
+
+    /**
+     * <p>Increase the progress bar's secondary progress by the specified amount.</p>
+     *
+     * @param diff the amount by which the secondary progress must be increased
+     *
+     * @see #setSecondaryProgress(int) 
+     */
+    public synchronized final void incrementSecondaryProgressBy(int diff) {
+        setSecondaryProgress(mSecondaryProgress + diff);
+    }
+
+    /**
+     * <p>Start the indeterminate progress animation.</p>
+     */
+    void startAnimation() {
+        if (getVisibility() != VISIBLE) {
+            return;
+        }
+
+        if (mIndeterminateDrawable instanceof Animatable) {
+            mShouldStartAnimationDrawable = true;
+            mHasAnimation = false;
+        } else {
+            mHasAnimation = true;
+
+            if (mInterpolator == null) {
+                mInterpolator = new LinearInterpolator();
+            }
+    
+            if (mTransformation == null) {
+                mTransformation = new Transformation();
+            } else {
+                mTransformation.clear();
+            }
+            
+            if (mAnimation == null) {
+                mAnimation = new AlphaAnimation(0.0f, 1.0f);
+            } else {
+                mAnimation.reset();
+            }
+
+            mAnimation.setRepeatMode(mBehavior);
+            mAnimation.setRepeatCount(Animation.INFINITE);
+            mAnimation.setDuration(mDuration);
+            mAnimation.setInterpolator(mInterpolator);
+            mAnimation.setStartTime(Animation.START_ON_FIRST_FRAME);
+        }
+        postInvalidate();
+    }
+
+    /**
+     * <p>Stop the indeterminate progress animation.</p>
+     */
+    void stopAnimation() {
+        mHasAnimation = false;
+        if (mIndeterminateDrawable instanceof Animatable) {
+            ((Animatable) mIndeterminateDrawable).stop();
+            mShouldStartAnimationDrawable = false;
+        }
+        postInvalidate();
+    }
+
+    /**
+     * Sets the acceleration curve for the indeterminate animation.
+     * The interpolator is loaded as a resource from the specified context.
+     *
+     * @param context The application environment
+     * @param resID The resource identifier of the interpolator to load
+     */
+    public void setInterpolator(Context context, int resID) {
+        setInterpolator(AnimationUtils.loadInterpolator(context, resID));
+    }
+
+    /**
+     * Sets the acceleration curve for the indeterminate animation.
+     * Defaults to a linear interpolation.
+     *
+     * @param interpolator The interpolator which defines the acceleration curve
+     */
+    public void setInterpolator(Interpolator interpolator) {
+        mInterpolator = interpolator;
+    }
+
+    /**
+     * Gets the acceleration curve type for the indeterminate animation.
+     *
+     * @return the {@link Interpolator} associated to this animation
+     */
+    public Interpolator getInterpolator() {
+        return mInterpolator;
+    }
+
+    @Override
+    @RemotableViewMethod
+    public void setVisibility(int v) {
+        if (getVisibility() != v) {
+            super.setVisibility(v);
+
+            if (mIndeterminate) {
+                // let's be nice with the UI thread
+                if (v == GONE || v == INVISIBLE) {
+                    stopAnimation();
+                } else {
+                    startAnimation();
+                }
+            }
+        }
+    }
+
+    @Override
+    protected void onVisibilityChanged(View changedView, int visibility) {
+        super.onVisibilityChanged(changedView, visibility);
+
+        if (mIndeterminate) {
+            // let's be nice with the UI thread
+            if (visibility == GONE || visibility == INVISIBLE) {
+                stopAnimation();
+            } else {
+                startAnimation();
+            }
+        }
+    }
+
+    @Override
+    public void invalidateDrawable(Drawable dr) {
+        if (!mInDrawing) {
+            if (verifyDrawable(dr)) {
+                final Rect dirty = dr.getBounds();
+                final int scrollX = mScrollX + mPaddingLeft;
+                final int scrollY = mScrollY + mPaddingTop;
+
+                invalidate(dirty.left + scrollX, dirty.top + scrollY,
+                        dirty.right + scrollX, dirty.bottom + scrollY);
+            } else {
+                super.invalidateDrawable(dr);
+            }
+        }
+    }
+
+    /**
+     * @hide
+     */
+    @Override
+    public int getResolvedLayoutDirection(Drawable who) {
+        return (who == mProgressDrawable || who == mIndeterminateDrawable) ?
+            getResolvedLayoutDirection() : super.getResolvedLayoutDirection(who);
+    }
+
+    @Override
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        updateDrawableBounds(w, h);
+    }
+
+    private void updateDrawableBounds(int w, int h) {
+        // onDraw will translate the canvas so we draw starting at 0,0
+        int right = w - mPaddingRight - mPaddingLeft;
+        int bottom = h - mPaddingBottom - mPaddingTop;
+        int top = 0;
+        int left = 0;
+
+        if (mIndeterminateDrawable != null) {
+            // Aspect ratio logic does not apply to AnimationDrawables
+            if (mOnlyIndeterminate && !(mIndeterminateDrawable instanceof AnimationDrawable)) {
+                // Maintain aspect ratio. Certain kinds of animated drawables
+                // get very confused otherwise.
+                final int intrinsicWidth = mIndeterminateDrawable.getIntrinsicWidth();
+                final int intrinsicHeight = mIndeterminateDrawable.getIntrinsicHeight();
+                final float intrinsicAspect = (float) intrinsicWidth / intrinsicHeight;
+                final float boundAspect = (float) w / h;
+                if (intrinsicAspect != boundAspect) {
+                    if (boundAspect > intrinsicAspect) {
+                        // New width is larger. Make it smaller to match height.
+                        final int width = (int) (h * intrinsicAspect);
+                        left = (w - width) / 2;
+                        right = left + width;
+                    } else {
+                        // New height is larger. Make it smaller to match width.
+                        final int height = (int) (w * (1 / intrinsicAspect));
+                        top = (h - height) / 2;
+                        bottom = top + height;
+                    }
+                }
+            }
+            mIndeterminateDrawable.setBounds(left, top, right, bottom);
+        }
+        
+        if (mProgressDrawable != null) {
+            mProgressDrawable.setBounds(0, 0, right, bottom);
+        }
+    }
+
+    @Override
+    protected synchronized void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+
+        Drawable d = mCurrentDrawable;
+        if (d != null) {
+            // Translate canvas so a indeterminate circular progress bar with padding
+            // rotates properly in its animation
+            canvas.save();
+            canvas.translate(mPaddingLeft, mPaddingTop);
+            long time = getDrawingTime();
+            if (mHasAnimation) {
+                mAnimation.getTransformation(time, mTransformation);
+                float scale = mTransformation.getAlpha();
+                try {
+                    mInDrawing = true;
+                    d.setLevel((int) (scale * MAX_LEVEL));
+                } finally {
+                    mInDrawing = false;
+                }
+                postInvalidateOnAnimation();
+            }
+            d.draw(canvas);
+            canvas.restore();
+            if (mShouldStartAnimationDrawable && d instanceof Animatable) {
+                ((Animatable) d).start();
+                mShouldStartAnimationDrawable = false;
+            }
+        }
+    }
+
+    @Override
+    protected synchronized void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        Drawable d = mCurrentDrawable;
+
+        int dw = 0;
+        int dh = 0;
+        if (d != null) {
+            dw = Math.max(mMinWidth, Math.min(mMaxWidth, d.getIntrinsicWidth()));
+            dh = Math.max(mMinHeight, Math.min(mMaxHeight, d.getIntrinsicHeight()));
+        }
+        updateDrawableState();
+        dw += mPaddingLeft + mPaddingRight;
+        dh += mPaddingTop + mPaddingBottom;
+
+        setMeasuredDimension(resolveSizeAndState(dw, widthMeasureSpec, 0),
+                resolveSizeAndState(dh, heightMeasureSpec, 0));
+    }
+    
+    @Override
+    protected void drawableStateChanged() {
+        super.drawableStateChanged();
+        updateDrawableState();
+    }
+        
+    private void updateDrawableState() {
+        int[] state = getDrawableState();
+        
+        if (mProgressDrawable != null && mProgressDrawable.isStateful()) {
+            mProgressDrawable.setState(state);
+        }
+        
+        if (mIndeterminateDrawable != null && mIndeterminateDrawable.isStateful()) {
+            mIndeterminateDrawable.setState(state);
+        }
+    }
+
+    static class SavedState extends BaseSavedState {
+        int progress;
+        int secondaryProgress;
+        
+        /**
+         * Constructor called from {@link ProgressBar#onSaveInstanceState()}
+         */
+        SavedState(Parcelable superState) {
+            super(superState);
+        }
+        
+        /**
+         * Constructor called from {@link #CREATOR}
+         */
+        private SavedState(Parcel in) {
+            super(in);
+            progress = in.readInt();
+            secondaryProgress = in.readInt();
+        }
+
+        @Override
+        public void writeToParcel(Parcel out, int flags) {
+            super.writeToParcel(out, flags);
+            out.writeInt(progress);
+            out.writeInt(secondaryProgress);
+        }
+
+        public static final Parcelable.Creator<SavedState> CREATOR
+                = new Parcelable.Creator<SavedState>() {
+            public SavedState createFromParcel(Parcel in) {
+                return new SavedState(in);
+            }
+
+            public SavedState[] newArray(int size) {
+                return new SavedState[size];
+            }
+        };
+    }
+
+    @Override
+    public Parcelable onSaveInstanceState() {
+        // Force our ancestor class to save its state
+        Parcelable superState = super.onSaveInstanceState();
+        SavedState ss = new SavedState(superState);
+        
+        ss.progress = mProgress;
+        ss.secondaryProgress = mSecondaryProgress;
+        
+        return ss;
+    }
+
+    @Override
+    public void onRestoreInstanceState(Parcelable state) {
+        SavedState ss = (SavedState) state;
+        super.onRestoreInstanceState(ss.getSuperState());
+        
+        setProgress(ss.progress);
+        setSecondaryProgress(ss.secondaryProgress);
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        if (mIndeterminate) {
+            startAnimation();
+        }
+        if (mRefreshData != null) {
+            synchronized (this) {
+                final int count = mRefreshData.size();
+                for (int i = 0; i < count; i++) {
+                    final RefreshData rd = mRefreshData.get(i);
+                    doRefreshProgress(rd.id, rd.progress, rd.fromUser, true);
+                    rd.recycle();
+                }
+                mRefreshData.clear();
+            }
+        }
+        mAttached = true;
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        if (mIndeterminate) {
+            stopAnimation();
+        }
+        if (mRefreshProgressRunnable != null) {
+            removeCallbacks(mRefreshProgressRunnable);
+        }
+        if (mRefreshProgressRunnable != null && mRefreshIsPosted) {
+            removeCallbacks(mRefreshProgressRunnable);
+        }
+        if (mAccessibilityEventSender != null) {
+            removeCallbacks(mAccessibilityEventSender);
+        }
+        // This should come after stopAnimation(), otherwise an invalidate message remains in the
+        // queue, which can prevent the entire view hierarchy from being GC'ed during a rotation
+        super.onDetachedFromWindow();
+        mAttached = false;
+    }
+
+    @Override
+    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
+        super.onInitializeAccessibilityEvent(event);
+        event.setClassName(ProgressBar.class.getName());
+        event.setItemCount(mMax);
+        event.setCurrentItemIndex(mProgress);
+    }
+
+    @Override
+    public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
+        super.onInitializeAccessibilityNodeInfo(info);
+        info.setClassName(ProgressBar.class.getName());
+    }
+
+    /**
+     * Schedule a command for sending an accessibility event.
+     * </br>
+     * Note: A command is used to ensure that accessibility events
+     *       are sent at most one in a given time frame to save
+     *       system resources while the progress changes quickly.
+     */
+    private void scheduleAccessibilityEventSender() {
+        if (mAccessibilityEventSender == null) {
+            mAccessibilityEventSender = new AccessibilityEventSender();
+        } else {
+            removeCallbacks(mAccessibilityEventSender);
+        }
+        postDelayed(mAccessibilityEventSender, TIMEOUT_SEND_ACCESSIBILITY_EVENT);
+    }
+
+    /**
+     * Command for sending an accessibility event.
+     */
+    private class AccessibilityEventSender implements Runnable {
+        public void run() {
+            sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED);
+        }
+    }
+}
diff --git a/src/frameworks/base/core/java/android/widget/SearchView.java b/src/frameworks/base/core/java/android/widget/SearchView.java
new file mode 100644
index 0000000..a0e961f
--- /dev/null
+++ b/src/frameworks/base/core/java/android/widget/SearchView.java
@@ -0,0 +1,1751 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.widget;
+
+import static android.widget.SuggestionsAdapter.getColumnString;
+
+import android.app.PendingIntent;
+import android.app.SearchManager;
+import android.app.SearchableInfo;
+import android.content.ActivityNotFoundException;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.database.Cursor;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.os.Bundle;
+import android.speech.RecognizerIntent;
+import android.text.Editable;
+import android.text.InputType;
+import android.text.Spannable;
+import android.text.SpannableStringBuilder;
+import android.text.TextUtils;
+import android.text.TextWatcher;
+import android.text.style.ImageSpan;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.util.TypedValue;
+import android.view.CollapsibleActionView;
+import android.view.KeyEvent;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.accessibility.AccessibilityEvent;
+import android.view.accessibility.AccessibilityNodeInfo;
+import android.view.inputmethod.EditorInfo;
+import android.view.inputmethod.InputMethodManager;
+import android.widget.AdapterView.OnItemClickListener;
+import android.widget.AdapterView.OnItemSelectedListener;
+import android.widget.TextView.OnEditorActionListener;
+
+import com.android.internal.R;
+
+import java.util.WeakHashMap;
+
+/**
+ * A widget that provides a user interface for the user to enter a search query and submit a request
+ * to a search provider. Shows a list of query suggestions or results, if available, and allows the
+ * user to pick a suggestion or result to launch into.
+ *
+ * <p>
+ * When the SearchView is used in an ActionBar as an action view for a collapsible menu item, it
+ * needs to be set to iconified by default using {@link #setIconifiedByDefault(boolean)
+ * setIconifiedByDefault(true)}. This is the default, so nothing needs to be done.
+ * </p>
+ * <p>
+ * If you want the search field to always be visible, then call setIconifiedByDefault(false).
+ * </p>
+ *
+ * <div class="special reference">
+ * <h3>Developer Guides</h3>
+ * <p>For information about using {@code SearchView}, read the
+ * <a href="{@docRoot}guide/topics/search/index.html">Search</a> developer guide.</p>
+ * </div>
+ *
+ * @see android.view.MenuItem#SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW
+ * @attr ref android.R.styleable#SearchView_iconifiedByDefault
+ * @attr ref android.R.styleable#SearchView_imeOptions
+ * @attr ref android.R.styleable#SearchView_inputType
+ * @attr ref android.R.styleable#SearchView_maxWidth
+ * @attr ref android.R.styleable#SearchView_queryHint
+ */
+public class SearchView extends LinearLayout implements CollapsibleActionView {
+
+    private static final boolean DBG = false;
+    private static final String LOG_TAG = "SearchView";
+
+    /**
+     * Private constant for removing the microphone in the keyboard.
+     */
+    private static final String IME_OPTION_NO_MICROPHONE = "nm";
+
+    private OnQueryTextListener mOnQueryChangeListener;
+    private OnCloseListener mOnCloseListener;
+    private OnFocusChangeListener mOnQueryTextFocusChangeListener;
+    private OnSuggestionListener mOnSuggestionListener;
+    private OnClickListener mOnSearchClickListener;
+
+    private boolean mIconifiedByDefault;
+    private boolean mIconified;
+    private CursorAdapter mSuggestionsAdapter;
+    private View mSearchButton;
+    private View mSubmitButton;
+    private View mSearchPlate;
+    private View mSubmitArea;
+    private ImageView mCloseButton;
+    private View mSearchEditFrame;
+    private View mVoiceButton;
+    private SearchAutoComplete mQueryTextView;
+    private View mDropDownAnchor;
+    private ImageView mSearchHintIcon;
+    private boolean mSubmitButtonEnabled;
+    private CharSequence mQueryHint;
+    private boolean mQueryRefinement;
+    private boolean mClearingFocus;
+    private int mMaxWidth;
+    private boolean mVoiceButtonEnabled;
+    private CharSequence mOldQueryText;
+    private CharSequence mUserQuery;
+    private boolean mExpandedInActionView;
+    private int mCollapsedImeOptions;
+
+    private SearchableInfo mSearchable;
+    private Bundle mAppSearchData;
+
+    /*
+     * SearchView can be set expanded before the IME is ready to be shown during
+     * initial UI setup. The show operation is asynchronous to account for this.
+     */
+    private Runnable mShowImeRunnable = new Runnable() {
+        public void run() {
+            InputMethodManager imm = (InputMethodManager)
+                    getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
+
+            if (imm != null) {
+                imm.showSoftInputUnchecked(0, null);
+            }
+        }
+    };
+
+    private Runnable mUpdateDrawableStateRunnable = new Runnable() {
+        public void run() {
+            updateFocusedState();
+        }
+    };
+
+    private Runnable mReleaseCursorRunnable = new Runnable() {
+        public void run() {
+            if (mSuggestionsAdapter != null && mSuggestionsAdapter instanceof SuggestionsAdapter) {
+                mSuggestionsAdapter.changeCursor(null);
+            }
+        }
+    };
+
+    // For voice searching
+    private final Intent mVoiceWebSearchIntent;
+    private final Intent mVoiceAppSearchIntent;
+
+    // A weak map of drawables we've gotten from other packages, so we don't load them
+    // more than once.
+    private final WeakHashMap<String, Drawable.ConstantState> mOutsideDrawablesCache =
+            new WeakHashMap<String, Drawable.ConstantState>();
+
+    /**
+     * Callbacks for changes to the query text.
+     */
+    public interface OnQueryTextListener {
+
+        /**
+         * Called when the user submits the query. This could be due to a key press on the
+         * keyboard or due to pressing a submit button.
+         * The listener can override the standard behavior by returning true
+         * to indicate that it has handled the submit request. Otherwise return false to
+         * let the SearchView handle the submission by launching any associated intent.
+         *
+         * @param query the query text that is to be submitted
+         *
+         * @return true if the query has been handled by the listener, false to let the
+         * SearchView perform the default action.
+         */
+        boolean onQueryTextSubmit(String query);
+
+        /**
+         * Called when the query text is changed by the user.
+         *
+         * @param newText the new content of the query text field.
+         *
+         * @return false if the SearchView should perform the default action of showing any
+         * suggestions if available, true if the action was handled by the listener.
+         */
+        boolean onQueryTextChange(String newText);
+    }
+
+    public interface OnCloseListener {
+
+        /**
+         * The user is attempting to close the SearchView.
+         *
+         * @return true if the listener wants to override the default behavior of clearing the
+         * text field and dismissing it, false otherwise.
+         */
+        boolean onClose();
+    }
+
+    /**
+     * Callback interface for selection events on suggestions. These callbacks
+     * are only relevant when a SearchableInfo has been specified by {@link #setSearchableInfo}.
+     */
+    public interface OnSuggestionListener {
+
+        /**
+         * Called when a suggestion was selected by navigating to it.
+         * @param position the absolute position in the list of suggestions.
+         *
+         * @return true if the listener handles the event and wants to override the default
+         * behavior of possibly rewriting the query based on the selected item, false otherwise.
+         */
+        boolean onSuggestionSelect(int position);
+
+        /**
+         * Called when a suggestion was clicked.
+         * @param position the absolute position of the clicked item in the list of suggestions.
+         *
+         * @return true if the listener handles the event and wants to override the default
+         * behavior of launching any intent or submitting a search query specified on that item.
+         * Return false otherwise.
+         */
+        boolean onSuggestionClick(int position);
+    }
+
+    public SearchView(Context context) {
+        this(context, null);
+    }
+
+    public SearchView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+
+        LayoutInflater inflater = (LayoutInflater) context
+                .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        inflater.inflate(R.layout.search_view, this, true);
+
+        mSearchButton = findViewById(R.id.search_button);
+        mQueryTextView = (SearchAutoComplete) findViewById(R.id.search_src_text);
+        mQueryTextView.setSearchView(this);
+
+        mSearchEditFrame = findViewById(R.id.search_edit_frame);
+        mSearchPlate = findViewById(R.id.search_plate);
+        mSubmitArea = findViewById(R.id.submit_area);
+        mSubmitButton = findViewById(R.id.search_go_btn);
+        mCloseButton = (ImageView) findViewById(R.id.search_close_btn);
+        mVoiceButton = findViewById(R.id.search_voice_btn);
+        mSearchHintIcon = (ImageView) findViewById(R.id.search_mag_icon);
+
+        mSearchButton.setOnClickListener(mOnClickListener);
+        mCloseButton.setOnClickListener(mOnClickListener);
+        mSubmitButton.setOnClickListener(mOnClickListener);
+        mVoiceButton.setOnClickListener(mOnClickListener);
+        mQueryTextView.setOnClickListener(mOnClickListener);
+
+        mQueryTextView.addTextChangedListener(mTextWatcher);
+        mQueryTextView.setOnEditorActionListener(mOnEditorActionListener);
+        mQueryTextView.setOnItemClickListener(mOnItemClickListener);
+        mQueryTextView.setOnItemSelectedListener(mOnItemSelectedListener);
+        mQueryTextView.setOnKeyListener(mTextKeyListener);
+        // Inform any listener of focus changes
+        mQueryTextView.setOnFocusChangeListener(new OnFocusChangeListener() {
+
+            public void onFocusChange(View v, boolean hasFocus) {
+                if (mOnQueryTextFocusChangeListener != null) {
+                    mOnQueryTextFocusChangeListener.onFocusChange(SearchView.this, hasFocus);
+                }
+            }
+        });
+
+        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SearchView, 0, 0);
+        setIconifiedByDefault(a.getBoolean(R.styleable.SearchView_iconifiedByDefault, true));
+        int maxWidth = a.getDimensionPixelSize(R.styleable.SearchView_maxWidth, -1);
+        if (maxWidth != -1) {
+            setMaxWidth(maxWidth);
+        }
+        CharSequence queryHint = a.getText(R.styleable.SearchView_queryHint);
+        if (!TextUtils.isEmpty(queryHint)) {
+            setQueryHint(queryHint);
+        }
+        int imeOptions = a.getInt(R.styleable.SearchView_imeOptions, -1);
+        if (imeOptions != -1) {
+            setImeOptions(imeOptions);
+        }
+        int inputType = a.getInt(R.styleable.SearchView_inputType, -1);
+        if (inputType != -1) {
+            setInputType(inputType);
+        }
+
+        a.recycle();
+
+        boolean focusable = true;
+
+        a = context.obtainStyledAttributes(attrs, R.styleable.View, 0, 0);
+        focusable = a.getBoolean(R.styleable.View_focusable, focusable);
+        a.recycle();
+        setFocusable(focusable);
+
+        // Save voice intent for later queries/launching
+        mVoiceWebSearchIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
+        mVoiceWebSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        mVoiceWebSearchIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,
+                RecognizerIntent.LANGUAGE_MODEL_WEB_SEARCH);
+
+        mVoiceAppSearchIntent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
+        mVoiceAppSearchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+
+        mDropDownAnchor = findViewById(mQueryTextView.getDropDownAnchor());
+        if (mDropDownAnchor != null) {
+            mDropDownAnchor.addOnLayoutChangeListener(new OnLayoutChangeListener() {
+                @Override
+                public void onLayoutChange(View v, int left, int top, int right, int bottom,
+                        int oldLeft, int oldTop, int oldRight, int oldBottom) {
+                    adjustDropDownSizeAndPosition();
+                }
+
+            });
+        }
+
+        updateViewsVisibility(mIconifiedByDefault);
+        updateQueryHint();
+    }
+
+    /**
+     * Sets the SearchableInfo for this SearchView. Properties in the SearchableInfo are used
+     * to display labels, hints, suggestions, create intents for launching search results screens
+     * and controlling other affordances such as a voice button.
+     *
+     * @param searchable a SearchableInfo can be retrieved from the SearchManager, for a specific
+     * activity or a global search provider.
+     */
+    public void setSearchableInfo(SearchableInfo searchable) {
+        mSearchable = searchable;
+        if (mSearchable != null) {
+            updateSearchAutoComplete();
+            updateQueryHint();
+        }
+        // Cache the voice search capability
+        mVoiceButtonEnabled = hasVoiceSearch();
+
+        if (mVoiceButtonEnabled) {
+            // Disable the microphone on the keyboard, as a mic is displayed near the text box
+            // TODO: use imeOptions to disable voice input when the new API will be available
+            mQueryTextView.setPrivateImeOptions(IME_OPTION_NO_MICROPHONE);
+        }
+        updateViewsVisibility(isIconified());
+    }
+
+    /**
+     * Sets the APP_DATA for legacy SearchDialog use.
+     * @param appSearchData bundle provided by the app when launching the search dialog
+     * @hide
+     */
+    public void setAppSearchData(Bundle appSearchData) {
+        mAppSearchData = appSearchData;
+    }
+
+    /**
+     * Sets the IME options on the query text field.
+     *
+     * @see TextView#setImeOptions(int)
+     * @param imeOptions the options to set on the query text field
+     *
+     * @attr ref android.R.styleable#SearchView_imeOptions
+     */
+    public void setImeOptions(int imeOptions) {
+        mQueryTextView.setImeOptions(imeOptions);
+    }
+
+    /**
+     * Returns the IME options set on the query text field.
+     * @return the ime options
+     * @see TextView#setImeOptions(int)
+     *
+     * @attr ref android.R.styleable#SearchView_imeOptions
+     */
+    public int getImeOptions() {
+        return mQueryTextView.getImeOptions();
+    }
+
+    /**
+     * Sets the input type on the query text field.
+     *
+     * @see TextView#setInputType(int)
+     * @param inputType the input type to set on the query text field
+     *
+     * @attr ref android.R.styleable#SearchView_inputType
+     */
+    public void setInputType(int inputType) {
+        mQueryTextView.setInputType(inputType);
+    }
+
+    /**
+     * Returns the input type set on the query text field.
+     * @return the input type
+     *
+     * @attr ref android.R.styleable#SearchView_inputType
+     */
+    public int getInputType() {
+        return mQueryTextView.getInputType();
+    }
+
+    /** @hide */
+    @Override
+    public boolean requestFocus(int direction, Rect previouslyFocusedRect) {
+        // Don't accept focus if in the middle of clearing focus
+        if (mClearingFocus) return false;
+        // Check if SearchView is focusable.
+        if (!isFocusable()) return false;
+        // If it is not iconified, then give the focus to the text field
+        if (!isIconified()) {
+            boolean result = mQueryTextView.requestFocus(direction, previouslyFocusedRect);
+            if (result) {
+                updateViewsVisibility(false);
+            }
+            return result;
+        } else {
+            return super.requestFocus(direction, previouslyFocusedRect);
+        }
+    }
+
+    /** @hide */
+    @Override
+    public void clearFocus() {
+        mClearingFocus = true;
+        setImeVisibility(false);
+        super.clearFocus();
+        mQueryTextView.clearFocus();
+        mClearingFocus = false;
+    }
+
+    /**
+     * Sets a listener for user actions within the SearchView.
+     *
+     * @param listener the listener object that receives callbacks when the user performs
+     * actions in the SearchView such as clicking on buttons or typing a query.
+     */
+    public void setOnQueryTextListener(OnQueryTextListener listener) {
+        mOnQueryChangeListener = listener;
+    }
+
+    /**
+     * Sets a listener to inform when the user closes the SearchView.
+     *
+     * @param listener the listener to call when the user closes the SearchView.
+     */
+    public void setOnCloseListener(OnCloseListener listener) {
+        mOnCloseListener = listener;
+    }
+
+    /**
+     * Sets a listener to inform when the focus of the query text field changes.
+     *
+     * @param listener the listener to inform of focus changes.
+     */
+    public void setOnQueryTextFocusChangeListener(OnFocusChangeListener listener) {
+        mOnQueryTextFocusChangeListener = listener;
+    }
+
+    /**
+     * Sets a listener to inform when a suggestion is focused or clicked.
+     *
+     * @param listener the listener to inform of suggestion selection events.
+     */
+    public void setOnSuggestionListener(OnSuggestionListener listener) {
+        mOnSuggestionListener = listener;
+    }
+
+    /**
+     * Sets a listener to inform when the search button is pressed. This is only
+     * relevant when the text field is not visible by default. Calling {@link #setIconified
+     * setIconified(false)} can also cause this listener to be informed.
+     *
+     * @param listener the listener to inform when the search button is clicked or
+     * the text field is programmatically de-iconified.
+     */
+    public void setOnSearchClickListener(OnClickListener listener) {
+        mOnSearchClickListener = listener;
+    }
+
+    /**
+     * Returns the query string currently in the text field.
+     *
+     * @return the query string
+     */
+    public CharSequence getQuery() {
+        return mQueryTextView.getText();
+    }
+
+    /**
+     * Sets a query string in the text field and optionally submits the query as well.
+     *
+     * @param query the query string. This replaces any query text already present in the
+     * text field.
+     * @param submit whether to submit the query right now or only update the contents of
+     * text field.
+     */
+    public void setQuery(CharSequence query, boolean submit) {
+        mQueryTextView.setText(query);
+        if (query != null) {
+            mQueryTextView.setSelection(mQueryTextView.length());
+            mUserQuery = query;
+        }
+
+        // If the query is not empty and submit is requested, submit the query
+        if (submit && !TextUtils.isEmpty(query)) {
+            onSubmitQuery();
+        }
+    }
+
+    /**
+     * Sets the hint text to display in the query text field. This overrides any hint specified
+     * in the SearchableInfo.
+     *
+     * @param hint the hint text to display
+     *
+     * @attr ref android.R.styleable#SearchView_queryHint
+     */
+    public void setQueryHint(CharSequence hint) {
+        mQueryHint = hint;
+        updateQueryHint();
+    }
+
+    /**
+     * Gets the hint text to display in the query text field.
+     * @return the query hint text, if specified, null otherwise.
+     *
+     * @attr ref android.R.styleable#SearchView_queryHint
+     */
+    public CharSequence getQueryHint() {
+        if (mQueryHint != null) {
+            return mQueryHint;
+        } else if (mSearchable != null) {
+            CharSequence hint = null;
+            int hintId = mSearchable.getHintId();
+            if (hintId != 0) {
+                hint = getContext().getString(hintId);
+            }
+            return hint;
+        }
+        return null;
+    }
+
+    /**
+     * Sets the default or resting state of the search field. If true, a single search icon is
+     * shown by default and expands to show the text field and other buttons when pressed. Also,
+     * if the default state is iconified, then it collapses to that state when the close button
+     * is pressed. Changes to this property will take effect immediately.
+     *
+     * <p>The default value is true.</p>
+     *
+     * @param iconified whether the search field should be iconified by default
+     *
+     * @attr ref android.R.styleable#SearchView_iconifiedByDefault
+     */
+    public void setIconifiedByDefault(boolean iconified) {
+        if (mIconifiedByDefault == iconified) return;
+        mIconifiedByDefault = iconified;
+        updateViewsVisibility(iconified);
+        updateQueryHint();
+    }
+
+    /**
+     * Returns the default iconified state of the search field.
+     * @return
+     *
+     * @attr ref android.R.styleable#SearchView_iconifiedByDefault
+     */
+    public boolean isIconfiedByDefault() {
+        return mIconifiedByDefault;
+    }
+
+    /**
+     * Iconifies or expands the SearchView. Any query text is cleared when iconified. This is
+     * a temporary state and does not override the default iconified state set by
+     * {@link #setIconifiedByDefault(boolean)}. If the default state is iconified, then
+     * a false here will only be valid until the user closes the field. And if the default
+     * state is expanded, then a true here will only clear the text field and not close it.
+     *
+     * @param iconify a true value will collapse the SearchView to an icon, while a false will
+     * expand it.
+     */
+    public void setIconified(boolean iconify) {
+        if (iconify) {
+            onCloseClicked();
+        } else {
+            onSearchClicked();
+        }
+    }
+
+    /**
+     * Returns the current iconified state of the SearchView.
+     *
+     * @return true if the SearchView is currently iconified, false if the search field is
+     * fully visible.
+     */
+    public boolean isIconified() {
+        return mIconified;
+    }
+
+    /**
+     * Enables showing a submit button when the query is non-empty. In cases where the SearchView
+     * is being used to filter the contents of the current activity and doesn't launch a separate
+     * results activity, then the submit button should be disabled.
+     *
+     * @param enabled true to show a submit button for submitting queries, false if a submit
+     * button is not required.
+     */
+    public void setSubmitButtonEnabled(boolean enabled) {
+        mSubmitButtonEnabled = enabled;
+        updateViewsVisibility(isIconified());
+    }
+
+    /**
+     * Returns whether the submit button is enabled when necessary or never displayed.
+     *
+     * @return whether the submit button is enabled automatically when necessary
+     */
+    public boolean isSubmitButtonEnabled() {
+        return mSubmitButtonEnabled;
+    }
+
+    /**
+     * Specifies if a query refinement button should be displayed alongside each suggestion
+     * or if it should depend on the flags set in the individual items retrieved from the
+     * suggestions provider. Clicking on the query refinement button will replace the text
+     * in the query text field with the text from the suggestion. This flag only takes effect
+     * if a SearchableInfo has been specified with {@link #setSearchableInfo(SearchableInfo)}
+     * and not when using a custom adapter.
+     *
+     * @param enable true if all items should have a query refinement button, false if only
+     * those items that have a query refinement flag set should have the button.
+     *
+     * @see SearchManager#SUGGEST_COLUMN_FLAGS
+     * @see SearchManager#FLAG_QUERY_REFINEMENT
+     */
+    public void setQueryRefinementEnabled(boolean enable) {
+        mQueryRefinement = enable;
+        if (mSuggestionsAdapter instanceof SuggestionsAdapter) {
+            ((SuggestionsAdapter) mSuggestionsAdapter).setQueryRefinement(
+                    enable ? SuggestionsAdapter.REFINE_ALL : SuggestionsAdapter.REFINE_BY_ENTRY);
+        }
+    }
+
+    /**
+     * Returns whether query refinement is enabled for all items or only specific ones.
+     * @return true if enabled for all items, false otherwise.
+     */
+    public boolean isQueryRefinementEnabled() {
+        return mQueryRefinement;
+    }
+
+    /**
+     * You can set a custom adapter if you wish. Otherwise the default adapter is used to
+     * display the suggestions from the suggestions provider associated with the SearchableInfo.
+     *
+     * @see #setSearchableInfo(SearchableInfo)
+     */
+    public void setSuggestionsAdapter(CursorAdapter adapter) {
+        mSuggestionsAdapter = adapter;
+
+        mQueryTextView.setAdapter(mSuggestionsAdapter);
+    }
+
+    /**
+     * Returns the adapter used for suggestions, if any.
+     * @return the suggestions adapter
+     */
+    public CursorAdapter getSuggestionsAdapter() {
+        return mSuggestionsAdapter;
+    }
+
+    /**
+     * Makes the view at most this many pixels wide
+     *
+     * @attr ref android.R.styleable#SearchView_maxWidth
+     */
+    public void setMaxWidth(int maxpixels) {
+        mMaxWidth = maxpixels;
+
+        requestLayout();
+    }
+
+    /**
+     * Gets the specified maximum width in pixels, if set. Returns zero if
+     * no maximum width was specified.
+     * @return the maximum width of the view
+     *
+     * @attr ref android.R.styleable#SearchView_maxWidth
+     */
+    public int getMaxWidth() {
+        return mMaxWidth;
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        // Let the standard measurements take effect in iconified state.
+        if (isIconified()) {
+            super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+            return;
+        }
+
+        int widthMode = MeasureSpec.getMode(widthMeasureSpec);
+        int width = MeasureSpec.getSize(widthMeasureSpec);
+
+        switch (widthMode) {
+        case MeasureSpec.AT_MOST:
+            // If there is an upper limit, don't exceed maximum width (explicit or implicit)
+            if (mMaxWidth > 0) {
+                width = Math.min(mMaxWidth, width);
+            } else {
+                width = Math.min(getPreferredWidth(), width);
+            }
+            break;
+        case MeasureSpec.EXACTLY:
+            // If an exact width is specified, still don't exceed any specified maximum width
+            if (mMaxWidth > 0) {
+                width = Math.min(mMaxWidth, width);
+            }
+            break;
+        case MeasureSpec.UNSPECIFIED:
+            // Use maximum width, if specified, else preferred width
+            width = mMaxWidth > 0 ? mMaxWidth : getPreferredWidth();
+            break;
+        }
+        widthMode = MeasureSpec.EXACTLY;
+        super.onMeasure(MeasureSpec.makeMeasureSpec(width, widthMode), heightMeasureSpec);
+    }
+
+    private int getPreferredWidth() {
+        return getContext().getResources()
+                .getDimensionPixelSize(R.dimen.search_view_preferred_width);
+    }
+
+    private void updateViewsVisibility(final boolean collapsed) {
+        mIconified = collapsed;
+        // Visibility of views that are visible when collapsed
+        final int visCollapsed = collapsed ? VISIBLE : GONE;
+        // Is there text in the query
+        final boolean hasText = !TextUtils.isEmpty(mQueryTextView.getText());
+
+        mSearchButton.setVisibility(visCollapsed);
+        updateSubmitButton(hasText);
+        mSearchEditFrame.setVisibility(collapsed ? GONE : VISIBLE);
+        mSearchHintIcon.setVisibility(mIconifiedByDefault ? GONE : VISIBLE);
+        updateCloseButton();
+        updateVoiceButton(!hasText);
+        updateSubmitArea();
+    }
+
+    private boolean hasVoiceSearch() {
+        if (mSearchable != null && mSearchable.getVoiceSearchEnabled()) {
+            Intent testIntent = null;
+            if (mSearchable.getVoiceSearchLaunchWebSearch()) {
+                testIntent = mVoiceWebSearchIntent;
+            } else if (mSearchable.getVoiceSearchLaunchRecognizer()) {
+                testIntent = mVoiceAppSearchIntent;
+            }
+            if (testIntent != null) {
+                ResolveInfo ri = getContext().getPackageManager().resolveActivity(testIntent,
+                        PackageManager.MATCH_DEFAULT_ONLY);
+                return ri != null;
+            }
+        }
+        return false;
+    }
+
+    private boolean isSubmitAreaEnabled() {
+        return (mSubmitButtonEnabled || mVoiceButtonEnabled) && !isIconified();
+    }
+
+    private void updateSubmitButton(boolean hasText) {
+        int visibility = GONE;
+        if (mSubmitButtonEnabled && isSubmitAreaEnabled() && hasFocus()
+                && (hasText || !mVoiceButtonEnabled)) {
+            visibility = VISIBLE;
+        }
+        mSubmitButton.setVisibility(visibility);
+    }
+
+    private void updateSubmitArea() {
+        int visibility = GONE;
+        if (isSubmitAreaEnabled()
+                && (mSubmitButton.getVisibility() == VISIBLE
+                        || mVoiceButton.getVisibility() == VISIBLE)) {
+            visibility = VISIBLE;
+        }
+        mSubmitArea.setVisibility(visibility);
+    }
+
+    private void updateCloseButton() {
+        final boolean hasText = !TextUtils.isEmpty(mQueryTextView.getText());
+        // Should we show the close button? It is not shown if there's no focus,
+        // field is not iconified by default and there is no text in it.
+        final boolean showClose = hasText || (mIconifiedByDefault && !mExpandedInActionView);
+        mCloseButton.setVisibility(showClose ? VISIBLE : GONE);
+        mCloseButton.getDrawable().setState(hasText ? ENABLED_STATE_SET : EMPTY_STATE_SET);
+    }
+
+    private void postUpdateFocusedState() {
+        post(mUpdateDrawableStateRunnable);
+    }
+
+    private void updateFocusedState() {
+        boolean focused = mQueryTextView.hasFocus();
+        mSearchPlate.getBackground().setState(focused ? FOCUSED_STATE_SET : EMPTY_STATE_SET);
+        mSubmitArea.getBackground().setState(focused ? FOCUSED_STATE_SET : EMPTY_STATE_SET);
+        invalidate();
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        removeCallbacks(mUpdateDrawableStateRunnable);
+        post(mReleaseCursorRunnable);
+        super.onDetachedFromWindow();
+    }
+
+    private void setImeVisibility(final boolean visible) {
+        if (visible) {
+            post(mShowImeRunnable);
+        } else {
+            removeCallbacks(mShowImeRunnable);
+            InputMethodManager imm = (InputMethodManager)
+                    getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
+
+            if (imm != null) {
+                imm.hideSoftInputFromWindow(getWindowToken(), 0);
+            }
+        }
+    }
+
+    /**
+     * Called by the SuggestionsAdapter
+     * @hide
+     */
+    /* package */void onQueryRefine(CharSequence queryText) {
+        setQuery(queryText);
+    }
+
+    private final OnClickListener mOnClickListener = new OnClickListener() {
+
+        public void onClick(View v) {
+            if (v == mSearchButton) {
+                onSearchClicked();
+            } else if (v == mCloseButton) {
+                onCloseClicked();
+            } else if (v == mSubmitButton) {
+                onSubmitQuery();
+            } else if (v == mVoiceButton) {
+                onVoiceClicked();
+            } else if (v == mQueryTextView) {
+                forceSuggestionQuery();
+            }
+        }
+    };
+
+    /**
+     * Handles the key down event for dealing with action keys.
+     *
+     * @param keyCode This is the keycode of the typed key, and is the same value as
+     *        found in the KeyEvent parameter.
+     * @param event The complete event record for the typed key
+     *
+     * @return true if the event was handled here, or false if not.
+     */
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+        if (mSearchable == null) {
+            return false;
+        }
+
+        // if it's an action specified by the searchable activity, launch the
+        // entered query with the action key
+        SearchableInfo.ActionKeyInfo actionKey = mSearchable.findActionKey(keyCode);
+        if ((actionKey != null) && (actionKey.getQueryActionMsg() != null)) {
+            launchQuerySearch(keyCode, actionKey.getQueryActionMsg(), mQueryTextView.getText()
+                    .toString());
+            return true;
+        }
+
+        return super.onKeyDown(keyCode, event);
+    }
+
+    /**
+     * React to the user typing "enter" or other hardwired keys while typing in
+     * the search box. This handles these special keys while the edit box has
+     * focus.
+     */
+    View.OnKeyListener mTextKeyListener = new View.OnKeyListener() {
+        public boolean onKey(View v, int keyCode, KeyEvent event) {
+            // guard against possible race conditions
+            if (mSearchable == null) {
+                return false;
+            }
+
+            if (DBG) {
+                Log.d(LOG_TAG, "mTextListener.onKey(" + keyCode + "," + event + "), selection: "
+                        + mQueryTextView.getListSelection());
+            }
+
+            // If a suggestion is selected, handle enter, search key, and action keys
+            // as presses on the selected suggestion
+            if (mQueryTextView.isPopupShowing()
+                    && mQueryTextView.getListSelection() != ListView.INVALID_POSITION) {
+                return onSuggestionsKey(v, keyCode, event);
+            }
+
+            // If there is text in the query box, handle enter, and action keys
+            // The search key is handled by the dialog's onKeyDown().
+            if (!mQueryTextView.isEmpty() && event.hasNoModifiers()) {
+                if (event.getAction() == KeyEvent.ACTION_UP) {
+                    if (keyCode == KeyEvent.KEYCODE_ENTER) {
+                        v.cancelLongPress();
+
+                        // Launch as a regular search.
+                        launchQuerySearch(KeyEvent.KEYCODE_UNKNOWN, null, mQueryTextView.getText()
+                                .toString());
+                        return true;
+                    }
+                }
+                if (event.getAction() == KeyEvent.ACTION_DOWN) {
+                    SearchableInfo.ActionKeyInfo actionKey = mSearchable.findActionKey(keyCode);
+                    if ((actionKey != null) && (actionKey.getQueryActionMsg() != null)) {
+                        launchQuerySearch(keyCode, actionKey.getQueryActionMsg(), mQueryTextView
+                                .getText().toString());
+                        return true;
+                    }
+                }
+            }
+            return false;
+        }
+    };
+
+    /**
+     * React to the user typing while in the suggestions list. First, check for
+     * action keys. If not handled, try refocusing regular characters into the
+     * EditText.
+     */
+    private boolean onSuggestionsKey(View v, int keyCode, KeyEvent event) {
+        // guard against possible race conditions (late arrival after dismiss)
+        if (mSearchable == null) {
+            return false;
+        }
+        if (mSuggestionsAdapter == null) {
+            return false;
+        }
+        if (event.getAction() == KeyEvent.ACTION_DOWN && event.hasNoModifiers()) {
+            // First, check for enter or search (both of which we'll treat as a
+            // "click")
+            if (keyCode == KeyEvent.KEYCODE_ENTER || keyCode == KeyEvent.KEYCODE_SEARCH
+                    || keyCode == KeyEvent.KEYCODE_TAB) {
+                int position = mQueryTextView.getListSelection();
+                return onItemClicked(position, KeyEvent.KEYCODE_UNKNOWN, null);
+            }
+
+            // Next, check for left/right moves, which we use to "return" the
+            // user to the edit view
+            if (keyCode == KeyEvent.KEYCODE_DPAD_LEFT || keyCode == KeyEvent.KEYCODE_DPAD_RIGHT) {
+                // give "focus" to text editor, with cursor at the beginning if
+                // left key, at end if right key
+                // TODO: Reverse left/right for right-to-left languages, e.g.
+                // Arabic
+                int selPoint = (keyCode == KeyEvent.KEYCODE_DPAD_LEFT) ? 0 : mQueryTextView
+                        .length();
+                mQueryTextView.setSelection(selPoint);
+                mQueryTextView.setListSelection(0);
+                mQueryTextView.clearListSelection();
+                mQueryTextView.ensureImeVisible(true);
+
+                return true;
+            }
+
+            // Next, check for an "up and out" move
+            if (keyCode == KeyEvent.KEYCODE_DPAD_UP && 0 == mQueryTextView.getListSelection()) {
+                // TODO: restoreUserQuery();
+                // let ACTV complete the move
+                return false;
+            }
+
+            // Next, check for an "action key"
+            SearchableInfo.ActionKeyInfo actionKey = mSearchable.findActionKey(keyCode);
+            if ((actionKey != null)
+                    && ((actionKey.getSuggestActionMsg() != null) || (actionKey
+                            .getSuggestActionMsgColumn() != null))) {
+                // launch suggestion using action key column
+                int position = mQueryTextView.getListSelection();
+                if (position != ListView.INVALID_POSITION) {
+                    Cursor c = mSuggestionsAdapter.getCursor();
+                    if (c.moveToPosition(position)) {
+                        final String actionMsg = getActionKeyMessage(c, actionKey);
+                        if (actionMsg != null && (actionMsg.length() > 0)) {
+                            return onItemClicked(position, keyCode, actionMsg);
+                        }
+                    }
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * For a given suggestion and a given cursor row, get the action message. If
+     * not provided by the specific row/column, also check for a single
+     * definition (for the action key).
+     *
+     * @param c The cursor providing suggestions
+     * @param actionKey The actionkey record being examined
+     *
+     * @return Returns a string, or null if no action key message for this
+     *         suggestion
+     */
+    private static String getActionKeyMessage(Cursor c, SearchableInfo.ActionKeyInfo actionKey) {
+        String result = null;
+        // check first in the cursor data, for a suggestion-specific message
+        final String column = actionKey.getSuggestActionMsgColumn();
+        if (column != null) {
+            result = SuggestionsAdapter.getColumnString(c, column);
+        }
+        // If the cursor didn't give us a message, see if there's a single
+        // message defined
+        // for the actionkey (for all suggestions)
+        if (result == null) {
+            result = actionKey.getSuggestActionMsg();
+        }
+        return result;
+    }
+
+    private int getSearchIconId() {
+        TypedValue outValue = new TypedValue();
+        getContext().getTheme().resolveAttribute(com.android.internal.R.attr.searchViewSearchIcon,
+                outValue, true);
+        return outValue.resourceId;
+    }
+
+    private CharSequence getDecoratedHint(CharSequence hintText) {
+        // If the field is always expanded, then don't add the search icon to the hint
+        if (!mIconifiedByDefault) return hintText;
+
+        SpannableStringBuilder ssb = new SpannableStringBuilder("   "); // for the icon
+        ssb.append(hintText);
+        Drawable searchIcon = getContext().getResources().getDrawable(getSearchIconId());
+        int textSize = (int) (mQueryTextView.getTextSize() * 1.25);
+        searchIcon.setBounds(0, 0, textSize, textSize);
+        ssb.setSpan(new ImageSpan(searchIcon), 1, 2, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
+        return ssb;
+    }
+
+    private void updateQueryHint() {
+        if (mQueryHint != null) {
+            mQueryTextView.setHint(getDecoratedHint(mQueryHint));
+        } else if (mSearchable != null) {
+            CharSequence hint = null;
+            int hintId = mSearchable.getHintId();
+            if (hintId != 0) {
+                hint = getContext().getString(hintId);
+            }
+            if (hint != null) {
+                mQueryTextView.setHint(getDecoratedHint(hint));
+            }
+        } else {
+            mQueryTextView.setHint(getDecoratedHint(""));
+        }
+    }
+
+    /**
+     * Updates the auto-complete text view.
+     */
+    private void updateSearchAutoComplete() {
+        mQueryTextView.setDropDownAnimationStyle(0); // no animation
+        mQueryTextView.setThreshold(mSearchable.getSuggestThreshold());
+        mQueryTextView.setImeOptions(mSearchable.getImeOptions());
+        int inputType = mSearchable.getInputType();
+        // We only touch this if the input type is set up for text (which it almost certainly
+        // should be, in the case of search!)
+        if ((inputType & InputType.TYPE_MASK_CLASS) == InputType.TYPE_CLASS_TEXT) {
+            // The existence of a suggestions authority is the proxy for "suggestions
+            // are available here"
+            inputType &= ~InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
+            if (mSearchable.getSuggestAuthority() != null) {
+                inputType |= InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
+                // TYPE_TEXT_FLAG_AUTO_COMPLETE means that the text editor is performing
+                // auto-completion based on its own semantics, which it will present to the user
+                // as they type. This generally means that the input method should not show its
+                // own candidates, and the spell checker should not be in action. The text editor
+                // supplies its candidates by calling InputMethodManager.displayCompletions(),
+                // which in turn will call InputMethodSession.displayCompletions().
+                inputType |= InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS;
+            }
+        }
+        mQueryTextView.setInputType(inputType);
+        if (mSuggestionsAdapter != null) {
+            mSuggestionsAdapter.changeCursor(null);
+        }
+        // attach the suggestions adapter, if suggestions are available
+        // The existence of a suggestions authority is the proxy for "suggestions available here"
+        if (mSearchable.getSuggestAuthority() != null) {
+            mSuggestionsAdapter = new SuggestionsAdapter(getContext(),
+                    this, mSearchable, mOutsideDrawablesCache);
+            mQueryTextView.setAdapter(mSuggestionsAdapter);
+            ((SuggestionsAdapter) mSuggestionsAdapter).setQueryRefinement(
+                    mQueryRefinement ? SuggestionsAdapter.REFINE_ALL
+                    : SuggestionsAdapter.REFINE_BY_ENTRY);
+        }
+    }
+
+    /**
+     * Update the visibility of the voice button.  There are actually two voice search modes,
+     * either of which will activate the button.
+     * @param empty whether the search query text field is empty. If it is, then the other
+     * criteria apply to make the voice button visible.
+     */
+    private void updateVoiceButton(boolean empty) {
+        int visibility = GONE;
+        if (mVoiceButtonEnabled && !isIconified() && empty) {
+            visibility = VISIBLE;
+            mSubmitButton.setVisibility(GONE);
+        }
+        mVoiceButton.setVisibility(visibility);
+    }
+
+    private final OnEditorActionListener mOnEditorActionListener = new OnEditorActionListener() {
+
+        /**
+         * Called when the input method default action key is pressed.
+         */
+        public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
+            onSubmitQuery();
+            return true;
+        }
+    };
+
+    private void onTextChanged(CharSequence newText) {
+        CharSequence text = mQueryTextView.getText();
+        mUserQuery = text;
+        boolean hasText = !TextUtils.isEmpty(text);
+        updateSubmitButton(hasText);
+        updateVoiceButton(!hasText);
+        updateCloseButton();
+        updateSubmitArea();
+        if (mOnQueryChangeListener != null && !TextUtils.equals(newText, mOldQueryText)) {
+            mOnQueryChangeListener.onQueryTextChange(newText.toString());
+        }
+        mOldQueryText = newText.toString();
+    }
+
+    private void onSubmitQuery() {
+        CharSequence query = mQueryTextView.getText();
+        if (query != null && TextUtils.getTrimmedLength(query) > 0) {
+            if (mOnQueryChangeListener == null
+                    || !mOnQueryChangeListener.onQueryTextSubmit(query.toString())) {
+                if (mSearchable != null) {
+                    launchQuerySearch(KeyEvent.KEYCODE_UNKNOWN, null, query.toString());
+                    setImeVisibility(false);
+                }
+                dismissSuggestions();
+            }
+        }
+    }
+
+    private void dismissSuggestions() {
+        mQueryTextView.dismissDropDown();
+    }
+
+    private void onCloseClicked() {
+        CharSequence text = mQueryTextView.getText();
+        if (TextUtils.isEmpty(text)) {
+            if (mIconifiedByDefault) {
+                // If the app doesn't override the close behavior
+                if (mOnCloseListener == null || !mOnCloseListener.onClose()) {
+                    // hide the keyboard and remove focus
+                    clearFocus();
+                    // collapse the search field
+                    updateViewsVisibility(true);
+                }
+            }
+        } else {
+            mQueryTextView.setText("");
+            mQueryTextView.requestFocus();
+            setImeVisibility(true);
+        }
+
+    }
+
+    private void onSearchClicked() {
+        updateViewsVisibility(false);
+        mQueryTextView.requestFocus();
+        setImeVisibility(true);
+        if (mOnSearchClickListener != null) {
+            mOnSearchClickListener.onClick(this);
+        }
+    }
+
+    private void onVoiceClicked() {
+        // guard against possible race conditions
+        if (mSearchable == null) {
+            return;
+        }
+        SearchableInfo searchable = mSearchable;
+        try {
+            if (searchable.getVoiceSearchLaunchWebSearch()) {
+                Intent webSearchIntent = createVoiceWebSearchIntent(mVoiceWebSearchIntent,
+                        searchable);
+                getContext().startActivity(webSearchIntent);
+            } else if (searchable.getVoiceSearchLaunchRecognizer()) {
+                Intent appSearchIntent = createVoiceAppSearchIntent(mVoiceAppSearchIntent,
+                        searchable);
+                getContext().startActivity(appSearchIntent);
+            }
+        } catch (ActivityNotFoundException e) {
+            // Should not happen, since we check the availability of
+            // voice search before showing the button. But just in case...
+            Log.w(LOG_TAG, "Could not find voice search activity");
+        }
+    }
+
+    void onTextFocusChanged() {
+        updateViewsVisibility(isIconified());
+        // Delayed update to make sure that the focus has settled down and window focus changes
+        // don't affect it. A synchronous update was not working.
+        postUpdateFocusedState();
+        if (mQueryTextView.hasFocus()) {
+            forceSuggestionQuery();
+        }
+    }
+
+    @Override
+    public void onWindowFocusChanged(boolean hasWindowFocus) {
+        super.onWindowFocusChanged(hasWindowFocus);
+
+        postUpdateFocusedState();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onActionViewCollapsed() {
+        clearFocus();
+        updateViewsVisibility(true);
+        mQueryTextView.setImeOptions(mCollapsedImeOptions);
+        mExpandedInActionView = false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onActionViewExpanded() {
+        if (mExpandedInActionView) return;
+
+        mExpandedInActionView = true;
+        mCollapsedImeOptions = mQueryTextView.getImeOptions();
+        mQueryTextView.setImeOptions(mCollapsedImeOptions | EditorInfo.IME_FLAG_NO_FULLSCREEN);
+        mQueryTextView.setText("");
+        setIconified(false);
+    }
+
+    @Override
+    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
+        super.onInitializeAccessibilityEvent(event);
+        event.setClassName(SearchView.class.getName());
+    }
+
+    @Override
+    public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
+        super.onInitializeAccessibilityNodeInfo(info);
+        info.setClassName(SearchView.class.getName());
+    }
+
+    private void adjustDropDownSizeAndPosition() {
+        if (mDropDownAnchor.getWidth() > 1) {
+            Resources res = getContext().getResources();
+            int anchorPadding = mSearchPlate.getPaddingLeft();
+            Rect dropDownPadding = new Rect();
+            int iconOffset = mIconifiedByDefault
+                    ? res.getDimensionPixelSize(R.dimen.dropdownitem_icon_width)
+                    + res.getDimensionPixelSize(R.dimen.dropdownitem_text_padding_left)
+                    : 0;
+            mQueryTextView.getDropDownBackground().getPadding(dropDownPadding);
+            mQueryTextView.setDropDownHorizontalOffset(-(dropDownPadding.left + iconOffset)
+                    + anchorPadding);
+            mQueryTextView.setDropDownWidth(mDropDownAnchor.getWidth() + dropDownPadding.left
+                    + dropDownPadding.right + iconOffset - (anchorPadding));
+        }
+    }
+
+    private boolean onItemClicked(int position, int actionKey, String actionMsg) {
+        if (mOnSuggestionListener == null
+                || !mOnSuggestionListener.onSuggestionClick(position)) {
+            launchSuggestion(position, KeyEvent.KEYCODE_UNKNOWN, null);
+            setImeVisibility(false);
+            dismissSuggestions();
+            return true;
+        }
+        return false;
+    }
+
+    private boolean onItemSelected(int position) {
+        if (mOnSuggestionListener == null
+                || !mOnSuggestionListener.onSuggestionSelect(position)) {
+            rewriteQueryFromSuggestion(position);
+            return true;
+        }
+        return false;
+    }
+
+    private final OnItemClickListener mOnItemClickListener = new OnItemClickListener() {
+
+        /**
+         * Implements OnItemClickListener
+         */
+        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
+            if (DBG) Log.d(LOG_TAG, "onItemClick() position " + position);
+            onItemClicked(position, KeyEvent.KEYCODE_UNKNOWN, null);
+        }
+    };
+
+    private final OnItemSelectedListener mOnItemSelectedListener = new OnItemSelectedListener() {
+
+        /**
+         * Implements OnItemSelectedListener
+         */
+        public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
+            if (DBG) Log.d(LOG_TAG, "onItemSelected() position " + position);
+            SearchView.this.onItemSelected(position);
+        }
+
+        /**
+         * Implements OnItemSelectedListener
+         */
+        public void onNothingSelected(AdapterView<?> parent) {
+            if (DBG)
+                Log.d(LOG_TAG, "onNothingSelected()");
+        }
+    };
+
+    /**
+     * Query rewriting.
+     */
+    private void rewriteQueryFromSuggestion(int position) {
+        CharSequence oldQuery = mQueryTextView.getText();
+        Cursor c = mSuggestionsAdapter.getCursor();
+        if (c == null) {
+            return;
+        }
+        if (c.moveToPosition(position)) {
+            // Get the new query from the suggestion.
+            CharSequence newQuery = mSuggestionsAdapter.convertToString(c);
+            if (newQuery != null) {
+                // The suggestion rewrites the query.
+                // Update the text field, without getting new suggestions.
+                setQuery(newQuery);
+            } else {
+                // The suggestion does not rewrite the query, restore the user's query.
+                setQuery(oldQuery);
+            }
+        } else {
+            // We got a bad position, restore the user's query.
+            setQuery(oldQuery);
+        }
+    }
+
+    /**
+     * Launches an intent based on a suggestion.
+     *
+     * @param position The index of the suggestion to create the intent from.
+     * @param actionKey The key code of the action key that was pressed,
+     *        or {@link KeyEvent#KEYCODE_UNKNOWN} if none.
+     * @param actionMsg The message for the action key that was pressed,
+     *        or <code>null</code> if none.
+     * @return true if a successful launch, false if could not (e.g. bad position).
+     */
+    private boolean launchSuggestion(int position, int actionKey, String actionMsg) {
+        Cursor c = mSuggestionsAdapter.getCursor();
+        if ((c != null) && c.moveToPosition(position)) {
+
+            Intent intent = createIntentFromSuggestion(c, actionKey, actionMsg);
+
+            // launch the intent
+            launchIntent(intent);
+
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Launches an intent, including any special intent handling.
+     */
+    private void launchIntent(Intent intent) {
+        if (intent == null) {
+            return;
+        }
+        try {
+            // If the intent was created from a suggestion, it will always have an explicit
+            // component here.
+            getContext().startActivity(intent);
+        } catch (RuntimeException ex) {
+            Log.e(LOG_TAG, "Failed launch activity: " + intent, ex);
+        }
+    }
+
+    /**
+     * Sets the text in the query box, without updating the suggestions.
+     */
+    private void setQuery(CharSequence query) {
+        mQueryTextView.setText(query, true);
+        // Move the cursor to the end
+        mQueryTextView.setSelection(TextUtils.isEmpty(query) ? 0 : query.length());
+    }
+
+    private void launchQuerySearch(int actionKey, String actionMsg, String query) {
+        String action = Intent.ACTION_SEARCH;
+        Intent intent = createIntent(action, null, null, query, actionKey, actionMsg);
+        getContext().startActivity(intent);
+    }
+
+    /**
+     * Constructs an intent from the given information and the search dialog state.
+     *
+     * @param action Intent action.
+     * @param data Intent data, or <code>null</code>.
+     * @param extraData Data for {@link SearchManager#EXTRA_DATA_KEY} or <code>null</code>.
+     * @param query Intent query, or <code>null</code>.
+     * @param actionKey The key code of the action key that was pressed,
+     *        or {@link KeyEvent#KEYCODE_UNKNOWN} if none.
+     * @param actionMsg The message for the action key that was pressed,
+     *        or <code>null</code> if none.
+     * @param mode The search mode, one of the acceptable values for
+     *             {@link SearchManager#SEARCH_MODE}, or {@code null}.
+     * @return The intent.
+     */
+    private Intent createIntent(String action, Uri data, String extraData, String query,
+            int actionKey, String actionMsg) {
+        // Now build the Intent
+        Intent intent = new Intent(action);
+        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        // We need CLEAR_TOP to avoid reusing an old task that has other activities
+        // on top of the one we want. We don't want to do this in in-app search though,
+        // as it can be destructive to the activity stack.
+        if (data != null) {
+            intent.setData(data);
+        }
+        intent.putExtra(SearchManager.USER_QUERY, mUserQuery);
+        if (query != null) {
+            intent.putExtra(SearchManager.QUERY, query);
+        }
+        if (extraData != null) {
+            intent.putExtra(SearchManager.EXTRA_DATA_KEY, extraData);
+        }
+        if (mAppSearchData != null) {
+            intent.putExtra(SearchManager.APP_DATA, mAppSearchData);
+        }
+        if (actionKey != KeyEvent.KEYCODE_UNKNOWN) {
+            intent.putExtra(SearchManager.ACTION_KEY, actionKey);
+            intent.putExtra(SearchManager.ACTION_MSG, actionMsg);
+        }
+        intent.setComponent(mSearchable.getSearchActivity());
+        return intent;
+    }
+
+    /**
+     * Create and return an Intent that can launch the voice search activity for web search.
+     */
+    private Intent createVoiceWebSearchIntent(Intent baseIntent, SearchableInfo searchable) {
+        Intent voiceIntent = new Intent(baseIntent);
+        ComponentName searchActivity = searchable.getSearchActivity();
+        voiceIntent.putExtra(RecognizerIntent.EXTRA_CALLING_PACKAGE, searchActivity == null ? null
+                : searchActivity.flattenToShortString());
+        return voiceIntent;
+    }
+
+    /**
+     * Create and return an Intent that can launch the voice search activity, perform a specific
+     * voice transcription, and forward the results to the searchable activity.
+     *
+     * @param baseIntent The voice app search intent to start from
+     * @return A completely-configured intent ready to send to the voice search activity
+     */
+    private Intent createVoiceAppSearchIntent(Intent baseIntent, SearchableInfo searchable) {
+        ComponentName searchActivity = searchable.getSearchActivity();
+
+        // create the necessary intent to set up a search-and-forward operation
+        // in the voice search system.   We have to keep the bundle separate,
+        // because it becomes immutable once it enters the PendingIntent
+        Intent queryIntent = new Intent(Intent.ACTION_SEARCH);
+        queryIntent.setComponent(searchActivity);
+        PendingIntent pending = PendingIntent.getActivity(getContext(), 0, queryIntent,
+                PendingIntent.FLAG_ONE_SHOT);
+
+        // Now set up the bundle that will be inserted into the pending intent
+        // when it's time to do the search.  We always build it here (even if empty)
+        // because the voice search activity will always need to insert "QUERY" into
+        // it anyway.
+        Bundle queryExtras = new Bundle();
+
+        // Now build the intent to launch the voice search.  Add all necessary
+        // extras to launch the voice recognizer, and then all the necessary extras
+        // to forward the results to the searchable activity
+        Intent voiceIntent = new Intent(baseIntent);
+
+        // Add all of the configuration options supplied by the searchable's metadata
+        String languageModel = RecognizerIntent.LANGUAGE_MODEL_FREE_FORM;
+        String prompt = null;
+        String language = null;
+        int maxResults = 1;
+
+        Resources resources = getResources();
+        if (searchable.getVoiceLanguageModeId() != 0) {
+            languageModel = resources.getString(searchable.getVoiceLanguageModeId());
+        }
+        if (searchable.getVoicePromptTextId() != 0) {
+            prompt = resources.getString(searchable.getVoicePromptTextId());
+        }
+        if (searchable.getVoiceLanguageId() != 0) {
+            language = resources.getString(searchable.getVoiceLanguageId());
+        }
+        if (searchable.getVoiceMaxResults() != 0) {
+            maxResults = searchable.getVoiceMaxResults();
+        }
+        voiceIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, languageModel);
+        voiceIntent.putExtra(RecognizerIntent.EXTRA_PROMPT, prompt);
+        voiceIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE, language);
+        voiceIntent.putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, maxResults);
+        voiceIntent.putExtra(RecognizerIntent.EXTRA_CALLING_PACKAGE, searchActivity == null ? null
+                : searchActivity.flattenToShortString());
+
+        // Add the values that configure forwarding the results
+        voiceIntent.putExtra(RecognizerIntent.EXTRA_RESULTS_PENDINGINTENT, pending);
+        voiceIntent.putExtra(RecognizerIntent.EXTRA_RESULTS_PENDINGINTENT_BUNDLE, queryExtras);
+
+        return voiceIntent;
+    }
+
+    /**
+     * When a particular suggestion has been selected, perform the various lookups required
+     * to use the suggestion.  This includes checking the cursor for suggestion-specific data,
+     * and/or falling back to the XML for defaults;  It also creates REST style Uri data when
+     * the suggestion includes a data id.
+     *
+     * @param c The suggestions cursor, moved to the row of the user's selection
+     * @param actionKey The key code of the action key that was pressed,
+     *        or {@link KeyEvent#KEYCODE_UNKNOWN} if none.
+     * @param actionMsg The message for the action key that was pressed,
+     *        or <code>null</code> if none.
+     * @return An intent for the suggestion at the cursor's position.
+     */
+    private Intent createIntentFromSuggestion(Cursor c, int actionKey, String actionMsg) {
+        try {
+            // use specific action if supplied, or default action if supplied, or fixed default
+            String action = getColumnString(c, SearchManager.SUGGEST_COLUMN_INTENT_ACTION);
+
+            if (action == null) {
+                action = mSearchable.getSuggestIntentAction();
+            }
+            if (action == null) {
+                action = Intent.ACTION_SEARCH;
+            }
+
+            // use specific data if supplied, or default data if supplied
+            String data = getColumnString(c, SearchManager.SUGGEST_COLUMN_INTENT_DATA);
+            if (data == null) {
+                data = mSearchable.getSuggestIntentData();
+            }
+            // then, if an ID was provided, append it.
+            if (data != null) {
+                String id = getColumnString(c, SearchManager.SUGGEST_COLUMN_INTENT_DATA_ID);
+                if (id != null) {
+                    data = data + "/" + Uri.encode(id);
+                }
+            }
+            Uri dataUri = (data == null) ? null : Uri.parse(data);
+
+            String query = getColumnString(c, SearchManager.SUGGEST_COLUMN_QUERY);
+            String extraData = getColumnString(c, SearchManager.SUGGEST_COLUMN_INTENT_EXTRA_DATA);
+
+            return createIntent(action, dataUri, extraData, query, actionKey, actionMsg);
+        } catch (RuntimeException e ) {
+            int rowNum;
+            try {                       // be really paranoid now
+                rowNum = c.getPosition();
+            } catch (RuntimeException e2 ) {
+                rowNum = -1;
+            }
+            Log.w(LOG_TAG, "Search Suggestions cursor at row " + rowNum +
+                            " returned exception" + e.toString());
+            return null;
+        }
+    }
+
+    private void forceSuggestionQuery() {
+        mQueryTextView.doBeforeTextChanged();
+        mQueryTextView.doAfterTextChanged();
+    }
+
+    static boolean isLandscapeMode(Context context) {
+        return context.getResources().getConfiguration().orientation
+                == Configuration.ORIENTATION_LANDSCAPE;
+    }
+
+    /**
+     * Callback to watch the text field for empty/non-empty
+     */
+    private TextWatcher mTextWatcher = new TextWatcher() {
+
+        public void beforeTextChanged(CharSequence s, int start, int before, int after) { }
+
+        public void onTextChanged(CharSequence s, int start,
+                int before, int after) {
+            SearchView.this.onTextChanged(s);
+        }
+
+        public void afterTextChanged(Editable s) {
+        }
+    };
+
+    /**
+     * Local subclass for AutoCompleteTextView.
+     * @hide
+     */
+    public static class SearchAutoComplete extends AutoCompleteTextView {
+
+        private int mThreshold;
+        private SearchView mSearchView;
+
+        public SearchAutoComplete(Context context) {
+            super(context);
+            mThreshold = getThreshold();
+        }
+
+        public SearchAutoComplete(Context context, AttributeSet attrs) {
+            super(context, attrs);
+            mThreshold = getThreshold();
+        }
+
+        public SearchAutoComplete(Context context, AttributeSet attrs, int defStyle) {
+            super(context, attrs, defStyle);
+            mThreshold = getThreshold();
+        }
+
+        void setSearchView(SearchView searchView) {
+            mSearchView = searchView;
+        }
+
+        @Override
+        public void setThreshold(int threshold) {
+            super.setThreshold(threshold);
+            mThreshold = threshold;
+        }
+
+        /**
+         * Returns true if the text field is empty, or contains only whitespace.
+         */
+        private boolean isEmpty() {
+            return TextUtils.getTrimmedLength(getText()) == 0;
+        }
+
+        /**
+         * We override this method to avoid replacing the query box text when a
+         * suggestion is clicked.
+         */
+        @Override
+        protected void replaceText(CharSequence text) {
+        }
+
+        /**
+         * We override this method to avoid an extra onItemClick being called on
+         * the drop-down's OnItemClickListener by
+         * {@link AutoCompleteTextView#onKeyUp(int, KeyEvent)} when an item is
+         * clicked with the trackball.
+         */
+        @Override
+        public void performCompletion() {
+        }
+
+        /**
+         * We override this method to be sure and show the soft keyboard if
+         * appropriate when the TextView has focus.
+         */
+        @Override
+        public void onWindowFocusChanged(boolean hasWindowFocus) {
+            super.onWindowFocusChanged(hasWindowFocus);
+
+            if (hasWindowFocus && mSearchView.hasFocus() && getVisibility() == VISIBLE) {
+                InputMethodManager inputManager = (InputMethodManager) getContext()
+                        .getSystemService(Context.INPUT_METHOD_SERVICE);
+                inputManager.showSoftInput(this, 0);
+                // If in landscape mode, then make sure that
+                // the ime is in front of the dropdown.
+                if (isLandscapeMode(getContext())) {
+                    ensureImeVisible(true);
+                }
+            }
+        }
+
+        @Override
+        protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) {
+            super.onFocusChanged(focused, direction, previouslyFocusedRect);
+            mSearchView.onTextFocusChanged();
+        }
+
+        /**
+         * We override this method so that we can allow a threshold of zero,
+         * which ACTV does not.
+         */
+        @Override
+        public boolean enoughToFilter() {
+            return mThreshold <= 0 || super.enoughToFilter();
+        }
+
+        @Override
+        public boolean onKeyPreIme(int keyCode, KeyEvent event) {
+            if (keyCode == KeyEvent.KEYCODE_BACK) {
+                // special case for the back key, we do not even try to send it
+                // to the drop down list but instead, consume it immediately
+                if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
+                    KeyEvent.DispatcherState state = getKeyDispatcherState();
+                    if (state != null) {
+                        state.startTracking(event, this);
+                    }
+                    return true;
+                } else if (event.getAction() == KeyEvent.ACTION_UP) {
+                    KeyEvent.DispatcherState state = getKeyDispatcherState();
+                    if (state != null) {
+                        state.handleUpEvent(event);
+                    }
+                    if (event.isTracking() && !event.isCanceled()) {
+                        mSearchView.clearFocus();
+                        mSearchView.setImeVisibility(false);
+                        return true;
+                    }
+                }
+            }
+            return super.onKeyPreIme(keyCode, event);
+        }
+
+    }
+}
diff --git a/src/frameworks/base/core/java/com/android/internal/statusbar/IStatusBar.aidl b/src/frameworks/base/core/java/com/android/internal/statusbar/IStatusBar.aidl
new file mode 100644
index 0000000..294d4c4
--- /dev/null
+++ b/src/frameworks/base/core/java/com/android/internal/statusbar/IStatusBar.aidl
@@ -0,0 +1,41 @@
+/**
+ * Copyright (c) 2007, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ *
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License.
+ */
+ 
+package com.android.internal.statusbar;
+
+import com.android.internal.statusbar.StatusBarIcon;
+import com.android.internal.statusbar.StatusBarNotification;
+
+/** @hide */
+oneway interface IStatusBar
+{
+    void setIcon(int index, in StatusBarIcon icon);
+    void removeIcon(int index);
+    void addNotification(IBinder key, in StatusBarNotification notification);
+    void updateNotification(IBinder key, in StatusBarNotification notification);
+    void removeNotification(IBinder key);
+    void disable(int state);
+    void animateExpand();
+    void animateCollapse();
+    void setSystemUiVisibility(int vis, int mask);
+    void topAppWindowChanged(boolean menuVisible);
+    void setImeWindowStatus(in IBinder token, int vis, int backDisposition);
+    void setHardKeyboardStatus(boolean available, boolean enabled);
+    void toggleRecentApps();
+    void preloadRecentApps();
+    void cancelPreloadRecentApps();
+}
+
diff --git a/src/frameworks/base/core/java/com/android/internal/statusbar/IStatusBarService.aidl b/src/frameworks/base/core/java/com/android/internal/statusbar/IStatusBarService.aidl
new file mode 100644
index 0000000..c64f170
--- /dev/null
+++ b/src/frameworks/base/core/java/com/android/internal/statusbar/IStatusBarService.aidl
@@ -0,0 +1,52 @@
+/**
+ * Copyright (c) 2007, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); 
+ * you may not use this file except in compliance with the License. 
+ * You may obtain a copy of the License at 
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0 
+ *
+ * Unless required by applicable law or agreed to in writing, software 
+ * distributed under the License is distributed on an "AS IS" BASIS, 
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+ * See the License for the specific language governing permissions and 
+ * limitations under the License.
+ */
+
+package com.android.internal.statusbar;
+
+import com.android.internal.statusbar.IStatusBar;
+import com.android.internal.statusbar.StatusBarIcon;
+import com.android.internal.statusbar.StatusBarIconList;
+import com.android.internal.statusbar.StatusBarNotification;
+
+/** @hide */
+interface IStatusBarService
+{
+    void expand();
+    void collapse();
+    void disable(int what, IBinder token, String pkg);
+    void setIcon(String slot, String iconPackage, int iconId, int iconLevel, String contentDescription);
+    void setIconVisibility(String slot, boolean visible);
+    void removeIcon(String slot);
+    void topAppWindowChanged(boolean menuVisible);
+    void setImeWindowStatus(in IBinder token, int vis, int backDisposition);
+
+    // ---- Methods below are for use by the status bar policy services ----
+    // You need the STATUS_BAR_SERVICE permission
+    void registerStatusBar(IStatusBar callbacks, out StatusBarIconList iconList,
+            out List<IBinder> notificationKeys, out List<StatusBarNotification> notifications,
+            out int[] switches, out List<IBinder> binders);
+    void onPanelRevealed();
+    void onNotificationClick(String pkg, String tag, int id);
+    void onNotificationError(String pkg, String tag, int id,
+            int uid, int initialPid, String message);
+    void onClearAllNotifications();
+    void onNotificationClear(String pkg, String tag, int id);
+    void setSystemUiVisibility(int vis, int mask);
+    void setHardKeyboardEnabled(boolean enabled);
+    void toggleRecentApps();
+    void preloadRecentApps();
+    void cancelPreloadRecentApps();
+}
diff --git a/src/frameworks/base/core/java/com/android/internal/view/menu/ListMenuItemView.java b/src/frameworks/base/core/java/com/android/internal/view/menu/ListMenuItemView.java
new file mode 100644
index 0000000..df579c6
--- /dev/null
+++ b/src/frameworks/base/core/java/com/android/internal/view/menu/ListMenuItemView.java
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.view.menu;
+
+import android.content.Context;
+import android.content.res.TypedArray;
+import android.graphics.drawable.Drawable;
+import android.util.AttributeSet;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.CheckBox;
+import android.widget.CompoundButton;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.RadioButton;
+import android.widget.TextView;
+
+/**
+ * The item view for each item in the ListView-based MenuViews.
+ */
+public class ListMenuItemView extends LinearLayout implements MenuView.ItemView {
+    private static final String TAG = "ListMenuItemView";
+    private MenuItemImpl mItemData; 
+    
+    private ImageView mIconView;
+    private RadioButton mRadioButton;
+    private TextView mTitleView;
+    private CheckBox mCheckBox;
+    private TextView mShortcutView;
+    
+    private Drawable mBackground;
+    private int mTextAppearance;
+    private Context mTextAppearanceContext;
+    private boolean mPreserveIconSpacing;
+    
+    private int mMenuType;
+    
+    private LayoutInflater mInflater;
+
+    private boolean mForceShowIcon;
+
+    public ListMenuItemView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs);
+    
+        TypedArray a =
+            context.obtainStyledAttributes(
+                attrs, com.android.internal.R.styleable.MenuView, defStyle, 0);
+        
+        mBackground = a.getDrawable(com.android.internal.R.styleable.MenuView_itemBackground);
+        mTextAppearance = a.getResourceId(com.android.internal.R.styleable.
+                                          MenuView_itemTextAppearance, -1);
+        mPreserveIconSpacing = a.getBoolean(
+                com.android.internal.R.styleable.MenuView_preserveIconSpacing, false);
+        mTextAppearanceContext = context;
+        
+        a.recycle();
+    }
+
+    public ListMenuItemView(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    @Override
+    protected void onFinishInflate() {
+        super.onFinishInflate();
+        
+        setBackgroundDrawable(mBackground);
+        
+        mTitleView = (TextView) findViewById(com.android.internal.R.id.title);
+        if (mTextAppearance != -1) {
+            mTitleView.setTextAppearance(mTextAppearanceContext,
+                                         mTextAppearance);
+        }
+        
+        mShortcutView = (TextView) findViewById(com.android.internal.R.id.shortcut);
+    }
+
+    public void initialize(MenuItemImpl itemData, int menuType) {
+        mItemData = itemData;
+        mMenuType = menuType;
+
+        setVisibility(itemData.isVisible() ? View.VISIBLE : View.GONE);
+        
+        setTitle(itemData.getTitleForItemView(this));
+        setCheckable(itemData.isCheckable());
+        setShortcut(itemData.shouldShowShortcut(), itemData.getShortcut());
+        setIcon(itemData.getIcon());
+        setEnabled(itemData.isEnabled());
+    }
+
+    public void setForceShowIcon(boolean forceShow) {
+        mPreserveIconSpacing = mForceShowIcon = forceShow;
+    }
+
+    public void setTitle(CharSequence title) {
+        if (title != null) {
+            mTitleView.setText(title);
+            
+            if (mTitleView.getVisibility() != VISIBLE) mTitleView.setVisibility(VISIBLE);
+        } else {
+            if (mTitleView.getVisibility() != GONE) mTitleView.setVisibility(GONE);
+        }
+    }
+    
+    public MenuItemImpl getItemData() {
+        return mItemData;
+    }
+
+    public void setCheckable(boolean checkable) {
+        if (!checkable && mRadioButton == null && mCheckBox == null) {
+            return;
+        }
+        
+        // Depending on whether its exclusive check or not, the checkbox or
+        // radio button will be the one in use (and the other will be otherCompoundButton)
+        final CompoundButton compoundButton;
+        final CompoundButton otherCompoundButton; 
+
+        if (mItemData.isExclusiveCheckable()) {
+            if (mRadioButton == null) {
+                insertRadioButton();
+            }
+            compoundButton = mRadioButton;
+            otherCompoundButton = mCheckBox;
+        } else {
+            if (mCheckBox == null) {
+                insertCheckBox();
+            }
+            compoundButton = mCheckBox;
+            otherCompoundButton = mRadioButton;
+        }
+        
+        if (checkable) {
+            compoundButton.setChecked(mItemData.isChecked());
+            
+            final int newVisibility = checkable ? VISIBLE : GONE;
+            if (compoundButton.getVisibility() != newVisibility) {
+                compoundButton.setVisibility(newVisibility);
+            }
+            
+            // Make sure the other compound button isn't visible
+            if (otherCompoundButton != null && otherCompoundButton.getVisibility() != GONE) {
+                otherCompoundButton.setVisibility(GONE);
+            }
+        } else {
+            if (mCheckBox != null) mCheckBox.setVisibility(GONE);
+            if (mRadioButton != null) mRadioButton.setVisibility(GONE);
+        }
+    }
+    
+    public void setChecked(boolean checked) {
+        CompoundButton compoundButton;
+        
+        if (mItemData.isExclusiveCheckable()) {
+            if (mRadioButton == null) {
+                insertRadioButton();
+            }
+            compoundButton = mRadioButton;
+        } else {
+            if (mCheckBox == null) {
+                insertCheckBox();
+            }
+            compoundButton = mCheckBox;
+        }
+        
+        compoundButton.setChecked(checked);
+    }
+
+    public void setShortcut(boolean showShortcut, char shortcutKey) {
+        final int newVisibility = (showShortcut && mItemData.shouldShowShortcut())
+                ? VISIBLE : GONE;
+
+        if (newVisibility == VISIBLE) {
+            mShortcutView.setText(mItemData.getShortcutLabel());
+        }
+
+        if (mShortcutView.getVisibility() != newVisibility) {
+            mShortcutView.setVisibility(newVisibility);
+        }
+    }
+    
+    public void setIcon(Drawable icon) {
+        final boolean showIcon = mItemData.shouldShowIcon() || mForceShowIcon;
+        if (!showIcon && !mPreserveIconSpacing) {
+            return;
+        }
+        
+        if (mIconView == null && icon == null && !mPreserveIconSpacing) {
+            return;
+        }
+        
+        if (mIconView == null) {
+            insertIconView();
+        }
+        
+        if (icon != null || mPreserveIconSpacing) {
+            mIconView.setImageDrawable(showIcon ? icon : null);
+
+            if (mIconView.getVisibility() != VISIBLE) {
+                mIconView.setVisibility(VISIBLE);
+            }
+        } else {
+            mIconView.setVisibility(GONE);
+        }
+    }
+    
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        if (mIconView != null && mPreserveIconSpacing) {
+            // Enforce minimum icon spacing
+            ViewGroup.LayoutParams lp = getLayoutParams();
+            LayoutParams iconLp = (LayoutParams) mIconView.getLayoutParams();
+            if (lp.height > 0 && iconLp.width <= 0) {
+                iconLp.width = lp.height;
+            }
+        }
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+    }
+
+    private void insertIconView() {
+        LayoutInflater inflater = getInflater();
+        mIconView = (ImageView) inflater.inflate(com.android.internal.R.layout.list_menu_item_icon,
+                this, false);
+        addView(mIconView, 0);
+    }
+    
+    private void insertRadioButton() {
+        LayoutInflater inflater = getInflater();
+        mRadioButton =
+                (RadioButton) inflater.inflate(com.android.internal.R.layout.list_menu_item_radio,
+                this, false);
+        addView(mRadioButton);
+    }
+    
+    private void insertCheckBox() {
+        LayoutInflater inflater = getInflater();
+        mCheckBox =
+                (CheckBox) inflater.inflate(com.android.internal.R.layout.list_menu_item_checkbox,
+                this, false);
+        addView(mCheckBox);
+    }
+
+    public boolean prefersCondensedTitle() {
+        return false;
+    }
+
+    public boolean showsIcon() {
+        return mForceShowIcon;
+    }
+    
+    private LayoutInflater getInflater() {
+        if (mInflater == null) {
+            mInflater = LayoutInflater.from(mContext);
+        }
+        return mInflater;
+    }
+}
diff --git a/src/frameworks/base/core/java/com/android/internal/view/menu/MenuBuilder.java b/src/frameworks/base/core/java/com/android/internal/view/menu/MenuBuilder.java
new file mode 100644
index 0000000..458ea2f
--- /dev/null
+++ b/src/frameworks/base/core/java/com/android/internal/view/menu/MenuBuilder.java
@@ -0,0 +1,1270 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.view.menu;
+
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.graphics.drawable.Drawable;
+import android.os.Bundle;
+import android.os.Parcelable;
+import android.util.SparseArray;
+import android.view.ActionProvider;
+import android.view.ContextMenu.ContextMenuInfo;
+import android.view.KeyCharacterMap;
+import android.view.KeyEvent;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.SubMenu;
+import android.view.View;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+/**
+ * Implementation of the {@link android.view.Menu} interface for creating a
+ * standard menu UI.
+ */
+public class MenuBuilder implements Menu {
+    private static final String TAG = "MenuBuilder";
+
+    private static final String PRESENTER_KEY = "android:menu:presenters";
+    private static final String ACTION_VIEW_STATES_KEY = "android:menu:actionviewstates";
+    private static final String EXPANDED_ACTION_VIEW_ID = "android:menu:expandedactionview";
+
+    private static final int[]  sCategoryToOrder = new int[] {
+        1, /* No category */
+        4, /* CONTAINER */
+        5, /* SYSTEM */
+        3, /* SECONDARY */
+        2, /* ALTERNATIVE */
+        0, /* SELECTED_ALTERNATIVE */
+    };
+
+    private final Context mContext;
+    private final Resources mResources;
+
+    /**
+     * Whether the shortcuts should be qwerty-accessible. Use isQwertyMode()
+     * instead of accessing this directly.
+     */
+    private boolean mQwertyMode;
+
+    /**
+     * Whether the shortcuts should be visible on menus. Use isShortcutsVisible()
+     * instead of accessing this directly.
+     */ 
+    private boolean mShortcutsVisible;
+    
+    /**
+     * Callback that will receive the various menu-related events generated by
+     * this class. Use getCallback to get a reference to the callback.
+     */
+    private Callback mCallback;
+    
+    /** Contains all of the items for this menu */
+    private ArrayList<MenuItemImpl> mItems;
+
+    /** Contains only the items that are currently visible.  This will be created/refreshed from
+     * {@link #getVisibleItems()} */
+    private ArrayList<MenuItemImpl> mVisibleItems;
+    /**
+     * Whether or not the items (or any one item's shown state) has changed since it was last
+     * fetched from {@link #getVisibleItems()}
+     */ 
+    private boolean mIsVisibleItemsStale;
+    
+    /**
+     * Contains only the items that should appear in the Action Bar, if present.
+     */
+    private ArrayList<MenuItemImpl> mActionItems;
+    /**
+     * Contains items that should NOT appear in the Action Bar, if present.
+     */
+    private ArrayList<MenuItemImpl> mNonActionItems;
+
+    /**
+     * Whether or not the items (or any one item's action state) has changed since it was
+     * last fetched.
+     */
+    private boolean mIsActionItemsStale;
+
+    /**
+     * Default value for how added items should show in the action list.
+     */
+    private int mDefaultShowAsAction = MenuItem.SHOW_AS_ACTION_NEVER;
+
+    /**
+     * Current use case is Context Menus: As Views populate the context menu, each one has
+     * extra information that should be passed along.  This is the current menu info that
+     * should be set on all items added to this menu.
+     */
+    private ContextMenuInfo mCurrentMenuInfo;
+    
+    /** Header title for menu types that have a header (context and submenus) */
+    CharSequence mHeaderTitle;
+    /** Header icon for menu types that have a header and support icons (context) */
+    Drawable mHeaderIcon;
+    /** Header custom view for menu types that have a header and support custom views (context) */
+    View mHeaderView;
+
+    /**
+     * Contains the state of the View hierarchy for all menu views when the menu
+     * was frozen.
+     */
+    private SparseArray<Parcelable> mFrozenViewStates;
+
+    /**
+     * Prevents onItemsChanged from doing its junk, useful for batching commands
+     * that may individually call onItemsChanged.
+     */
+    private boolean mPreventDispatchingItemsChanged = false;
+    private boolean mItemsChangedWhileDispatchPrevented = false;
+    
+    private boolean mOptionalIconsVisible = false;
+
+    private boolean mIsClosing = false;
+
+    private ArrayList<MenuItemImpl> mTempShortcutItemList = new ArrayList<MenuItemImpl>();
+
+    private CopyOnWriteArrayList<WeakReference<MenuPresenter>> mPresenters =
+            new CopyOnWriteArrayList<WeakReference<MenuPresenter>>();
+
+    /**
+     * Currently expanded menu item; must be collapsed when we clear.
+     */
+    private MenuItemImpl mExpandedItem;
+    
+    /**
+     * Called by menu to notify of close and selection changes.
+     */
+    public interface Callback {
+        /**
+         * Called when a menu item is selected.
+         * @param menu The menu that is the parent of the item
+         * @param item The menu item that is selected
+         * @return whether the menu item selection was handled
+         */
+        public boolean onMenuItemSelected(MenuBuilder menu, MenuItem item);
+        
+        /**
+         * Called when the mode of the menu changes (for example, from icon to expanded).
+         * 
+         * @param menu the menu that has changed modes
+         */
+        public void onMenuModeChange(MenuBuilder menu);
+    }
+
+    /**
+     * Called by menu items to execute their associated action
+     */
+    public interface ItemInvoker {
+        public boolean invokeItem(MenuItemImpl item);
+    }
+
+    public MenuBuilder(Context context) {
+        mContext = context;
+        mResources = context.getResources();
+        
+        mItems = new ArrayList<MenuItemImpl>();
+        
+        mVisibleItems = new ArrayList<MenuItemImpl>();
+        mIsVisibleItemsStale = true;
+        
+        mActionItems = new ArrayList<MenuItemImpl>();
+        mNonActionItems = new ArrayList<MenuItemImpl>();
+        mIsActionItemsStale = true;
+        
+        setShortcutsVisibleInner(true);
+    }
+    
+    public MenuBuilder setDefaultShowAsAction(int defaultShowAsAction) {
+        mDefaultShowAsAction = defaultShowAsAction;
+        return this;
+    }
+
+    /**
+     * Add a presenter to this menu. This will only hold a WeakReference;
+     * you do not need to explicitly remove a presenter, but you can using
+     * {@link #removeMenuPresenter(MenuPresenter)}.
+     *
+     * @param presenter The presenter to add
+     */
+    public void addMenuPresenter(MenuPresenter presenter) {
+        mPresenters.add(new WeakReference<MenuPresenter>(presenter));
+        presenter.initForMenu(mContext, this);
+        mIsActionItemsStale = true;
+    }
+
+    /**
+     * Remove a presenter from this menu. That presenter will no longer
+     * receive notifications of updates to this menu's data.
+     *
+     * @param presenter The presenter to remove
+     */
+    public void removeMenuPresenter(MenuPresenter presenter) {
+        for (WeakReference<MenuPresenter> ref : mPresenters) {
+            final MenuPresenter item = ref.get();
+            if (item == null || item == presenter) {
+                mPresenters.remove(ref);
+            }
+        }
+    }
+    
+    private void dispatchPresenterUpdate(boolean cleared) {
+        if (mPresenters.isEmpty()) return;
+
+        stopDispatchingItemsChanged();
+        for (WeakReference<MenuPresenter> ref : mPresenters) {
+            final MenuPresenter presenter = ref.get();
+            if (presenter == null) {
+                mPresenters.remove(ref);
+            } else {
+                presenter.updateMenuView(cleared);
+            }
+        }
+        startDispatchingItemsChanged();
+    }
+    
+    private boolean dispatchSubMenuSelected(SubMenuBuilder subMenu) {
+        if (mPresenters.isEmpty()) return false;
+
+        boolean result = false;
+
+        for (WeakReference<MenuPresenter> ref : mPresenters) {
+            final MenuPresenter presenter = ref.get();
+            if (presenter == null) {
+                mPresenters.remove(ref);
+            } else if (!result) {
+                result = presenter.onSubMenuSelected(subMenu);
+            }
+        }
+        return result;
+    }
+
+    private void dispatchSaveInstanceState(Bundle outState) {
+        if (mPresenters.isEmpty()) return;
+
+        SparseArray<Parcelable> presenterStates = new SparseArray<Parcelable>();
+
+        for (WeakReference<MenuPresenter> ref : mPresenters) {
+            final MenuPresenter presenter = ref.get();
+            if (presenter == null) {
+                mPresenters.remove(ref);
+            } else {
+                final int id = presenter.getId();
+                if (id > 0) {
+                    final Parcelable state = presenter.onSaveInstanceState();
+                    if (state != null) {
+                        presenterStates.put(id, state);
+                    }
+                }
+            }
+        }
+
+        outState.putSparseParcelableArray(PRESENTER_KEY, presenterStates);
+    }
+
+    private void dispatchRestoreInstanceState(Bundle state) {
+        SparseArray<Parcelable> presenterStates = state.getSparseParcelableArray(PRESENTER_KEY);
+
+        if (presenterStates == null || mPresenters.isEmpty()) return;
+
+        for (WeakReference<MenuPresenter> ref : mPresenters) {
+            final MenuPresenter presenter = ref.get();
+            if (presenter == null) {
+                mPresenters.remove(ref);
+            } else {
+                final int id = presenter.getId();
+                if (id > 0) {
+                    Parcelable parcel = presenterStates.get(id);
+                    if (parcel != null) {
+                        presenter.onRestoreInstanceState(parcel);
+                    }
+                }
+            }
+        }
+    }
+
+    public void savePresenterStates(Bundle outState) {
+        dispatchSaveInstanceState(outState);
+    }
+
+    public void restorePresenterStates(Bundle state) {
+        dispatchRestoreInstanceState(state);
+    }
+
+    public void saveActionViewStates(Bundle outStates) {
+        SparseArray<Parcelable> viewStates = null;
+
+        final int itemCount = size();
+        for (int i = 0; i < itemCount; i++) {
+            final MenuItem item = getItem(i);
+            final View v = item.getActionView();
+            if (v != null && v.getId() != View.NO_ID) {
+                if (viewStates == null) {
+                    viewStates = new SparseArray<Parcelable>();
+                }
+                v.saveHierarchyState(viewStates);
+                if (item.isActionViewExpanded()) {
+                    outStates.putInt(EXPANDED_ACTION_VIEW_ID, item.getItemId());
+                }
+            }
+            if (item.hasSubMenu()) {
+                final SubMenuBuilder subMenu = (SubMenuBuilder) item.getSubMenu();
+                subMenu.saveActionViewStates(outStates);
+            }
+        }
+
+        if (viewStates != null) {
+            outStates.putSparseParcelableArray(getActionViewStatesKey(), viewStates);
+        }
+    }
+
+    public void restoreActionViewStates(Bundle states) {
+        if (states == null) {
+            return;
+        }
+
+        SparseArray<Parcelable> viewStates = states.getSparseParcelableArray(
+                getActionViewStatesKey());
+
+        final int itemCount = size();
+        for (int i = 0; i < itemCount; i++) {
+            final MenuItem item = getItem(i);
+            final View v = item.getActionView();
+            if (v != null && v.getId() != View.NO_ID) {
+                v.restoreHierarchyState(viewStates);
+            }
+            if (item.hasSubMenu()) {
+                final SubMenuBuilder subMenu = (SubMenuBuilder) item.getSubMenu();
+                subMenu.restoreActionViewStates(states);
+            }
+        }
+
+        final int expandedId = states.getInt(EXPANDED_ACTION_VIEW_ID);
+        if (expandedId > 0) {
+            MenuItem itemToExpand = findItem(expandedId);
+            if (itemToExpand != null) {
+                itemToExpand.expandActionView();
+            }
+        }
+    }
+
+    protected String getActionViewStatesKey() {
+        return ACTION_VIEW_STATES_KEY;
+    }
+
+    public void setCallback(Callback cb) {
+        mCallback = cb;
+    }
+    
+    /**
+     * Adds an item to the menu.  The other add methods funnel to this.
+     */
+    private MenuItem addInternal(int group, int id, int categoryOrder, CharSequence title) {
+        final int ordering = getOrdering(categoryOrder);
+        
+        final MenuItemImpl item = new MenuItemImpl(this, group, id, categoryOrder,
+                ordering, title, mDefaultShowAsAction);
+
+        if (mCurrentMenuInfo != null) {
+            // Pass along the current menu info
+            item.setMenuInfo(mCurrentMenuInfo);
+        }
+        
+        mItems.add(findInsertIndex(mItems, ordering), item);
+        onItemsChanged(true);
+        
+        return item;
+    }
+    
+    public MenuItem add(CharSequence title) {
+        return addInternal(0, 0, 0, title);
+    }
+
+    public MenuItem add(int titleRes) {
+        return addInternal(0, 0, 0, mResources.getString(titleRes));
+    }
+
+    public MenuItem add(int group, int id, int categoryOrder, CharSequence title) {
+        return addInternal(group, id, categoryOrder, title);
+    }
+
+    public MenuItem add(int group, int id, int categoryOrder, int title) {
+        return addInternal(group, id, categoryOrder, mResources.getString(title));
+    }
+
+    public SubMenu addSubMenu(CharSequence title) {
+        return addSubMenu(0, 0, 0, title);
+    }
+
+    public SubMenu addSubMenu(int titleRes) {
+        return addSubMenu(0, 0, 0, mResources.getString(titleRes));
+    }
+
+    public SubMenu addSubMenu(int group, int id, int categoryOrder, CharSequence title) {
+        final MenuItemImpl item = (MenuItemImpl) addInternal(group, id, categoryOrder, title);
+        final SubMenuBuilder subMenu = new SubMenuBuilder(mContext, this, item);
+        item.setSubMenu(subMenu);
+        
+        return subMenu;
+    }
+
+    public SubMenu addSubMenu(int group, int id, int categoryOrder, int title) {
+        return addSubMenu(group, id, categoryOrder, mResources.getString(title));
+    }
+
+    public int addIntentOptions(int group, int id, int categoryOrder, ComponentName caller,
+            Intent[] specifics, Intent intent, int flags, MenuItem[] outSpecificItems) {
+        PackageManager pm = mContext.getPackageManager();
+        final List<ResolveInfo> lri =
+                pm.queryIntentActivityOptions(caller, specifics, intent, 0);
+        final int N = lri != null ? lri.size() : 0;
+
+        if ((flags & FLAG_APPEND_TO_GROUP) == 0) {
+            removeGroup(group);
+        }
+
+        for (int i=0; i<N; i++) {
+            final ResolveInfo ri = lri.get(i);
+            Intent rintent = new Intent(
+                ri.specificIndex < 0 ? intent : specifics[ri.specificIndex]);
+            rintent.setComponent(new ComponentName(
+                    ri.activityInfo.applicationInfo.packageName,
+                    ri.activityInfo.name));
+            final MenuItem item = add(group, id, categoryOrder, ri.loadLabel(pm))
+                    .setIcon(ri.loadIcon(pm))
+                    .setIntent(rintent);
+            if (outSpecificItems != null && ri.specificIndex >= 0) {
+                outSpecificItems[ri.specificIndex] = item;
+            }
+        }
+
+        return N;
+    }
+
+    public void removeItem(int id) {
+        removeItemAtInt(findItemIndex(id), true);
+    }
+
+    public void removeGroup(int group) {
+        final int i = findGroupIndex(group);
+
+        if (i >= 0) {
+            final int maxRemovable = mItems.size() - i;
+            int numRemoved = 0;
+            while ((numRemoved++ < maxRemovable) && (mItems.get(i).getGroupId() == group)) {
+                // Don't force update for each one, this method will do it at the end
+                removeItemAtInt(i, false);
+            }
+            
+            // Notify menu views
+            onItemsChanged(true);
+        }
+    }
+
+    /**
+     * Remove the item at the given index and optionally forces menu views to
+     * update.
+     * 
+     * @param index The index of the item to be removed. If this index is
+     *            invalid an exception is thrown.
+     * @param updateChildrenOnMenuViews Whether to force update on menu views.
+     *            Please make sure you eventually call this after your batch of
+     *            removals.
+     */
+    private void removeItemAtInt(int index, boolean updateChildrenOnMenuViews) {
+        if ((index < 0) || (index >= mItems.size())) return;
+
+        mItems.remove(index);
+        
+        if (updateChildrenOnMenuViews) onItemsChanged(true);
+    }
+    
+    public void removeItemAt(int index) {
+        removeItemAtInt(index, true);
+    }
+
+    public void clearAll() {
+        mPreventDispatchingItemsChanged = true;
+        clear();
+        clearHeader();
+        mPreventDispatchingItemsChanged = false;
+        mItemsChangedWhileDispatchPrevented = false;
+        onItemsChanged(true);
+    }
+    
+    public void clear() {
+        if (mExpandedItem != null) {
+            collapseItemActionView(mExpandedItem);
+        }
+        mItems.clear();
+        
+        onItemsChanged(true);
+    }
+
+    void setExclusiveItemChecked(MenuItem item) {
+        final int group = item.getGroupId();
+        
+        final int N = mItems.size();
+        for (int i = 0; i < N; i++) {
+            MenuItemImpl curItem = mItems.get(i);
+            if (curItem.getGroupId() == group) {
+                if (!curItem.isExclusiveCheckable()) continue;
+                if (!curItem.isCheckable()) continue;
+                
+                // Check the item meant to be checked, uncheck the others (that are in the group)
+                curItem.setCheckedInt(curItem == item);
+            }
+        }
+    }
+    
+    public void setGroupCheckable(int group, boolean checkable, boolean exclusive) {
+        final int N = mItems.size();
+       
+        for (int i = 0; i < N; i++) {
+            MenuItemImpl item = mItems.get(i);
+            if (item.getGroupId() == group) {
+                item.setExclusiveCheckable(exclusive);
+                item.setCheckable(checkable);
+            }
+        }
+    }
+
+    public void setGroupVisible(int group, boolean visible) {
+        final int N = mItems.size();
+
+        // We handle the notification of items being changed ourselves, so we use setVisibleInt rather
+        // than setVisible and at the end notify of items being changed
+        
+        boolean changedAtLeastOneItem = false;
+        for (int i = 0; i < N; i++) {
+            MenuItemImpl item = mItems.get(i);
+            if (item.getGroupId() == group) {
+                if (item.setVisibleInt(visible)) changedAtLeastOneItem = true;
+            }
+        }
+
+        if (changedAtLeastOneItem) onItemsChanged(true);
+    }
+
+    public void setGroupEnabled(int group, boolean enabled) {
+        final int N = mItems.size();
+
+        for (int i = 0; i < N; i++) {
+            MenuItemImpl item = mItems.get(i);
+            if (item.getGroupId() == group) {
+                item.setEnabled(enabled);
+            }
+        }
+    }
+
+    public boolean hasVisibleItems() {
+        final int size = size();
+
+        for (int i = 0; i < size; i++) {
+            MenuItemImpl item = mItems.get(i);
+            if (item.isVisible()) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    public MenuItem findItem(int id) {
+        final int size = size();
+        for (int i = 0; i < size; i++) {
+            MenuItemImpl item = mItems.get(i);
+            if (item.getItemId() == id) {
+                return item;
+            } else if (item.hasSubMenu()) {
+                MenuItem possibleItem = item.getSubMenu().findItem(id);
+                
+                if (possibleItem != null) {
+                    return possibleItem;
+                }
+            }
+        }
+        
+        return null;
+    }
+
+    public int findItemIndex(int id) {
+        final int size = size();
+
+        for (int i = 0; i < size; i++) {
+            MenuItemImpl item = mItems.get(i);
+            if (item.getItemId() == id) {
+                return i;
+            }
+        }
+
+        return -1;
+    }
+
+    public int findGroupIndex(int group) {
+        return findGroupIndex(group, 0);
+    }
+
+    public int findGroupIndex(int group, int start) {
+        final int size = size();
+        
+        if (start < 0) {
+            start = 0;
+        }
+        
+        for (int i = start; i < size; i++) {
+            final MenuItemImpl item = mItems.get(i);
+            
+            if (item.getGroupId() == group) {
+                return i;
+            }
+        }
+
+        return -1;
+    }
+    
+    public int size() {
+        return mItems.size();
+    }
+
+    /** {@inheritDoc} */
+    public MenuItem getItem(int index) {
+        return mItems.get(index);
+    }
+
+    public boolean isShortcutKey(int keyCode, KeyEvent event) {
+        return findItemWithShortcutForKey(keyCode, event) != null;
+    }
+
+    public void setQwertyMode(boolean isQwerty) {
+        mQwertyMode = isQwerty;
+
+        onItemsChanged(false);
+    }
+
+    /**
+     * Returns the ordering across all items. This will grab the category from
+     * the upper bits, find out how to order the category with respect to other
+     * categories, and combine it with the lower bits.
+     * 
+     * @param categoryOrder The category order for a particular item (if it has
+     *            not been or/add with a category, the default category is
+     *            assumed).
+     * @return An ordering integer that can be used to order this item across
+     *         all the items (even from other categories).
+     */
+    private static int getOrdering(int categoryOrder) {
+        final int index = (categoryOrder & CATEGORY_MASK) >> CATEGORY_SHIFT;
+        
+        if (index < 0 || index >= sCategoryToOrder.length) {
+            throw new IllegalArgumentException("order does not contain a valid category.");
+        }
+        
+        return (sCategoryToOrder[index] << CATEGORY_SHIFT) | (categoryOrder & USER_MASK);
+    }
+
+    /**
+     * @return whether the menu shortcuts are in qwerty mode or not
+     */
+    boolean isQwertyMode() {
+        return mQwertyMode;
+    }
+
+    /**
+     * Sets whether the shortcuts should be visible on menus.  Devices without hardware
+     * key input will never make shortcuts visible even if this method is passed 'true'.
+     * 
+     * @param shortcutsVisible Whether shortcuts should be visible (if true and a
+     *            menu item does not have a shortcut defined, that item will
+     *            still NOT show a shortcut)
+     */
+    public void setShortcutsVisible(boolean shortcutsVisible) {
+        if (mShortcutsVisible == shortcutsVisible) return;
+
+        setShortcutsVisibleInner(shortcutsVisible);
+        onItemsChanged(false);
+    }
+
+    private void setShortcutsVisibleInner(boolean shortcutsVisible) {
+        mShortcutsVisible = shortcutsVisible
+                && mResources.getConfiguration().keyboard != Configuration.KEYBOARD_NOKEYS
+                && mResources.getBoolean(
+                        com.android.internal.R.bool.config_showMenuShortcutsWhenKeyboardPresent);
+    }
+
+    /**
+     * @return Whether shortcuts should be visible on menus.
+     */
+    public boolean isShortcutsVisible() {
+        return mShortcutsVisible;
+    }
+    
+    Resources getResources() {
+        return mResources;
+    }
+    
+    public Context getContext() {
+        return mContext;
+    }
+    
+    boolean dispatchMenuItemSelected(MenuBuilder menu, MenuItem item) {
+        return mCallback != null && mCallback.onMenuItemSelected(menu, item);
+    }
+
+    /**
+     * Dispatch a mode change event to this menu's callback.
+     */
+    public void changeMenuMode() {
+        if (mCallback != null) {
+            mCallback.onMenuModeChange(this);
+        }
+    }
+
+    private static int findInsertIndex(ArrayList<MenuItemImpl> items, int ordering) {
+        for (int i = items.size() - 1; i >= 0; i--) {
+            MenuItemImpl item = items.get(i);
+            if (item.getOrdering() <= ordering) {
+                return i + 1;
+            }
+        }
+        
+        return 0;
+    }
+    
+    public boolean performShortcut(int keyCode, KeyEvent event, int flags) {
+        final MenuItemImpl item = findItemWithShortcutForKey(keyCode, event);
+
+        boolean handled = false;
+        
+        if (item != null) {
+            handled = performItemAction(item, flags);
+        }
+        
+        if ((flags & FLAG_ALWAYS_PERFORM_CLOSE) != 0) {
+            close(true);
+        }
+        
+        return handled;
+    }
+
+    /*
+     * This function will return all the menu and sub-menu items that can
+     * be directly (the shortcut directly corresponds) and indirectly
+     * (the ALT-enabled char corresponds to the shortcut) associated
+     * with the keyCode.
+     */
+    void findItemsWithShortcutForKey(List<MenuItemImpl> items, int keyCode, KeyEvent event) {
+        final boolean qwerty = isQwertyMode();
+        final int metaState = event.getMetaState();
+        final KeyCharacterMap.KeyData possibleChars = new KeyCharacterMap.KeyData();
+        // Get the chars associated with the keyCode (i.e using any chording combo)
+        final boolean isKeyCodeMapped = event.getKeyData(possibleChars);
+        // The delete key is not mapped to '\b' so we treat it specially
+        if (!isKeyCodeMapped && (keyCode != KeyEvent.KEYCODE_DEL)) {
+            return;
+        }
+
+        // Look for an item whose shortcut is this key.
+        final int N = mItems.size();
+        for (int i = 0; i < N; i++) {
+            MenuItemImpl item = mItems.get(i);
+            if (item.hasSubMenu()) {
+                ((MenuBuilder)item.getSubMenu()).findItemsWithShortcutForKey(items, keyCode, event);
+            }
+            final char shortcutChar = qwerty ? item.getAlphabeticShortcut() : item.getNumericShortcut();
+            if (((metaState & (KeyEvent.META_SHIFT_ON | KeyEvent.META_SYM_ON)) == 0) &&
+                  (shortcutChar != 0) &&
+                  (shortcutChar == possibleChars.meta[0]
+                      || shortcutChar == possibleChars.meta[2]
+                      || (qwerty && shortcutChar == '\b' &&
+                          keyCode == KeyEvent.KEYCODE_DEL)) &&
+                  item.isEnabled()) {
+                items.add(item);
+            }
+        }
+    }
+
+    /*
+     * We want to return the menu item associated with the key, but if there is no
+     * ambiguity (i.e. there is only one menu item corresponding to the key) we want
+     * to return it even if it's not an exact match; this allow the user to
+     * _not_ use the ALT key for example, making the use of shortcuts slightly more
+     * user-friendly. An example is on the G1, '!' and '1' are on the same key, and
+     * in Gmail, Menu+1 will trigger Menu+! (the actual shortcut).
+     *
+     * On the other hand, if two (or more) shortcuts corresponds to the same key,
+     * we have to only return the exact match.
+     */
+    MenuItemImpl findItemWithShortcutForKey(int keyCode, KeyEvent event) {
+        // Get all items that can be associated directly or indirectly with the keyCode
+        ArrayList<MenuItemImpl> items = mTempShortcutItemList;
+        items.clear();
+        findItemsWithShortcutForKey(items, keyCode, event);
+
+        if (items.isEmpty()) {
+            return null;
+        }
+
+        final int metaState = event.getMetaState();
+        final KeyCharacterMap.KeyData possibleChars = new KeyCharacterMap.KeyData();
+        // Get the chars associated with the keyCode (i.e using any chording combo)
+        event.getKeyData(possibleChars);
+
+        // If we have only one element, we can safely returns it
+        final int size = items.size();
+        if (size == 1) {
+            return items.get(0);
+        }
+
+        final boolean qwerty = isQwertyMode();
+        // If we found more than one item associated with the key,
+        // we have to return the exact match
+        for (int i = 0; i < size; i++) {
+            final MenuItemImpl item = items.get(i);
+            final char shortcutChar = qwerty ? item.getAlphabeticShortcut() :
+                    item.getNumericShortcut();
+            if ((shortcutChar == possibleChars.meta[0] &&
+                    (metaState & KeyEvent.META_ALT_ON) == 0)
+                || (shortcutChar == possibleChars.meta[2] &&
+                    (metaState & KeyEvent.META_ALT_ON) != 0)
+                || (qwerty && shortcutChar == '\b' &&
+                    keyCode == KeyEvent.KEYCODE_DEL)) {
+                return item;
+            }
+        }
+        return null;
+    }
+
+    public boolean performIdentifierAction(int id, int flags) {
+        // Look for an item whose identifier is the id.
+        return performItemAction(findItem(id), flags);           
+    }
+
+    public boolean performItemAction(MenuItem item, int flags) {
+        MenuItemImpl itemImpl = (MenuItemImpl) item;
+        
+        if (itemImpl == null || !itemImpl.isEnabled()) {
+            return false;
+        }
+
+        boolean invoked = itemImpl.invoke();
+
+        final ActionProvider provider = item.getActionProvider();
+        final boolean providerHasSubMenu = provider != null && provider.hasSubMenu();
+        if (itemImpl.hasCollapsibleActionView()) {
+            invoked |= itemImpl.expandActionView();
+            if (invoked) close(true);
+        } else if (itemImpl.hasSubMenu() || providerHasSubMenu) {
+            close(false);
+
+            if (!itemImpl.hasSubMenu()) {
+                itemImpl.setSubMenu(new SubMenuBuilder(getContext(), this, itemImpl));
+            }
+
+            final SubMenuBuilder subMenu = (SubMenuBuilder) itemImpl.getSubMenu();
+            if (providerHasSubMenu) {
+                provider.onPrepareSubMenu(subMenu);
+            }
+            invoked |= dispatchSubMenuSelected(subMenu);
+            if (!invoked) close(true);
+        } else {
+            if ((flags & FLAG_PERFORM_NO_CLOSE) == 0) {
+                close(true);
+            }
+        }
+        
+        return invoked;
+    }
+    
+    /**
+     * Closes the visible menu.
+     * 
+     * @param allMenusAreClosing Whether the menus are completely closing (true),
+     *            or whether there is another menu coming in this menu's place
+     *            (false). For example, if the menu is closing because a
+     *            sub menu is about to be shown, <var>allMenusAreClosing</var>
+     *            is false.
+     */
+    final void close(boolean allMenusAreClosing) {
+        if (mIsClosing) return;
+
+        mIsClosing = true;
+        for (WeakReference<MenuPresenter> ref : mPresenters) {
+            final MenuPresenter presenter = ref.get();
+            if (presenter == null) {
+                mPresenters.remove(ref);
+            } else {
+                presenter.onCloseMenu(this, allMenusAreClosing);
+            }
+        }
+        mIsClosing = false;
+    }
+
+    /** {@inheritDoc} */
+    public void close() {
+        close(true);
+    }
+
+    /**
+     * Called when an item is added or removed.
+     * 
+     * @param structureChanged true if the menu structure changed,
+     *                         false if only item properties changed.
+     *                         (Visibility is a structural property since it affects layout.)
+     */
+    void onItemsChanged(boolean structureChanged) {
+        if (!mPreventDispatchingItemsChanged) {
+            if (structureChanged) {
+                mIsVisibleItemsStale = true;
+                mIsActionItemsStale = true;
+            }
+
+            dispatchPresenterUpdate(structureChanged);
+        } else {
+            mItemsChangedWhileDispatchPrevented = true;
+        }
+    }
+
+    /**
+     * Stop dispatching item changed events to presenters until
+     * {@link #startDispatchingItemsChanged()} is called. Useful when
+     * many menu operations are going to be performed as a batch.
+     */
+    public void stopDispatchingItemsChanged() {
+        if (!mPreventDispatchingItemsChanged) {
+            mPreventDispatchingItemsChanged = true;
+            mItemsChangedWhileDispatchPrevented = false;
+        }
+    }
+
+    public void startDispatchingItemsChanged() {
+        mPreventDispatchingItemsChanged = false;
+
+        if (mItemsChangedWhileDispatchPrevented) {
+            mItemsChangedWhileDispatchPrevented = false;
+            onItemsChanged(true);
+        }
+    }
+
+    /**
+     * Called by {@link MenuItemImpl} when its visible flag is changed.
+     * @param item The item that has gone through a visibility change.
+     */
+    void onItemVisibleChanged(MenuItemImpl item) {
+        // Notify of items being changed
+        mIsVisibleItemsStale = true;
+        onItemsChanged(true);
+    }
+    
+    /**
+     * Called by {@link MenuItemImpl} when its action request status is changed.
+     * @param item The item that has gone through a change in action request status.
+     */
+    void onItemActionRequestChanged(MenuItemImpl item) {
+        // Notify of items being changed
+        mIsActionItemsStale = true;
+        onItemsChanged(true);
+    }
+    
+    ArrayList<MenuItemImpl> getVisibleItems() {
+        if (!mIsVisibleItemsStale) return mVisibleItems;
+        
+        // Refresh the visible items
+        mVisibleItems.clear();
+        
+        final int itemsSize = mItems.size(); 
+        MenuItemImpl item;
+        for (int i = 0; i < itemsSize; i++) {
+            item = mItems.get(i);
+            if (item.isVisible()) mVisibleItems.add(item);
+        }
+        
+        mIsVisibleItemsStale = false;
+        mIsActionItemsStale = true;
+        
+        return mVisibleItems;
+    }
+
+    /**
+     * This method determines which menu items get to be 'action items' that will appear
+     * in an action bar and which items should be 'overflow items' in a secondary menu.
+     * The rules are as follows:
+     *
+     * <p>Items are considered for inclusion in the order specified within the menu.
+     * There is a limit of mMaxActionItems as a total count, optionally including the overflow
+     * menu button itself. This is a soft limit; if an item shares a group ID with an item
+     * previously included as an action item, the new item will stay with its group and become
+     * an action item itself even if it breaks the max item count limit. This is done to
+     * limit the conceptual complexity of the items presented within an action bar. Only a few
+     * unrelated concepts should be presented to the user in this space, and groups are treated
+     * as a single concept.
+     *
+     * <p>There is also a hard limit of consumed measurable space: mActionWidthLimit. This
+     * limit may be broken by a single item that exceeds the remaining space, but no further
+     * items may be added. If an item that is part of a group cannot fit within the remaining
+     * measured width, the entire group will be demoted to overflow. This is done to ensure room
+     * for navigation and other affordances in the action bar as well as reduce general UI clutter.
+     *
+     * <p>The space freed by demoting a full group cannot be consumed by future menu items.
+     * Once items begin to overflow, all future items become overflow items as well. This is
+     * to avoid inadvertent reordering that may break the app's intended design.
+     */
+    public void flagActionItems() {
+        if (!mIsActionItemsStale) {
+            return;
+        }
+
+        // Presenters flag action items as needed.
+        boolean flagged = false;
+        for (WeakReference<MenuPresenter> ref : mPresenters) {
+            final MenuPresenter presenter = ref.get();
+            if (presenter == null) {
+                mPresenters.remove(ref);
+            } else {
+                flagged |= presenter.flagActionItems();
+            }
+        }
+
+        if (flagged) {
+            mActionItems.clear();
+            mNonActionItems.clear();
+            ArrayList<MenuItemImpl> visibleItems = getVisibleItems();
+            final int itemsSize = visibleItems.size();
+            for (int i = 0; i < itemsSize; i++) {
+                MenuItemImpl item = visibleItems.get(i);
+                if (item.isActionButton()) {
+                    mActionItems.add(item);
+                } else {
+                    mNonActionItems.add(item);
+                }
+            }
+        } else {
+            // Nobody flagged anything, everything is a non-action item.
+            // (This happens during a first pass with no action-item presenters.)
+            mActionItems.clear();
+            mNonActionItems.clear();
+            mNonActionItems.addAll(getVisibleItems());
+        }
+        mIsActionItemsStale = false;
+    }
+    
+    ArrayList<MenuItemImpl> getActionItems() {
+        flagActionItems();
+        return mActionItems;
+    }
+    
+    ArrayList<MenuItemImpl> getNonActionItems() {
+        flagActionItems();
+        return mNonActionItems;
+    }
+
+    public void clearHeader() {
+        mHeaderIcon = null;
+        mHeaderTitle = null;
+        mHeaderView = null;
+        
+        onItemsChanged(false);
+    }
+    
+    private void setHeaderInternal(final int titleRes, final CharSequence title, final int iconRes,
+            final Drawable icon, final View view) {
+        final Resources r = getResources();
+
+        if (view != null) {
+            mHeaderView = view;
+            
+            // If using a custom view, then the title and icon aren't used
+            mHeaderTitle = null;
+            mHeaderIcon = null;
+        } else {
+            if (titleRes > 0) {
+                mHeaderTitle = r.getText(titleRes);
+            } else if (title != null) {
+                mHeaderTitle = title;
+            }
+            
+            if (iconRes > 0) {
+                mHeaderIcon = r.getDrawable(iconRes);
+            } else if (icon != null) {
+                mHeaderIcon = icon;
+            }
+            
+            // If using the title or icon, then a custom view isn't used
+            mHeaderView = null;
+        }
+        
+        // Notify of change
+        onItemsChanged(false);
+    }
+
+    /**
+     * Sets the header's title. This replaces the header view. Called by the
+     * builder-style methods of subclasses.
+     * 
+     * @param title The new title.
+     * @return This MenuBuilder so additional setters can be called.
+     */
+    protected MenuBuilder setHeaderTitleInt(CharSequence title) {
+        setHeaderInternal(0, title, 0, null, null);
+        return this;
+    }
+    
+    /**
+     * Sets the header's title. This replaces the header view. Called by the
+     * builder-style methods of subclasses.
+     * 
+     * @param titleRes The new title (as a resource ID).
+     * @return This MenuBuilder so additional setters can be called.
+     */
+    protected MenuBuilder setHeaderTitleInt(int titleRes) {
+        setHeaderInternal(titleRes, null, 0, null, null);
+        return this;
+    }
+    
+    /**
+     * Sets the header's icon. This replaces the header view. Called by the
+     * builder-style methods of subclasses.
+     * 
+     * @param icon The new icon.
+     * @return This MenuBuilder so additional setters can be called.
+     */
+    protected MenuBuilder setHeaderIconInt(Drawable icon) {
+        setHeaderInternal(0, null, 0, icon, null);
+        return this;
+    }
+    
+    /**
+     * Sets the header's icon. This replaces the header view. Called by the
+     * builder-style methods of subclasses.
+     * 
+     * @param iconRes The new icon (as a resource ID).
+     * @return This MenuBuilder so additional setters can be called.
+     */
+    protected MenuBuilder setHeaderIconInt(int iconRes) {
+        setHeaderInternal(0, null, iconRes, null, null);
+        return this;
+    }
+    
+    /**
+     * Sets the header's view. This replaces the title and icon. Called by the
+     * builder-style methods of subclasses.
+     * 
+     * @param view The new view.
+     * @return This MenuBuilder so additional setters can be called.
+     */
+    protected MenuBuilder setHeaderViewInt(View view) {
+        setHeaderInternal(0, null, 0, null, view);
+        return this;
+    }
+    
+    public CharSequence getHeaderTitle() {
+        return mHeaderTitle;
+    }
+    
+    public Drawable getHeaderIcon() {
+        return mHeaderIcon;
+    }
+    
+    public View getHeaderView() {
+        return mHeaderView;
+    }
+    
+    /**
+     * Gets the root menu (if this is a submenu, find its root menu).
+     * @return The root menu.
+     */
+    public MenuBuilder getRootMenu() {
+        return this;
+    }
+    
+    /**
+     * Sets the current menu info that is set on all items added to this menu
+     * (until this is called again with different menu info, in which case that
+     * one will be added to all subsequent item additions).
+     * 
+     * @param menuInfo The extra menu information to add.
+     */
+    public void setCurrentMenuInfo(ContextMenuInfo menuInfo) {
+        mCurrentMenuInfo = menuInfo;
+    }
+
+    void setOptionalIconsVisible(boolean visible) {
+        mOptionalIconsVisible = visible;
+    }
+    
+    boolean getOptionalIconsVisible() {
+        return mOptionalIconsVisible;
+    }
+
+    public boolean expandItemActionView(MenuItemImpl item) {
+        if (mPresenters.isEmpty()) return false;
+
+        boolean expanded = false;
+
+        stopDispatchingItemsChanged();
+        for (WeakReference<MenuPresenter> ref : mPresenters) {
+            final MenuPresenter presenter = ref.get();
+            if (presenter == null) {
+                mPresenters.remove(ref);
+            } else if ((expanded = presenter.expandItemActionView(this, item))) {
+                break;
+            }
+        }
+        startDispatchingItemsChanged();
+
+        if (expanded) {
+            mExpandedItem = item;
+        }
+        return expanded;
+    }
+
+    public boolean collapseItemActionView(MenuItemImpl item) {
+        if (mPresenters.isEmpty() || mExpandedItem != item) return false;
+
+        boolean collapsed = false;
+
+        stopDispatchingItemsChanged();
+        for (WeakReference<MenuPresenter> ref : mPresenters) {
+            final MenuPresenter presenter = ref.get();
+            if (presenter == null) {
+                mPresenters.remove(ref);
+            } else if ((collapsed = presenter.collapseItemActionView(this, item))) {
+                break;
+            }
+        }
+        startDispatchingItemsChanged();
+
+        if (collapsed) {
+            mExpandedItem = null;
+        }
+        return collapsed;
+    }
+
+    public MenuItemImpl getExpandedItem() {
+        return mExpandedItem;
+    }
+}
diff --git a/src/frameworks/base/core/java/com/android/internal/widget/ActionBarContextView.java b/src/frameworks/base/core/java/com/android/internal/widget/ActionBarContextView.java
new file mode 100644
index 0000000..16f08f5
--- /dev/null
+++ b/src/frameworks/base/core/java/com/android/internal/widget/ActionBarContextView.java
@@ -0,0 +1,538 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.internal.widget;
+
+import com.android.internal.R;
+import com.android.internal.view.menu.ActionMenuPresenter;
+import com.android.internal.view.menu.ActionMenuView;
+import com.android.internal.view.menu.MenuBuilder;
+
+import android.animation.Animator;
+import android.animation.Animator.AnimatorListener;
+import android.animation.AnimatorSet;
+import android.animation.ObjectAnimator;
+import android.content.Context;
+import android.content.res.Configuration;
+import android.content.res.TypedArray;
+import android.graphics.drawable.Drawable;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.view.ActionMode;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.accessibility.AccessibilityEvent;
+import android.view.animation.DecelerateInterpolator;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+/**
+ * @hide
+ */
+public class ActionBarContextView extends AbsActionBarView implements AnimatorListener {
+    private static final String TAG = "ActionBarContextView";
+
+    private CharSequence mTitle;
+    private CharSequence mSubtitle;
+
+    private View mClose;
+    private View mCustomView;
+    private LinearLayout mTitleLayout;
+    private TextView mTitleView;
+    private TextView mSubtitleView;
+    private int mTitleStyleRes;
+    private int mSubtitleStyleRes;
+    private Drawable mSplitBackground;
+    private boolean mTitleOptional;
+
+    private Animator mCurrentAnimation;
+    private boolean mAnimateInOnLayout;
+    private int mAnimationMode;
+
+    private static final int ANIMATE_IDLE = 0;
+    private static final int ANIMATE_IN = 1;
+    private static final int ANIMATE_OUT = 2;
+    
+    public ActionBarContextView(Context context) {
+        this(context, null);
+    }
+    
+    public ActionBarContextView(Context context, AttributeSet attrs) {
+        this(context, attrs, com.android.internal.R.attr.actionModeStyle);
+    }
+    
+    public ActionBarContextView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        
+        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ActionMode, defStyle, 0);
+        setBackgroundDrawable(a.getDrawable(
+                com.android.internal.R.styleable.ActionMode_background));
+        mTitleStyleRes = a.getResourceId(
+                com.android.internal.R.styleable.ActionMode_titleTextStyle, 0);
+        mSubtitleStyleRes = a.getResourceId(
+                com.android.internal.R.styleable.ActionMode_subtitleTextStyle, 0);
+
+        mContentHeight = a.getLayoutDimension(
+                com.android.internal.R.styleable.ActionMode_height, 0);
+
+        mSplitBackground = a.getDrawable(
+                com.android.internal.R.styleable.ActionMode_backgroundSplit);
+
+        a.recycle();
+    }
+
+    @Override
+    public void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        if (mActionMenuPresenter != null) {
+            mActionMenuPresenter.hideOverflowMenu();
+            mActionMenuPresenter.hideSubMenus();
+        }
+    }
+
+    @Override
+    public void setSplitActionBar(boolean split) {
+        if (mSplitActionBar != split) {
+            if (mActionMenuPresenter != null) {
+                // Mode is already active; move everything over and adjust the menu itself.
+                final LayoutParams layoutParams = new LayoutParams(LayoutParams.WRAP_CONTENT,
+                        LayoutParams.MATCH_PARENT);
+                if (!split) {
+                    mMenuView = (ActionMenuView) mActionMenuPresenter.getMenuView(this);
+                    mMenuView.setBackgroundDrawable(null);
+                    final ViewGroup oldParent = (ViewGroup) mMenuView.getParent();
+                    if (oldParent != null) oldParent.removeView(mMenuView);
+                    addView(mMenuView, layoutParams);
+                } else {
+                    // Allow full screen width in split mode.
+                    mActionMenuPresenter.setWidthLimit(
+                            getContext().getResources().getDisplayMetrics().widthPixels, true);
+                    // No limit to the item count; use whatever will fit.
+                    mActionMenuPresenter.setItemLimit(Integer.MAX_VALUE);
+                    // Span the whole width
+                    layoutParams.width = LayoutParams.MATCH_PARENT;
+                    layoutParams.height = mContentHeight;
+                    mMenuView = (ActionMenuView) mActionMenuPresenter.getMenuView(this);
+                    mMenuView.setBackgroundDrawable(mSplitBackground);
+                    final ViewGroup oldParent = (ViewGroup) mMenuView.getParent();
+                    if (oldParent != null) oldParent.removeView(mMenuView);
+                    mSplitView.addView(mMenuView, layoutParams);
+                }
+            }
+            super.setSplitActionBar(split);
+        }
+    }
+
+    public void setContentHeight(int height) {
+        mContentHeight = height;
+    }
+
+    public void setCustomView(View view) {
+        if (mCustomView != null) {
+            removeView(mCustomView);
+        }
+        mCustomView = view;
+        if (mTitleLayout != null) {
+            removeView(mTitleLayout);
+            mTitleLayout = null;
+        }
+        if (view != null) {
+            addView(view);
+        }
+        requestLayout();
+    }
+
+    public void setTitle(CharSequence title) {
+        mTitle = title;
+        initTitle();
+    }
+
+    public void setSubtitle(CharSequence subtitle) {
+        mSubtitle = subtitle;
+        initTitle();
+    }
+
+    public CharSequence getTitle() {
+        return mTitle;
+    }
+
+    public CharSequence getSubtitle() {
+        return mSubtitle;
+    }
+
+    private void initTitle() {
+        if (mTitleLayout == null) {
+            LayoutInflater inflater = LayoutInflater.from(getContext());
+            inflater.inflate(R.layout.action_bar_title_item, this);
+            mTitleLayout = (LinearLayout) getChildAt(getChildCount() - 1);
+            mTitleView = (TextView) mTitleLayout.findViewById(R.id.action_bar_title);
+            mSubtitleView = (TextView) mTitleLayout.findViewById(R.id.action_bar_subtitle);
+            if (mTitleStyleRes != 0) {
+                mTitleView.setTextAppearance(mContext, mTitleStyleRes);
+            }
+            if (mSubtitleStyleRes != 0) {
+                mSubtitleView.setTextAppearance(mContext, mSubtitleStyleRes);
+            }
+        }
+
+        mTitleView.setText(mTitle);
+        mSubtitleView.setText(mSubtitle);
+
+        final boolean hasTitle = !TextUtils.isEmpty(mTitle);
+        final boolean hasSubtitle = !TextUtils.isEmpty(mSubtitle);
+        mSubtitleView.setVisibility(hasSubtitle ? VISIBLE : GONE);
+        mTitleLayout.setVisibility(hasTitle || hasSubtitle ? VISIBLE : GONE);
+        if (mTitleLayout.getParent() == null) {
+            addView(mTitleLayout);
+        }
+    }
+
+    public void initForMode(final ActionMode mode) {
+        if (mClose == null) {
+            LayoutInflater inflater = LayoutInflater.from(mContext);
+            mClose = inflater.inflate(R.layout.action_mode_close_item, this, false);
+            addView(mClose);
+        } else if (mClose.getParent() == null) {
+            addView(mClose);
+        }
+
+        View closeButton = mClose.findViewById(R.id.action_mode_close_button);
+        closeButton.setOnClickListener(new OnClickListener() {
+            public void onClick(View v) {
+                mode.finish();
+            }
+        });
+
+        final MenuBuilder menu = (MenuBuilder) mode.getMenu();
+        if (mActionMenuPresenter != null) {
+            mActionMenuPresenter.dismissPopupMenus();
+        }
+        mActionMenuPresenter = new ActionMenuPresenter(mContext);
+        mActionMenuPresenter.setReserveOverflow(true);
+
+        final LayoutParams layoutParams = new LayoutParams(LayoutParams.WRAP_CONTENT,
+                LayoutParams.MATCH_PARENT);
+        if (!mSplitActionBar) {
+            menu.addMenuPresenter(mActionMenuPresenter);
+            mMenuView = (ActionMenuView) mActionMenuPresenter.getMenuView(this);
+            mMenuView.setBackgroundDrawable(null);
+            addView(mMenuView, layoutParams);
+        } else {
+            // Allow full screen width in split mode.
+            mActionMenuPresenter.setWidthLimit(
+                    getContext().getResources().getDisplayMetrics().widthPixels, true);
+            // No limit to the item count; use whatever will fit.
+            mActionMenuPresenter.setItemLimit(Integer.MAX_VALUE);
+            // Span the whole width
+            layoutParams.width = LayoutParams.MATCH_PARENT;
+            layoutParams.height = mContentHeight;
+            menu.addMenuPresenter(mActionMenuPresenter);
+            mMenuView = (ActionMenuView) mActionMenuPresenter.getMenuView(this);
+            mMenuView.setBackgroundDrawable(mSplitBackground);
+            mSplitView.addView(mMenuView, layoutParams);
+        }
+
+        mAnimateInOnLayout = true;
+    }
+
+    public void closeMode() {
+        if (mAnimationMode == ANIMATE_OUT) {
+            // Called again during close; just finish what we were doing.
+            return;
+        }
+        if (mClose == null) {
+            killMode();
+            return;
+        }
+
+        finishAnimation();
+        mAnimationMode = ANIMATE_OUT;
+        mCurrentAnimation = makeOutAnimation();
+        mCurrentAnimation.start();
+    }
+
+    private void finishAnimation() {
+        final Animator a = mCurrentAnimation;
+        if (a != null) {
+            mCurrentAnimation = null;
+            a.end();
+        }
+    }
+
+    public void killMode() {
+        finishAnimation();
+        removeAllViews();
+        if (mSplitView != null) {
+            mSplitView.removeView(mMenuView);
+        }
+        mCustomView = null;
+        mMenuView = null;
+        mAnimateInOnLayout = false;
+    }
+
+    @Override
+    public boolean showOverflowMenu() {
+        if (mActionMenuPresenter != null) {
+            return mActionMenuPresenter.showOverflowMenu();
+        }
+        return false;
+    }
+
+    @Override
+    public boolean hideOverflowMenu() {
+        if (mActionMenuPresenter != null) {
+            return mActionMenuPresenter.hideOverflowMenu();
+        }
+        return false;
+    }
+
+    @Override
+    public boolean isOverflowMenuShowing() {
+        if (mActionMenuPresenter != null) {
+            return mActionMenuPresenter.isOverflowMenuShowing();
+        }
+        return false;
+    }
+
+    @Override
+    protected ViewGroup.LayoutParams generateDefaultLayoutParams() {
+        // Used by custom views if they don't supply layout params. Everything else
+        // added to an ActionBarContextView should have them already.
+        return new MarginLayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
+    }
+
+    @Override
+    public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) {
+        return new MarginLayoutParams(getContext(), attrs);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
+        if (widthMode != MeasureSpec.EXACTLY) {
+            throw new IllegalStateException(getClass().getSimpleName() + " can only be used " +
+                    "with android:layout_width=\"match_parent\" (or fill_parent)");
+        }
+
+        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
+        if (heightMode == MeasureSpec.UNSPECIFIED) {
+            throw new IllegalStateException(getClass().getSimpleName() + " can only be used " +
+                    "with android:layout_height=\"wrap_content\"");
+        }
+        
+        final int contentWidth = MeasureSpec.getSize(widthMeasureSpec);
+
+        int maxHeight = mContentHeight > 0 ?
+                mContentHeight : MeasureSpec.getSize(heightMeasureSpec);
+
+        final int verticalPadding = getPaddingTop() + getPaddingBottom();
+        int availableWidth = contentWidth - getPaddingLeft() - getPaddingRight();
+        final int height = maxHeight - verticalPadding;
+        final int childSpecHeight = MeasureSpec.makeMeasureSpec(height, MeasureSpec.AT_MOST);
+        
+        if (mClose != null) {
+            availableWidth = measureChildView(mClose, availableWidth, childSpecHeight, 0);
+            MarginLayoutParams lp = (MarginLayoutParams) mClose.getLayoutParams();
+            availableWidth -= lp.leftMargin + lp.rightMargin;
+        }
+
+        if (mMenuView != null && mMenuView.getParent() == this) {
+            availableWidth = measureChildView(mMenuView, availableWidth,
+                    childSpecHeight, 0);
+        }
+
+        if (mTitleLayout != null && mCustomView == null) {
+            if (mTitleOptional) {
+                final int titleWidthSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
+                mTitleLayout.measure(titleWidthSpec, childSpecHeight);
+                final int titleWidth = mTitleLayout.getMeasuredWidth();
+                final boolean titleFits = titleWidth <= availableWidth;
+                if (titleFits) {
+                    availableWidth -= titleWidth;
+                }
+                mTitleLayout.setVisibility(titleFits ? VISIBLE : GONE);
+            } else {
+                availableWidth = measureChildView(mTitleLayout, availableWidth, childSpecHeight, 0);
+            }
+        }
+
+        if (mCustomView != null) {
+            ViewGroup.LayoutParams lp = mCustomView.getLayoutParams();
+            final int customWidthMode = lp.width != LayoutParams.WRAP_CONTENT ?
+                    MeasureSpec.EXACTLY : MeasureSpec.AT_MOST;
+            final int customWidth = lp.width >= 0 ?
+                    Math.min(lp.width, availableWidth) : availableWidth;
+            final int customHeightMode = lp.height != LayoutParams.WRAP_CONTENT ?
+                    MeasureSpec.EXACTLY : MeasureSpec.AT_MOST;
+            final int customHeight = lp.height >= 0 ?
+                    Math.min(lp.height, height) : height;
+            mCustomView.measure(MeasureSpec.makeMeasureSpec(customWidth, customWidthMode),
+                    MeasureSpec.makeMeasureSpec(customHeight, customHeightMode));
+        }
+
+        if (mContentHeight <= 0) {
+            int measuredHeight = 0;
+            final int count = getChildCount();
+            for (int i = 0; i < count; i++) {
+                View v = getChildAt(i);
+                int paddedViewHeight = v.getMeasuredHeight() + verticalPadding;
+                if (paddedViewHeight > measuredHeight) {
+                    measuredHeight = paddedViewHeight;
+                }
+            }
+            setMeasuredDimension(contentWidth, measuredHeight);
+        } else {
+            setMeasuredDimension(contentWidth, maxHeight);
+        }
+    }
+
+    private Animator makeInAnimation() {
+        mClose.setTranslationX(-mClose.getWidth() -
+                ((MarginLayoutParams) mClose.getLayoutParams()).leftMargin);
+        ObjectAnimator buttonAnimator = ObjectAnimator.ofFloat(mClose, "translationX", 0);
+        buttonAnimator.setDuration(200);
+        buttonAnimator.addListener(this);
+        buttonAnimator.setInterpolator(new DecelerateInterpolator());
+
+        AnimatorSet set = new AnimatorSet();
+        AnimatorSet.Builder b = set.play(buttonAnimator);
+
+        if (mMenuView != null) {
+            final int count = mMenuView.getChildCount();
+            if (count > 0) {
+                for (int i = count - 1, j = 0; i >= 0; i--, j++) {
+                    View child = mMenuView.getChildAt(i);
+                    child.setScaleY(0);
+                    ObjectAnimator a = ObjectAnimator.ofFloat(child, "scaleY", 0, 1);
+                    a.setDuration(300);
+                    b.with(a);
+                }
+            }
+        }
+
+        return set;
+    }
+
+    private Animator makeOutAnimation() {
+        ObjectAnimator buttonAnimator = ObjectAnimator.ofFloat(mClose, "translationX",
+                -mClose.getWidth() - ((MarginLayoutParams) mClose.getLayoutParams()).leftMargin);
+        buttonAnimator.setDuration(200);
+        buttonAnimator.addListener(this);
+        buttonAnimator.setInterpolator(new DecelerateInterpolator());
+
+        AnimatorSet set = new AnimatorSet();
+        AnimatorSet.Builder b = set.play(buttonAnimator);
+
+        if (mMenuView != null) {
+            final int count = mMenuView.getChildCount();
+            if (count > 0) {
+                for (int i = 0; i < 0; i++) {
+                    View child = mMenuView.getChildAt(i);
+                    child.setScaleY(0);
+                    ObjectAnimator a = ObjectAnimator.ofFloat(child, "scaleY", 0);
+                    a.setDuration(300);
+                    b.with(a);
+                }
+            }
+        }
+
+        return set;
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int l, int t, int r, int b) {
+        int x = getPaddingLeft();
+        final int y = getPaddingTop();
+        final int contentHeight = b - t - getPaddingTop() - getPaddingBottom();
+        
+        if (mClose != null && mClose.getVisibility() != GONE) {
+            MarginLayoutParams lp = (MarginLayoutParams) mClose.getLayoutParams();
+            x += lp.leftMargin;
+            x += positionChild(mClose, x, y, contentHeight);
+            x += lp.rightMargin;
+
+            if (mAnimateInOnLayout) {
+                mAnimationMode = ANIMATE_IN;
+                mCurrentAnimation = makeInAnimation();
+                mCurrentAnimation.start();
+                mAnimateInOnLayout = false;
+            }
+        }
+
+        if (mTitleLayout != null && mCustomView == null && mTitleLayout.getVisibility() != GONE) {
+            x += positionChild(mTitleLayout, x, y, contentHeight);
+        }
+        
+        if (mCustomView != null) {
+            x += positionChild(mCustomView, x, y, contentHeight);
+        }
+        
+        x = r - l - getPaddingRight();
+
+        if (mMenuView != null) {
+            x -= positionChildInverse(mMenuView, x, y, contentHeight);
+        }
+    }
+
+    @Override
+    public void onAnimationStart(Animator animation) {
+    }
+
+    @Override
+    public void onAnimationEnd(Animator animation) {
+        if (mAnimationMode == ANIMATE_OUT) {
+            killMode();
+        }
+        mAnimationMode = ANIMATE_IDLE;
+    }
+
+    @Override
+    public void onAnimationCancel(Animator animation) {
+    }
+
+    @Override
+    public void onAnimationRepeat(Animator animation) {
+    }
+
+    @Override
+    public boolean shouldDelayChildPressedState() {
+        return false;
+    }
+
+    @Override
+    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
+        if (event.getEventType() == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED) {
+            // Action mode started
+            event.setSource(this);
+            event.setClassName(getClass().getName());
+            event.setPackageName(getContext().getPackageName());
+            event.setContentDescription(mTitle);
+        } else {
+            super.onInitializeAccessibilityEvent(event);
+        }
+    }
+
+    public void setTitleOptional(boolean titleOptional) {
+        if (titleOptional != mTitleOptional) {
+            requestLayout();
+        }
+        mTitleOptional = titleOptional;
+    }
+
+    public boolean isTitleOptional() {
+        return mTitleOptional;
+    }
+}
diff --git a/src/frameworks/base/graphics/java/android/graphics/drawable/AnimatedRotateDrawable.java b/src/frameworks/base/graphics/java/android/graphics/drawable/AnimatedRotateDrawable.java
new file mode 100644
index 0000000..34f9070
--- /dev/null
+++ b/src/frameworks/base/graphics/java/android/graphics/drawable/AnimatedRotateDrawable.java
@@ -0,0 +1,356 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.graphics.drawable;
+
+import android.graphics.Canvas;
+import android.graphics.Rect;
+import android.graphics.ColorFilter;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.util.AttributeSet;
+import android.util.TypedValue;
+import android.util.Log;
+import android.os.SystemClock;
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import java.io.IOException;
+
+import com.android.internal.R;
+
+/**
+ * @hide
+ */
+public class AnimatedRotateDrawable extends Drawable implements Drawable.Callback, Runnable,
+        Animatable {
+
+    private AnimatedRotateState mState;
+    private boolean mMutated;
+    private float mCurrentDegrees;
+    private float mIncrement;
+    private boolean mRunning;
+
+    public AnimatedRotateDrawable() {
+        this(null, null);
+    }
+
+    private AnimatedRotateDrawable(AnimatedRotateState rotateState, Resources res) {
+        mState = new AnimatedRotateState(rotateState, this, res);
+        init();
+    }
+
+    private void init() {
+        final AnimatedRotateState state = mState;
+        mIncrement = 360.0f / state.mFramesCount;
+        final Drawable drawable = state.mDrawable;
+        if (drawable != null) {
+            drawable.setFilterBitmap(true);
+            if (drawable instanceof BitmapDrawable) {
+                ((BitmapDrawable) drawable).setAntiAlias(true);
+            }
+        }
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        int saveCount = canvas.save();
+
+        final AnimatedRotateState st = mState;
+        final Drawable drawable = st.mDrawable;
+        final Rect bounds = drawable.getBounds();
+
+        int w = bounds.right - bounds.left;
+        int h = bounds.bottom - bounds.top;
+
+        float px = st.mPivotXRel ? (w * st.mPivotX) : st.mPivotX;
+        float py = st.mPivotYRel ? (h * st.mPivotY) : st.mPivotY;
+
+        canvas.rotate(mCurrentDegrees, px + bounds.left, py + bounds.top);
+
+        drawable.draw(canvas);
+
+        canvas.restoreToCount(saveCount);
+    }
+
+    public void start() {
+        if (!mRunning) {
+            mRunning = true;
+            nextFrame();
+        }
+    }
+
+    public void stop() {
+        mRunning = false;
+        unscheduleSelf(this);
+    }
+
+    public boolean isRunning() {
+        return mRunning;
+    }
+
+    private void nextFrame() {
+        unscheduleSelf(this);
+        scheduleSelf(this, SystemClock.uptimeMillis() + mState.mFrameDuration);
+    }
+    
+    public void run() {
+        // TODO: This should be computed in draw(Canvas), based on the amount
+        // of time since the last frame drawn 
+        mCurrentDegrees += mIncrement;
+        if (mCurrentDegrees > (360.0f - mIncrement)) {
+            mCurrentDegrees = 0.0f;
+        }
+        invalidateSelf();
+        nextFrame();
+    }
+    
+    @Override
+    public boolean setVisible(boolean visible, boolean restart) {
+        mState.mDrawable.setVisible(visible, restart);
+        boolean changed = super.setVisible(visible, restart);
+        if (visible) {
+            if (changed || restart) {
+                mCurrentDegrees = 0.0f;
+                nextFrame();
+            }
+        } else {
+            unscheduleSelf(this);
+        }
+        return changed;
+    }    
+    
+    /**
+     * Returns the drawable rotated by this RotateDrawable.
+     */
+    public Drawable getDrawable() {
+        return mState.mDrawable;
+    }
+
+    @Override
+    public int getChangingConfigurations() {
+        return super.getChangingConfigurations()
+                | mState.mChangingConfigurations
+                | mState.mDrawable.getChangingConfigurations();
+    }
+    
+    @Override
+    public void setAlpha(int alpha) {
+        mState.mDrawable.setAlpha(alpha);
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+        mState.mDrawable.setColorFilter(cf);
+    }
+
+    @Override
+    public int getOpacity() {
+        return mState.mDrawable.getOpacity();
+    }
+
+    public void invalidateDrawable(Drawable who) {
+        final Callback callback = getCallback();
+        if (callback != null) {
+            callback.invalidateDrawable(this);
+        }
+    }
+
+    public void scheduleDrawable(Drawable who, Runnable what, long when) {
+        final Callback callback = getCallback();
+        if (callback != null) {
+            callback.scheduleDrawable(this, what, when);
+        }
+    }
+
+    public void unscheduleDrawable(Drawable who, Runnable what) {
+        final Callback callback = getCallback();
+        if (callback != null) {
+            callback.unscheduleDrawable(this, what);
+        }
+    }
+
+    @Override
+    public boolean getPadding(Rect padding) {
+        return mState.mDrawable.getPadding(padding);
+    }
+    
+    @Override
+    public boolean isStateful() {
+        return mState.mDrawable.isStateful();
+    }
+
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        mState.mDrawable.setBounds(bounds.left, bounds.top, bounds.right, bounds.bottom);
+    }
+
+    @Override
+    public int getIntrinsicWidth() {
+        return mState.mDrawable.getIntrinsicWidth();
+    }
+
+    @Override
+    public int getIntrinsicHeight() {
+        return mState.mDrawable.getIntrinsicHeight();
+    }
+
+    @Override
+    public ConstantState getConstantState() {
+        if (mState.canConstantState()) {
+            mState.mChangingConfigurations = getChangingConfigurations();
+            return mState;
+        }
+        return null;
+    }
+
+    @Override
+    public void inflate(Resources r, XmlPullParser parser, AttributeSet attrs)
+            throws XmlPullParserException, IOException {
+
+        final TypedArray a = r.obtainAttributes(attrs, R.styleable.AnimatedRotateDrawable);
+
+        super.inflateWithAttributes(r, parser, a, R.styleable.AnimatedRotateDrawable_visible);
+        
+        TypedValue tv = a.peekValue(R.styleable.AnimatedRotateDrawable_pivotX);
+        final boolean pivotXRel = tv.type == TypedValue.TYPE_FRACTION;
+        final float pivotX = pivotXRel ? tv.getFraction(1.0f, 1.0f) : tv.getFloat();
+        
+        tv = a.peekValue(R.styleable.AnimatedRotateDrawable_pivotY);
+        final boolean pivotYRel = tv.type == TypedValue.TYPE_FRACTION;
+        final float pivotY = pivotYRel ? tv.getFraction(1.0f, 1.0f) : tv.getFloat();
+
+        setFramesCount(a.getInt(R.styleable.AnimatedRotateDrawable_framesCount, 12));
+        setFramesDuration(a.getInt(R.styleable.AnimatedRotateDrawable_frameDuration, 150));
+
+        final int res = a.getResourceId(R.styleable.AnimatedRotateDrawable_drawable, 0);
+        Drawable drawable = null;
+        if (res > 0) {
+            drawable = r.getDrawable(res);
+        }
+
+        a.recycle();
+        
+        int outerDepth = parser.getDepth();
+        int type;
+        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &&
+               (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
+
+            if (type != XmlPullParser.START_TAG) {
+                continue;
+            }
+
+            if ((drawable = Drawable.createFromXmlInner(r, parser, attrs)) == null) {
+                Log.w("drawable", "Bad element under <animated-rotate>: "
+                        + parser .getName());
+            }
+        }
+
+        if (drawable == null) {
+            Log.w("drawable", "No drawable specified for <animated-rotate>");
+        }
+
+        final AnimatedRotateState rotateState = mState;
+        rotateState.mDrawable = drawable;
+        rotateState.mPivotXRel = pivotXRel;
+        rotateState.mPivotX = pivotX;
+        rotateState.mPivotYRel = pivotYRel;
+        rotateState.mPivotY = pivotY;
+
+        init();
+
+        if (drawable != null) {
+            drawable.setCallback(this);
+        }
+    }
+
+    public void setFramesCount(int framesCount) {
+        mState.mFramesCount = framesCount;
+        mIncrement = 360.0f / mState.mFramesCount;
+    }
+
+    public void setFramesDuration(int framesDuration) {
+        mState.mFrameDuration = framesDuration;
+    }
+
+    @Override
+    public Drawable mutate() {
+        if (!mMutated && super.mutate() == this) {
+            mState.mDrawable.mutate();
+            mMutated = true;
+        }
+        return this;
+    }
+
+    final static class AnimatedRotateState extends Drawable.ConstantState {
+        Drawable mDrawable;
+
+        int mChangingConfigurations;
+        
+        boolean mPivotXRel;
+        float mPivotX;
+        boolean mPivotYRel;
+        float mPivotY;
+        int mFrameDuration;
+        int mFramesCount;
+
+        private boolean mCanConstantState;
+        private boolean mCheckedConstantState;        
+
+        public AnimatedRotateState(AnimatedRotateState source, AnimatedRotateDrawable owner,
+                Resources res) {
+            if (source != null) {
+                if (res != null) {
+                    mDrawable = source.mDrawable.getConstantState().newDrawable(res);
+                } else {
+                    mDrawable = source.mDrawable.getConstantState().newDrawable();
+                }
+                mDrawable.setCallback(owner);
+                mPivotXRel = source.mPivotXRel;
+                mPivotX = source.mPivotX;
+                mPivotYRel = source.mPivotYRel;
+                mPivotY = source.mPivotY;
+                mFramesCount = source.mFramesCount;
+                mFrameDuration = source.mFrameDuration;
+                mCanConstantState = mCheckedConstantState = true;
+            }
+        }
+
+        @Override
+        public Drawable newDrawable() {
+            return new AnimatedRotateDrawable(this, null);
+        }
+        
+        @Override
+        public Drawable newDrawable(Resources res) {
+            return new AnimatedRotateDrawable(this, res);
+        }
+        
+        @Override
+        public int getChangingConfigurations() {
+            return mChangingConfigurations;
+        }
+
+        public boolean canConstantState() {
+            if (!mCheckedConstantState) {
+                mCanConstantState = mDrawable.getConstantState() != null;
+                mCheckedConstantState = true;
+            }
+
+            return mCanConstantState;
+        }
+    }
+}
diff --git a/src/frameworks/base/graphics/java/android/graphics/drawable/Drawable.java b/src/frameworks/base/graphics/java/android/graphics/drawable/Drawable.java
new file mode 100644
index 0000000..785582c
--- /dev/null
+++ b/src/frameworks/base/graphics/java/android/graphics/drawable/Drawable.java
@@ -0,0 +1,986 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.graphics.drawable;
+
+import android.graphics.Insets;
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Canvas;
+import android.graphics.ColorFilter;
+import android.graphics.NinePatch;
+import android.graphics.PixelFormat;
+import android.graphics.PorterDuff;
+import android.graphics.PorterDuffColorFilter;
+import android.graphics.Rect;
+import android.graphics.Region;
+import android.util.AttributeSet;
+import android.util.DisplayMetrics;
+import android.util.StateSet;
+import android.util.TypedValue;
+import android.util.Xml;
+import android.view.View;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.ref.WeakReference;
+import java.util.Arrays;
+
+/**
+ * A Drawable is a general abstraction for "something that can be drawn."  Most
+ * often you will deal with Drawable as the type of resource retrieved for
+ * drawing things to the screen; the Drawable class provides a generic API for
+ * dealing with an underlying visual resource that may take a variety of forms.
+ * Unlike a {@link android.view.View}, a Drawable does not have any facility to
+ * receive events or otherwise interact with the user.
+ *
+ * <p>In addition to simple drawing, Drawable provides a number of generic
+ * mechanisms for its client to interact with what is being drawn:
+ *
+ * <ul>
+ *     <li> The {@link #setBounds} method <var>must</var> be called to tell the
+ *     Drawable where it is drawn and how large it should be.  All Drawables
+ *     should respect the requested size, often simply by scaling their
+ *     imagery.  A client can find the preferred size for some Drawables with
+ *     the {@link #getIntrinsicHeight} and {@link #getIntrinsicWidth} methods.
+ *
+ *     <li> The {@link #getPadding} method can return from some Drawables
+ *     information about how to frame content that is placed inside of them.
+ *     For example, a Drawable that is intended to be the frame for a button
+ *     widget would need to return padding that correctly places the label
+ *     inside of itself.
+ *
+ *     <li> The {@link #setState} method allows the client to tell the Drawable
+ *     in which state it is to be drawn, such as "focused", "selected", etc.
+ *     Some drawables may modify their imagery based on the selected state.
+ *
+ *     <li> The {@link #setLevel} method allows the client to supply a single
+ *     continuous controller that can modify the Drawable is displayed, such as
+ *     a battery level or progress level.  Some drawables may modify their
+ *     imagery based on the current level.
+ *
+ *     <li> A Drawable can perform animations by calling back to its client
+ *     through the {@link Callback} interface.  All clients should support this
+ *     interface (via {@link #setCallback}) so that animations will work.  A
+ *     simple way to do this is through the system facilities such as
+ *     {@link android.view.View#setBackgroundDrawable(Drawable)} and
+ *     {@link android.widget.ImageView}.
+ * </ul>
+ *
+ * Though usually not visible to the application, Drawables may take a variety
+ * of forms:
+ *
+ * <ul>
+ *     <li> <b>Bitmap</b>: the simplest Drawable, a PNG or JPEG image.
+ *     <li> <b>Nine Patch</b>: an extension to the PNG format allows it to
+ *     specify information about how to stretch it and place things inside of
+ *     it.
+ *     <li> <b>Shape</b>: contains simple drawing commands instead of a raw
+ *     bitmap, allowing it to resize better in some cases.
+ *     <li> <b>Layers</b>: a compound drawable, which draws multiple underlying
+ *     drawables on top of each other.
+ *     <li> <b>States</b>: a compound drawable that selects one of a set of
+ *     drawables based on its state.
+ *     <li> <b>Levels</b>: a compound drawable that selects one of a set of
+ *     drawables based on its level.
+ *     <li> <b>Scale</b>: a compound drawable with a single child drawable,
+ *     whose overall size is modified based on the current level.
+ * </ul>
+ *
+ * <div class="special reference">
+ * <h3>Developer Guides</h3>
+ * <p>For more information about how to use drawables, read the
+ * <a href="{@docRoot}guide/topics/graphics/2d-graphics.html">Canvas and Drawables</a> developer
+ * guide. For information and examples of creating drawable resources (XML or bitmap files that
+ * can be loaded in code), read the
+ * <a href="{@docRoot}guide/topics/resources/drawable-resource.html">Drawable Resources</a>
+ * document.</p></div>
+ */
+public abstract class Drawable {
+    private static final Rect ZERO_BOUNDS_RECT = new Rect();
+
+    private int[] mStateSet = StateSet.WILD_CARD;
+    private int mLevel = 0;
+    private int mChangingConfigurations = 0;
+    private Rect mBounds = ZERO_BOUNDS_RECT;  // lazily becomes a new Rect()
+    private WeakReference<Callback> mCallback = null;
+    private boolean mVisible = true;
+
+    /**
+     * Draw in its bounds (set via setBounds) respecting optional effects such
+     * as alpha (set via setAlpha) and color filter (set via setColorFilter).
+     *
+     * @param canvas The canvas to draw into
+     */
+    public abstract void draw(Canvas canvas);
+
+    /**
+     * Specify a bounding rectangle for the Drawable. This is where the drawable
+     * will draw when its draw() method is called.
+     */
+    public void setBounds(int left, int top, int right, int bottom) {
+        Rect oldBounds = mBounds;
+
+        if (oldBounds == ZERO_BOUNDS_RECT) {
+            oldBounds = mBounds = new Rect();
+        }
+
+        if (oldBounds.left != left || oldBounds.top != top ||
+                oldBounds.right != right || oldBounds.bottom != bottom) {
+            mBounds.set(left, top, right, bottom);
+            onBoundsChange(mBounds);
+        }
+    }
+
+    /**
+     * Specify a bounding rectangle for the Drawable. This is where the drawable
+     * will draw when its draw() method is called.
+     */
+    public void setBounds(Rect bounds) {
+        setBounds(bounds.left, bounds.top, bounds.right, bounds.bottom);
+    }
+
+    /**
+     * Return a copy of the drawable's bounds in the specified Rect (allocated
+     * by the caller). The bounds specify where this will draw when its draw()
+     * method is called.
+     *
+     * @param bounds Rect to receive the drawable's bounds (allocated by the
+     *               caller).
+     */
+    public final void copyBounds(Rect bounds) {
+        bounds.set(mBounds);
+    }
+
+    /**
+     * Return a copy of the drawable's bounds in a new Rect. This returns the
+     * same values as getBounds(), but the returned object is guaranteed to not
+     * be changed later by the drawable (i.e. it retains no reference to this
+     * rect). If the caller already has a Rect allocated, call copyBounds(rect).
+     *
+     * @return A copy of the drawable's bounds
+     */
+    public final Rect copyBounds() {
+        return new Rect(mBounds);
+    }
+
+    /**
+     * Return the drawable's bounds Rect. Note: for efficiency, the returned
+     * object may be the same object stored in the drawable (though this is not
+     * guaranteed), so if a persistent copy of the bounds is needed, call
+     * copyBounds(rect) instead.
+     * You should also not change the object returned by this method as it may
+     * be the same object stored in the drawable.
+     *
+     * @return The bounds of the drawable (which may change later, so caller
+     *         beware). DO NOT ALTER the returned object as it may change the
+     *         stored bounds of this drawable.
+     *
+     * @see #copyBounds()
+     * @see #copyBounds(android.graphics.Rect) 
+     */
+    public final Rect getBounds() {
+        if (mBounds == ZERO_BOUNDS_RECT) {
+            mBounds = new Rect();
+        }
+
+        return mBounds;
+    }
+
+    /**
+     * Set a mask of the configuration parameters for which this drawable
+     * may change, requiring that it be re-created.
+     *
+     * @param configs A mask of the changing configuration parameters, as
+     * defined by {@link android.content.res.Configuration}.
+     *
+     * @see android.content.res.Configuration
+     */
+    public void setChangingConfigurations(int configs) {
+        mChangingConfigurations = configs;
+    }
+
+    /**
+     * Return a mask of the configuration parameters for which this drawable
+     * may change, requiring that it be re-created.  The default implementation
+     * returns whatever was provided through
+     * {@link #setChangingConfigurations(int)} or 0 by default.  Subclasses
+     * may extend this to or in the changing configurations of any other
+     * drawables they hold.
+     *
+     * @return Returns a mask of the changing configuration parameters, as
+     * defined by {@link android.content.res.Configuration}.
+     *
+     * @see android.content.res.Configuration
+     */
+    public int getChangingConfigurations() {
+        return mChangingConfigurations;
+    }
+
+    /**
+     * Set to true to have the drawable dither its colors when drawn to a device
+     * with fewer than 8-bits per color component. This can improve the look on
+     * those devices, but can also slow down the drawing a little.
+     */
+    public void setDither(boolean dither) {}
+
+    /**
+     * Set to true to have the drawable filter its bitmap when scaled or rotated
+     * (for drawables that use bitmaps). If the drawable does not use bitmaps,
+     * this call is ignored. This can improve the look when scaled or rotated,
+     * but also slows down the drawing.
+     */
+    public void setFilterBitmap(boolean filter) {}
+
+    /**
+     * Implement this interface if you want to create an animated drawable that
+     * extends {@link android.graphics.drawable.Drawable Drawable}.
+     * Upon retrieving a drawable, use
+     * {@link Drawable#setCallback(android.graphics.drawable.Drawable.Callback)}
+     * to supply your implementation of the interface to the drawable; it uses
+     * this interface to schedule and execute animation changes.
+     */
+    public static interface Callback {
+        /**
+         * Called when the drawable needs to be redrawn.  A view at this point
+         * should invalidate itself (or at least the part of itself where the
+         * drawable appears).
+         *
+         * @param who The drawable that is requesting the update.
+         */
+        public void invalidateDrawable(Drawable who);
+
+        /**
+         * A Drawable can call this to schedule the next frame of its
+         * animation.  An implementation can generally simply call
+         * {@link android.os.Handler#postAtTime(Runnable, Object, long)} with
+         * the parameters <var>(what, who, when)</var> to perform the
+         * scheduling.
+         *
+         * @param who The drawable being scheduled.
+         * @param what The action to execute.
+         * @param when The time (in milliseconds) to run.  The timebase is
+         *             {@link android.os.SystemClock#uptimeMillis}
+         */
+        public void scheduleDrawable(Drawable who, Runnable what, long when);
+
+        /**
+         * A Drawable can call this to unschedule an action previously
+         * scheduled with {@link #scheduleDrawable}.  An implementation can
+         * generally simply call
+         * {@link android.os.Handler#removeCallbacks(Runnable, Object)} with
+         * the parameters <var>(what, who)</var> to unschedule the drawable.
+         *
+         * @param who The drawable being unscheduled.
+         * @param what The action being unscheduled.
+         */
+        public void unscheduleDrawable(Drawable who, Runnable what);
+    }
+
+    /**
+     * Implement this interface if you want to create an drawable that is RTL aware
+     * @hide
+     */
+    public static interface Callback2 extends Callback {
+        /**
+         * A Drawable can call this to get the resolved layout direction of the <var>who</var>.
+         *
+         * @param who The drawable being queried.
+         */
+        public int getResolvedLayoutDirection(Drawable who);
+    }
+
+    /**
+     * Bind a {@link Callback} object to this Drawable.  Required for clients
+     * that want to support animated drawables.
+     *
+     * @param cb The client's Callback implementation.
+     * 
+     * @see #getCallback() 
+     */
+    public final void setCallback(Callback cb) {
+        mCallback = new WeakReference<Callback>(cb);
+    }
+
+    /**
+     * Return the current {@link Callback} implementation attached to this
+     * Drawable.
+     * 
+     * @return A {@link Callback} instance or null if no callback was set.
+     * 
+     * @see #setCallback(android.graphics.drawable.Drawable.Callback) 
+     */
+    public Callback getCallback() {
+        if (mCallback != null) {
+            return mCallback.get();
+        }
+        return null;
+    }
+    
+    /**
+     * Use the current {@link Callback} implementation to have this Drawable
+     * redrawn.  Does nothing if there is no Callback attached to the
+     * Drawable.
+     *
+     * @see Callback#invalidateDrawable
+     * @see #getCallback() 
+     * @see #setCallback(android.graphics.drawable.Drawable.Callback) 
+     */
+    public void invalidateSelf() {
+        final Callback callback = getCallback();
+        if (callback != null) {
+            callback.invalidateDrawable(this);
+        }
+    }
+
+    /**
+     * Use the current {@link Callback} implementation to have this Drawable
+     * scheduled.  Does nothing if there is no Callback attached to the
+     * Drawable.
+     *
+     * @param what The action being scheduled.
+     * @param when The time (in milliseconds) to run.
+     *
+     * @see Callback#scheduleDrawable
+     */
+    public void scheduleSelf(Runnable what, long when) {
+        final Callback callback = getCallback();
+        if (callback != null) {
+            callback.scheduleDrawable(this, what, when);
+        }
+    }
+
+    /**
+     * Use the current {@link Callback} implementation to have this Drawable
+     * unscheduled.  Does nothing if there is no Callback attached to the
+     * Drawable.
+     *
+     * @param what The runnable that you no longer want called.
+     *
+     * @see Callback#unscheduleDrawable
+     */
+    public void unscheduleSelf(Runnable what) {
+        final Callback callback = getCallback();
+        if (callback != null) {
+            callback.unscheduleDrawable(this, what);
+        }
+    }
+
+    /**
+     * Get the resolved layout direction of this Drawable.
+     * @hide
+     */
+    public int getResolvedLayoutDirectionSelf() {
+        final Callback callback = getCallback();
+        if (callback == null || !(callback instanceof Callback2)) {
+            return View.LAYOUT_DIRECTION_LTR;
+        }
+        return ((Callback2) callback).getResolvedLayoutDirection(this);
+    }
+
+    /**
+     * Specify an alpha value for the drawable. 0 means fully transparent, and
+     * 255 means fully opaque.
+     */
+    public abstract void setAlpha(int alpha);
+
+    /**
+     * Specify an optional colorFilter for the drawable. Pass null to remove
+     * any filters.
+    */
+    public abstract void setColorFilter(ColorFilter cf);
+
+    /**
+     * Specify a color and porterduff mode to be the colorfilter for this
+     * drawable.
+     */
+    public void setColorFilter(int color, PorterDuff.Mode mode) {
+        setColorFilter(new PorterDuffColorFilter(color, mode));
+    }
+
+    public void clearColorFilter() {
+        setColorFilter(null);
+    }
+
+    /**
+     * Indicates whether this view will change its appearance based on state.
+     * Clients can use this to determine whether it is necessary to calculate
+     * their state and call setState.
+     *
+     * @return True if this view changes its appearance based on state, false
+     *         otherwise.
+     *
+     * @see #setState(int[])
+     */
+    public boolean isStateful() {
+        return false;
+    }
+
+    /**
+     * Specify a set of states for the drawable. These are use-case specific,
+     * so see the relevant documentation. As an example, the background for
+     * widgets like Button understand the following states:
+     * [{@link android.R.attr#state_focused},
+     *  {@link android.R.attr#state_pressed}].
+     *
+     * <p>If the new state you are supplying causes the appearance of the
+     * Drawable to change, then it is responsible for calling
+     * {@link #invalidateSelf} in order to have itself redrawn, <em>and</em>
+     * true will be returned from this function.
+     *
+     * <p>Note: The Drawable holds a reference on to <var>stateSet</var>
+     * until a new state array is given to it, so you must not modify this
+     * array during that time.</p>
+     *
+     * @param stateSet The new set of states to be displayed.
+     *
+     * @return Returns true if this change in state has caused the appearance
+     * of the Drawable to change (hence requiring an invalidate), otherwise
+     * returns false.
+     */
+    public boolean setState(final int[] stateSet) {
+        if (!Arrays.equals(mStateSet, stateSet)) {
+            mStateSet = stateSet;
+            return onStateChange(stateSet);
+        }
+        return false;
+    }
+
+    /**
+     * Describes the current state, as a union of primitve states, such as
+     * {@link android.R.attr#state_focused},
+     * {@link android.R.attr#state_selected}, etc.
+     * Some drawables may modify their imagery based on the selected state.
+     * @return An array of resource Ids describing the current state.
+     */
+    public int[] getState() {
+        return mStateSet;
+    }
+
+    /**
+     * If this Drawable does transition animations between states, ask that
+     * it immediately jump to the current state and skip any active animations.
+     */
+    public void jumpToCurrentState() {
+    }
+
+    /**
+     * @return The current drawable that will be used by this drawable. For simple drawables, this
+     *         is just the drawable itself. For drawables that change state like
+     *         {@link StateListDrawable} and {@link LevelListDrawable} this will be the child drawable
+     *         currently in use.
+     */
+    public Drawable getCurrent() {
+        return this;
+    }
+
+    /**
+     * Specify the level for the drawable.  This allows a drawable to vary its
+     * imagery based on a continuous controller, for example to show progress
+     * or volume level.
+     *
+     * <p>If the new level you are supplying causes the appearance of the
+     * Drawable to change, then it is responsible for calling
+     * {@link #invalidateSelf} in order to have itself redrawn, <em>and</em>
+     * true will be returned from this function.
+     *
+     * @param level The new level, from 0 (minimum) to 10000 (maximum).
+     *
+     * @return Returns true if this change in level has caused the appearance
+     * of the Drawable to change (hence requiring an invalidate), otherwise
+     * returns false.
+     */
+    public final boolean setLevel(int level) {
+        if (mLevel != level) {
+            mLevel = level;
+            return onLevelChange(level);
+        }
+        return false;
+    }
+
+    /**
+     * Retrieve the current level.
+     *
+     * @return int Current level, from 0 (minimum) to 10000 (maximum).
+     */
+    public final int getLevel() {
+        return mLevel;
+    }
+
+    /**
+     * Set whether this Drawable is visible.  This generally does not impact
+     * the Drawable's behavior, but is a hint that can be used by some
+     * Drawables, for example, to decide whether run animations.
+     *
+     * @param visible Set to true if visible, false if not.
+     * @param restart You can supply true here to force the drawable to behave
+     *                as if it has just become visible, even if it had last
+     *                been set visible.  Used for example to force animations
+     *                to restart.
+     *
+     * @return boolean Returns true if the new visibility is different than
+     *         its previous state.
+     */
+    public boolean setVisible(boolean visible, boolean restart) {
+        boolean changed = mVisible != visible;
+        if (changed) {
+            mVisible = visible;
+            invalidateSelf();
+        }
+        return changed;
+    }
+
+    public final boolean isVisible() {
+        return mVisible;
+    }
+
+    /**
+     * Return the opacity/transparency of this Drawable.  The returned value is
+     * one of the abstract format constants in
+     * {@link android.graphics.PixelFormat}:
+     * {@link android.graphics.PixelFormat#UNKNOWN},
+     * {@link android.graphics.PixelFormat#TRANSLUCENT},
+     * {@link android.graphics.PixelFormat#TRANSPARENT}, or
+     * {@link android.graphics.PixelFormat#OPAQUE}.
+     *
+     * <p>Generally a Drawable should be as conservative as possible with the
+     * value it returns.  For example, if it contains multiple child drawables
+     * and only shows one of them at a time, if only one of the children is
+     * TRANSLUCENT and the others are OPAQUE then TRANSLUCENT should be
+     * returned.  You can use the method {@link #resolveOpacity} to perform a
+     * standard reduction of two opacities to the appropriate single output.
+     *
+     * <p>Note that the returned value does <em>not</em> take into account a
+     * custom alpha or color filter that has been applied by the client through
+     * the {@link #setAlpha} or {@link #setColorFilter} methods.
+     *
+     * @return int The opacity class of the Drawable.
+     *
+     * @see android.graphics.PixelFormat
+     */
+    public abstract int getOpacity();
+
+    /**
+     * Return the appropriate opacity value for two source opacities.  If
+     * either is UNKNOWN, that is returned; else, if either is TRANSLUCENT,
+     * that is returned; else, if either is TRANSPARENT, that is returned;
+     * else, OPAQUE is returned.
+     *
+     * <p>This is to help in implementing {@link #getOpacity}.
+     *
+     * @param op1 One opacity value.
+     * @param op2 Another opacity value.
+     *
+     * @return int The combined opacity value.
+     *
+     * @see #getOpacity
+     */
+    public static int resolveOpacity(int op1, int op2) {
+        if (op1 == op2) {
+            return op1;
+        }
+        if (op1 == PixelFormat.UNKNOWN || op2 == PixelFormat.UNKNOWN) {
+            return PixelFormat.UNKNOWN;
+        }
+        if (op1 == PixelFormat.TRANSLUCENT || op2 == PixelFormat.TRANSLUCENT) {
+            return PixelFormat.TRANSLUCENT;
+        }
+        if (op1 == PixelFormat.TRANSPARENT || op2 == PixelFormat.TRANSPARENT) {
+            return PixelFormat.TRANSPARENT;
+        }
+        return PixelFormat.OPAQUE;
+    }
+
+    /**
+     * Returns a Region representing the part of the Drawable that is completely
+     * transparent.  This can be used to perform drawing operations, identifying
+     * which parts of the target will not change when rendering the Drawable.
+     * The default implementation returns null, indicating no transparent
+     * region; subclasses can optionally override this to return an actual
+     * Region if they want to supply this optimization information, but it is
+     * not required that they do so.
+     *
+     * @return Returns null if the Drawables has no transparent region to
+     * report, else a Region holding the parts of the Drawable's bounds that
+     * are transparent.
+     */
+    public Region getTransparentRegion() {
+        return null;
+    }
+
+    /**
+     * Override this in your subclass to change appearance if you recognize the
+     * specified state.
+     *
+     * @return Returns true if the state change has caused the appearance of
+     * the Drawable to change (that is, it needs to be drawn), else false
+     * if it looks the same and there is no need to redraw it since its
+     * last state.
+     */
+    protected boolean onStateChange(int[] state) { return false; }
+    /** Override this in your subclass to change appearance if you vary based
+     *  on level.
+     * @return Returns true if the level change has caused the appearance of
+     * the Drawable to change (that is, it needs to be drawn), else false
+     * if it looks the same and there is no need to redraw it since its
+     * last level.
+     */
+    protected boolean onLevelChange(int level) { return false; }
+    /**
+     * Override this in your subclass to change appearance if you recognize the
+     * specified state.
+     */
+    protected void onBoundsChange(Rect bounds) {}
+
+    /**
+     * Return the intrinsic width of the underlying drawable object.  Returns
+     * -1 if it has no intrinsic width, such as with a solid color.
+     */
+    public int getIntrinsicWidth() {
+        return -1;
+    }
+
+    /**
+     * Return the intrinsic height of the underlying drawable object. Returns
+     * -1 if it has no intrinsic height, such as with a solid color.
+     */
+    public int getIntrinsicHeight() {
+        return -1;
+    }
+
+    /**
+     * Returns the minimum width suggested by this Drawable. If a View uses this
+     * Drawable as a background, it is suggested that the View use at least this
+     * value for its width. (There will be some scenarios where this will not be
+     * possible.) This value should INCLUDE any padding.
+     *
+     * @return The minimum width suggested by this Drawable. If this Drawable
+     *         doesn't have a suggested minimum width, 0 is returned.
+     */
+    public int getMinimumWidth() {
+        final int intrinsicWidth = getIntrinsicWidth();
+        return intrinsicWidth > 0 ? intrinsicWidth : 0;
+    }
+
+    /**
+     * Returns the minimum height suggested by this Drawable. If a View uses this
+     * Drawable as a background, it is suggested that the View use at least this
+     * value for its height. (There will be some scenarios where this will not be
+     * possible.) This value should INCLUDE any padding.
+     *
+     * @return The minimum height suggested by this Drawable. If this Drawable
+     *         doesn't have a suggested minimum height, 0 is returned.
+     */
+    public int getMinimumHeight() {
+        final int intrinsicHeight = getIntrinsicHeight();
+        return intrinsicHeight > 0 ? intrinsicHeight : 0;
+    }
+
+    /**
+     * Return in padding the insets suggested by this Drawable for placing
+     * content inside the drawable's bounds. Positive values move toward the
+     * center of the Drawable (set Rect.inset). Returns true if this drawable
+     * actually has a padding, else false. When false is returned, the padding
+     * is always set to 0.
+     */
+    public boolean getPadding(Rect padding) {
+        padding.set(0, 0, 0, 0);
+        return false;
+    }
+
+    /**
+     * Return in insets the layout insets suggested by this Drawable for use with alignment
+     * operations during layout.
+     *
+     * @hide
+     */
+    public Insets getLayoutInsets() {
+        return Insets.NONE;
+    }
+
+    /**
+     * Make this drawable mutable. This operation cannot be reversed. A mutable
+     * drawable is guaranteed to not share its state with any other drawable.
+     * This is especially useful when you need to modify properties of drawables
+     * loaded from resources. By default, all drawables instances loaded from
+     * the same resource share a common state; if you modify the state of one
+     * instance, all the other instances will receive the same modification.
+     *
+     * Calling this method on a mutable Drawable will have no effect.
+     *
+     * @return This drawable.
+     * @see ConstantState
+     * @see #getConstantState()
+     */
+    public Drawable mutate() {
+        return this;
+    }
+
+    /**
+     * Create a drawable from an inputstream
+     */
+    public static Drawable createFromStream(InputStream is, String srcName) {
+        return createFromResourceStream(null, null, is, srcName, null);
+    }
+
+    /**
+     * Create a drawable from an inputstream, using the given resources and
+     * value to determine density information.
+     */
+    public static Drawable createFromResourceStream(Resources res, TypedValue value,
+            InputStream is, String srcName) {
+        return createFromResourceStream(res, value, is, srcName, null);
+    }
+
+    /**
+     * Create a drawable from an inputstream, using the given resources and
+     * value to determine density information.
+     */
+    public static Drawable createFromResourceStream(Resources res, TypedValue value,
+            InputStream is, String srcName, BitmapFactory.Options opts) {
+
+        if (is == null) {
+            return null;
+        }
+
+        /*  ugh. The decodeStream contract is that we have already allocated
+            the pad rect, but if the bitmap does not had a ninepatch chunk,
+            then the pad will be ignored. If we could change this to lazily
+            alloc/assign the rect, we could avoid the GC churn of making new
+            Rects only to drop them on the floor.
+        */
+        Rect pad = new Rect();
+        
+        // Special stuff for compatibility mode: if the target density is not
+        // the same as the display density, but the resource -is- the same as
+        // the display density, then don't scale it down to the target density.
+        // This allows us to load the system's density-correct resources into
+        // an application in compatibility mode, without scaling those down
+        // to the compatibility density only to have them scaled back up when
+        // drawn to the screen.
+        if (opts == null) opts = new BitmapFactory.Options();
+        opts.inScreenDensity = DisplayMetrics.DENSITY_DEVICE;
+        Bitmap  bm = BitmapFactory.decodeResourceStream(res, value, is, pad, opts);
+        if (bm != null) {
+            byte[] np = bm.getNinePatchChunk();
+            if (np == null || !NinePatch.isNinePatchChunk(np)) {
+                np = null;
+                pad = null;
+            }
+            int[] layoutBounds = bm.getLayoutBounds();
+            Rect layoutBoundsRect = null;
+            if (layoutBounds != null) {
+                layoutBoundsRect = new Rect(layoutBounds[0], layoutBounds[1],
+                                             layoutBounds[2], layoutBounds[3]);
+            }
+            return drawableFromBitmap(res, bm, np, pad, layoutBoundsRect, srcName);
+        }
+        return null;
+    }
+
+    /**
+     * Create a drawable from an XML document. For more information on how to
+     * create resources in XML, see
+     * <a href="{@docRoot}guide/topics/resources/drawable-resource.html">Drawable Resources</a>.
+     */
+    public static Drawable createFromXml(Resources r, XmlPullParser parser)
+            throws XmlPullParserException, IOException {
+        AttributeSet attrs = Xml.asAttributeSet(parser);
+
+        int type;
+        while ((type=parser.next()) != XmlPullParser.START_TAG &&
+                type != XmlPullParser.END_DOCUMENT) {
+            // Empty loop
+        }
+
+        if (type != XmlPullParser.START_TAG) {
+            throw new XmlPullParserException("No start tag found");
+        }
+
+        Drawable drawable = createFromXmlInner(r, parser, attrs);
+
+        if (drawable == null) {
+            throw new RuntimeException("Unknown initial tag: " + parser.getName());
+        }
+
+        return drawable;
+    }
+
+    /**
+     * Create from inside an XML document.  Called on a parser positioned at
+     * a tag in an XML document, tries to create a Drawable from that tag.
+     * Returns null if the tag is not a valid drawable.
+     */
+    public static Drawable createFromXmlInner(Resources r, XmlPullParser parser, AttributeSet attrs)
+    throws XmlPullParserException, IOException {
+        Drawable drawable;
+
+        final String name = parser.getName();
+
+        if (name.equals("selector")) {
+            drawable = new StateListDrawable();
+        } else if (name.equals("level-list")) {
+            drawable = new LevelListDrawable();
+        /* Probably not doing this.
+        } else if (name.equals("mipmap")) {
+            drawable = new MipmapDrawable();
+        */
+        } else if (name.equals("layer-list")) {
+            drawable = new LayerDrawable();
+        } else if (name.equals("transition")) {
+            drawable = new TransitionDrawable();
+        } else if (name.equals("color")) {
+            drawable = new ColorDrawable();
+        } else if (name.equals("shape")) {
+            drawable = new GradientDrawable();
+        } else if (name.equals("scale")) {
+            drawable = new ScaleDrawable();
+        } else if (name.equals("clip")) {
+            drawable = new ClipDrawable();
+        } else if (name.equals("rotate")) {
+            drawable = new RotateDrawable();
+        } else if (name.equals("animated-rotate")) {
+            drawable = new AnimatedRotateDrawable();            
+        } else if (name.equals("animation-list")) {
+            drawable = new AnimationDrawable();
+        } else if (name.equals("inset")) {
+            drawable = new InsetDrawable();
+        } else if (name.equals("bitmap")) {
+            drawable = new BitmapDrawable(r);
+            if (r != null) {
+               ((BitmapDrawable) drawable).setTargetDensity(r.getDisplayMetrics());
+            }
+        } else if (name.equals("nine-patch")) {
+            drawable = new NinePatchDrawable();
+            if (r != null) {
+                ((NinePatchDrawable) drawable).setTargetDensity(r.getDisplayMetrics());
+             }
+        } else {
+            throw new XmlPullParserException(parser.getPositionDescription() +
+                    ": invalid drawable tag " + name);
+        }
+
+        drawable.inflate(r, parser, attrs);
+        return drawable;
+    }
+
+
+    /**
+     * Create a drawable from file path name.
+     */
+    public static Drawable createFromPath(String pathName) {
+        if (pathName == null) {
+            return null;
+        }
+
+        Bitmap bm = BitmapFactory.decodeFile(pathName);
+        if (bm != null) {
+            return drawableFromBitmap(null, bm, null, null, null, pathName);
+        }
+
+        return null;
+    }
+
+    /**
+     * Inflate this Drawable from an XML resource.
+     */
+    public void inflate(Resources r, XmlPullParser parser, AttributeSet attrs)
+            throws XmlPullParserException, IOException {
+
+        TypedArray a = r.obtainAttributes(attrs, com.android.internal.R.styleable.Drawable);
+        inflateWithAttributes(r, parser, a, com.android.internal.R.styleable.Drawable_visible);
+        a.recycle();
+    }
+
+    /**
+     * Inflate a Drawable from an XML resource.
+     *
+     * @throws XmlPullParserException
+     * @throws IOException
+     */
+    void inflateWithAttributes(Resources r, XmlPullParser parser,
+            TypedArray attrs, int visibleAttr)
+            throws XmlPullParserException, IOException {
+
+        mVisible = attrs.getBoolean(visibleAttr, mVisible);
+    }
+
+    /**
+     * This abstract class is used by {@link Drawable}s to store shared constant state and data
+     * between Drawables. {@link BitmapDrawable}s created from the same resource will for instance
+     * share a unique bitmap stored in their ConstantState.
+     *
+     * <p>
+     * {@link #newDrawable(Resources)} can be used as a factory to create new Drawable instances
+     * from this ConstantState.
+     * </p>
+     *
+     * Use {@link Drawable#getConstantState()} to retrieve the ConstantState of a Drawable. Calling
+     * {@link Drawable#mutate()} on a Drawable should typically create a new ConstantState for that
+     * Drawable.
+     */
+    public static abstract class ConstantState {
+        /**
+         * Create a new drawable without supplying resources the caller
+         * is running in.  Note that using this means the density-dependent
+         * drawables (like bitmaps) will not be able to update their target
+         * density correctly. One should use {@link #newDrawable(Resources)}
+         * instead to provide a resource.
+         */
+        public abstract Drawable newDrawable();
+        /**
+         * Create a new Drawable instance from its constant state.  This
+         * must be implemented for drawables that change based on the target
+         * density of their caller (that is depending on whether it is
+         * in compatibility mode).
+         */
+        public Drawable newDrawable(Resources res) {
+            return newDrawable();
+        }
+        /**
+         * Return a bit mask of configuration changes that will impact
+         * this drawable (and thus require completely reloading it).
+         */
+        public abstract int getChangingConfigurations();
+    }
+
+    /**
+     * Return a {@link ConstantState} instance that holds the shared state of this Drawable.
+     *q
+     * @return The ConstantState associated to that Drawable.
+     * @see ConstantState
+     * @see Drawable#mutate()
+     */
+    public ConstantState getConstantState() {
+        return null;
+    }
+
+    private static Drawable drawableFromBitmap(Resources res, Bitmap bm, byte[] np,
+            Rect pad, Rect layoutBounds, String srcName) {
+
+        if (np != null) {
+            return new NinePatchDrawable(res, bm, np, pad, layoutBounds, srcName);
+        }
+
+        return new BitmapDrawable(res, bm);
+    }
+}
+
diff --git a/src/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/CommandQueue.java b/src/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/CommandQueue.java
new file mode 100644
index 0000000..a00d95a
--- /dev/null
+++ b/src/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/CommandQueue.java
@@ -0,0 +1,322 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.statusbar;
+
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Message;
+
+import com.android.internal.statusbar.IStatusBar;
+import com.android.internal.statusbar.StatusBarIcon;
+import com.android.internal.statusbar.StatusBarIconList;
+import com.android.internal.statusbar.StatusBarNotification;
+
+/**
+ * This class takes the functions from IStatusBar that come in on
+ * binder pool threads and posts messages to get them onto the main
+ * thread, and calls onto Callbacks.  It also takes care of
+ * coalescing these calls so they don't stack up.  For the calls
+ * are coalesced, note that they are all idempotent.
+ */
+public class CommandQueue extends IStatusBar.Stub {
+    private static final String TAG = "StatusBar.CommandQueue";
+
+    private static final int INDEX_MASK = 0xffff;
+    private static final int MSG_SHIFT  = 16;
+    private static final int MSG_MASK   = 0xffff << MSG_SHIFT;
+
+
+    private static final int MSG_ICON                   = 1 << MSG_SHIFT;
+    private static final int OP_SET_ICON    = 1;
+    private static final int OP_REMOVE_ICON = 2;
+
+    private static final int MSG_ADD_NOTIFICATION       = 2 << MSG_SHIFT;
+    private static final int MSG_UPDATE_NOTIFICATION    = 3 << MSG_SHIFT;
+    private static final int MSG_REMOVE_NOTIFICATION    = 4 << MSG_SHIFT;
+
+    private static final int MSG_DISABLE                = 5 << MSG_SHIFT;
+
+    private static final int MSG_SET_VISIBILITY         = 6 << MSG_SHIFT;
+    private static final int OP_EXPAND      = 1;
+    private static final int OP_COLLAPSE    = 2;
+
+    private static final int MSG_SET_SYSTEMUI_VISIBILITY          = 7 << MSG_SHIFT;
+
+    private static final int MSG_TOP_APP_WINDOW_CHANGED = 8 << MSG_SHIFT;
+    private static final int MSG_SHOW_IME_BUTTON        = 9 << MSG_SHIFT;
+    private static final int MSG_SET_HARD_KEYBOARD_STATUS = 10 << MSG_SHIFT;
+
+    private static final int MSG_TOGGLE_RECENT_APPS       = 11 << MSG_SHIFT;
+    private static final int MSG_PRELOAD_RECENT_APPS      = 12 << MSG_SHIFT;
+    private static final int MSG_CANCEL_PRELOAD_RECENT_APPS       = 13 << MSG_SHIFT;
+
+    private static final int MSG_SET_NAVIGATION_ICON_HINTS = 14 << MSG_SHIFT;
+
+    public static final int FLAG_EXCLUDE_NONE = 0;
+    public static final int FLAG_EXCLUDE_SEARCH_PANEL = 1 << 0;
+    public static final int FLAG_EXCLUDE_RECENTS_PANEL = 1 << 1;
+    public static final int FLAG_EXCLUDE_NOTIFICATION_PANEL = 1 << 2;
+    public static final int FLAG_EXCLUDE_INPUT_METHODS_PANEL = 1 << 3;
+    public static final int FLAG_EXCLUDE_COMPAT_MODE_PANEL = 1 << 4;
+
+    private StatusBarIconList mList;
+    private Callbacks mCallbacks;
+    private Handler mHandler = new H();
+
+    private class NotificationQueueEntry {
+        IBinder key;
+        StatusBarNotification notification;
+    }
+
+    /**
+     * These methods are called back on the main thread.
+     */
+    public interface Callbacks {
+        public void addIcon(String slot, int index, int viewIndex, StatusBarIcon icon);
+        public void updateIcon(String slot, int index, int viewIndex,
+                StatusBarIcon old, StatusBarIcon icon);
+        public void removeIcon(String slot, int index, int viewIndex);
+        public void addNotification(IBinder key, StatusBarNotification notification);
+        public void updateNotification(IBinder key, StatusBarNotification notification);
+        public void removeNotification(IBinder key);
+        public void disable(int state);
+        public void animateExpand();
+        public void animateCollapse(int flags);
+        public void setSystemUiVisibility(int vis, int mask);
+        public void topAppWindowChanged(boolean visible);
+        public void setImeWindowStatus(IBinder token, int vis, int backDisposition);
+        public void setHardKeyboardStatus(boolean available, boolean enabled);
+        public void toggleRecentApps();
+        public void preloadRecentApps();
+        public void showSearchPanel();
+        public void hideSearchPanel();
+        public void cancelPreloadRecentApps();
+        public void setNavigationIconHints(int hints);
+    }
+
+    public CommandQueue(Callbacks callbacks, StatusBarIconList list) {
+        mCallbacks = callbacks;
+        mList = list;
+    }
+
+    public void setIcon(int index, StatusBarIcon icon) {
+        synchronized (mList) {
+            int what = MSG_ICON | index;
+            mHandler.removeMessages(what);
+            mHandler.obtainMessage(what, OP_SET_ICON, 0, icon.clone()).sendToTarget();
+        }
+    }
+
+    public void removeIcon(int index) {
+        synchronized (mList) {
+            int what = MSG_ICON | index;
+            mHandler.removeMessages(what);
+            mHandler.obtainMessage(what, OP_REMOVE_ICON, 0, null).sendToTarget();
+        }
+    }
+
+    public void addNotification(IBinder key, StatusBarNotification notification) {
+        synchronized (mList) {
+            NotificationQueueEntry ne = new NotificationQueueEntry();
+            ne.key = key;
+            ne.notification = notification;
+            mHandler.obtainMessage(MSG_ADD_NOTIFICATION, 0, 0, ne).sendToTarget();
+        }
+    }
+
+    public void updateNotification(IBinder key, StatusBarNotification notification) {
+        synchronized (mList) {
+            NotificationQueueEntry ne = new NotificationQueueEntry();
+            ne.key = key;
+            ne.notification = notification;
+            mHandler.obtainMessage(MSG_UPDATE_NOTIFICATION, 0, 0, ne).sendToTarget();
+        }
+    }
+
+    public void removeNotification(IBinder key) {
+        synchronized (mList) {
+            mHandler.obtainMessage(MSG_REMOVE_NOTIFICATION, 0, 0, key).sendToTarget();
+        }
+    }
+
+    public void disable(int state) {
+        synchronized (mList) {
+            mHandler.removeMessages(MSG_DISABLE);
+            mHandler.obtainMessage(MSG_DISABLE, state, 0, null).sendToTarget();
+        }
+    }
+
+    public void animateExpand() {
+        synchronized (mList) {
+            mHandler.removeMessages(MSG_SET_VISIBILITY);
+            mHandler.obtainMessage(MSG_SET_VISIBILITY, OP_EXPAND, 0, null).sendToTarget();
+        }
+    }
+
+    public void animateCollapse() {
+        animateCollapse(CommandQueue.FLAG_EXCLUDE_NONE);
+    }
+
+    public void animateCollapse(int flags) {
+        synchronized (mList) {
+            mHandler.removeMessages(MSG_SET_VISIBILITY);
+            mHandler.obtainMessage(MSG_SET_VISIBILITY, OP_COLLAPSE, flags, null).sendToTarget();
+        }
+    }
+
+    public void setSystemUiVisibility(int vis, int mask) {
+        synchronized (mList) {
+            mHandler.removeMessages(MSG_SET_SYSTEMUI_VISIBILITY);
+            mHandler.obtainMessage(MSG_SET_SYSTEMUI_VISIBILITY, vis, mask, null).sendToTarget();
+        }
+    }
+
+    public void topAppWindowChanged(boolean menuVisible) {
+        synchronized (mList) {
+            mHandler.removeMessages(MSG_TOP_APP_WINDOW_CHANGED);
+            mHandler.obtainMessage(MSG_TOP_APP_WINDOW_CHANGED, menuVisible ? 1 : 0, 0,
+                    null).sendToTarget();
+        }
+    }
+
+    public void setImeWindowStatus(IBinder token, int vis, int backDisposition) {
+        synchronized (mList) {
+            mHandler.removeMessages(MSG_SHOW_IME_BUTTON);
+            mHandler.obtainMessage(MSG_SHOW_IME_BUTTON, vis, backDisposition, token)
+                    .sendToTarget();
+        }
+    }
+
+    public void setHardKeyboardStatus(boolean available, boolean enabled) {
+        synchronized (mList) {
+            mHandler.removeMessages(MSG_SET_HARD_KEYBOARD_STATUS);
+            mHandler.obtainMessage(MSG_SET_HARD_KEYBOARD_STATUS,
+                    available ? 1 : 0, enabled ? 1 : 0).sendToTarget();
+        }
+    }
+
+    public void toggleRecentApps() {
+        synchronized (mList) {
+            mHandler.removeMessages(MSG_TOGGLE_RECENT_APPS);
+            mHandler.obtainMessage(MSG_TOGGLE_RECENT_APPS, 0, 0, null).sendToTarget();
+        }
+    }
+
+    public void preloadRecentApps() {
+        synchronized (mList) {
+            mHandler.removeMessages(MSG_PRELOAD_RECENT_APPS);
+            mHandler.obtainMessage(MSG_PRELOAD_RECENT_APPS, 0, 0, null).sendToTarget();
+        }
+    }
+
+    public void cancelPreloadRecentApps() {
+        synchronized (mList) {
+            mHandler.removeMessages(MSG_CANCEL_PRELOAD_RECENT_APPS);
+            mHandler.obtainMessage(MSG_CANCEL_PRELOAD_RECENT_APPS, 0, 0, null).sendToTarget();
+        }
+    }
+
+    public void setNavigationIconHints(int hints) {
+        synchronized (mList) {
+            mHandler.removeMessages(MSG_SET_NAVIGATION_ICON_HINTS);
+            mHandler.obtainMessage(MSG_SET_NAVIGATION_ICON_HINTS, hints, 0, null).sendToTarget();
+        }
+    }
+
+    private final class H extends Handler {
+        public void handleMessage(Message msg) {
+            final int what = msg.what & MSG_MASK;
+            switch (what) {
+                case MSG_ICON: {
+                    final int index = msg.what & INDEX_MASK;
+                    final int viewIndex = mList.getViewIndex(index);
+                    switch (msg.arg1) {
+                        case OP_SET_ICON: {
+                            StatusBarIcon icon = (StatusBarIcon)msg.obj;
+                            StatusBarIcon old = mList.getIcon(index);
+                            if (old == null) {
+                                mList.setIcon(index, icon);
+                                mCallbacks.addIcon(mList.getSlot(index), index, viewIndex, icon);
+                            } else {
+                                mList.setIcon(index, icon);
+                                mCallbacks.updateIcon(mList.getSlot(index), index, viewIndex,
+                                        old, icon);
+                            }
+                            break;
+                        }
+                        case OP_REMOVE_ICON:
+                            if (mList.getIcon(index) != null) {
+                                mList.removeIcon(index);
+                                mCallbacks.removeIcon(mList.getSlot(index), index, viewIndex);
+                            }
+                            break;
+                    }
+                    break;
+                }
+                case MSG_ADD_NOTIFICATION: {
+                    final NotificationQueueEntry ne = (NotificationQueueEntry)msg.obj;
+                    mCallbacks.addNotification(ne.key, ne.notification);
+                    break;
+                }
+                case MSG_UPDATE_NOTIFICATION: {
+                    final NotificationQueueEntry ne = (NotificationQueueEntry)msg.obj;
+                    mCallbacks.updateNotification(ne.key, ne.notification);
+                    break;
+                }
+                case MSG_REMOVE_NOTIFICATION: {
+                    mCallbacks.removeNotification((IBinder)msg.obj);
+                    break;
+                }
+                case MSG_DISABLE:
+                    mCallbacks.disable(msg.arg1);
+                    break;
+                case MSG_SET_VISIBILITY:
+                    if (msg.arg1 == OP_EXPAND) {
+                        mCallbacks.animateExpand();
+                    } else {
+                        mCallbacks.animateCollapse(msg.arg2);
+                    }
+                    break;
+                case MSG_SET_SYSTEMUI_VISIBILITY:
+                    mCallbacks.setSystemUiVisibility(msg.arg1, msg.arg2);
+                    break;
+                case MSG_TOP_APP_WINDOW_CHANGED:
+                    mCallbacks.topAppWindowChanged(msg.arg1 != 0);
+                    break;
+                case MSG_SHOW_IME_BUTTON:
+                    mCallbacks.setImeWindowStatus((IBinder)msg.obj, msg.arg1, msg.arg2);
+                    break;
+                case MSG_SET_HARD_KEYBOARD_STATUS:
+                    mCallbacks.setHardKeyboardStatus(msg.arg1 != 0, msg.arg2 != 0);
+                    break;
+                case MSG_TOGGLE_RECENT_APPS:
+                    mCallbacks.toggleRecentApps();
+                    break;
+                case MSG_PRELOAD_RECENT_APPS:
+                    mCallbacks.preloadRecentApps();
+                    break;
+                case MSG_CANCEL_PRELOAD_RECENT_APPS:
+                    mCallbacks.cancelPreloadRecentApps();
+                    break;
+                case MSG_SET_NAVIGATION_ICON_HINTS:
+                    mCallbacks.setNavigationIconHints(msg.arg1);
+                    break;
+            }
+        }
+    }
+}
+
diff --git a/src/frameworks/base/services/java/com/android/server/InputMethodManagerService.java b/src/frameworks/base/services/java/com/android/server/InputMethodManagerService.java
new file mode 100644
index 0000000..fdb278d
--- /dev/null
+++ b/src/frameworks/base/services/java/com/android/server/InputMethodManagerService.java
@@ -0,0 +1,3827 @@
+/*
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy of
+ * the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.android.server;
+
+import com.android.internal.content.PackageMonitor;
+import com.android.internal.os.AtomicFile;
+import com.android.internal.os.HandlerCaller;
+import com.android.internal.util.FastXmlSerializer;
+import com.android.internal.view.IInputContext;
+import com.android.internal.view.IInputMethod;
+import com.android.internal.view.IInputMethodCallback;
+import com.android.internal.view.IInputMethodClient;
+import com.android.internal.view.IInputMethodManager;
+import com.android.internal.view.IInputMethodSession;
+import com.android.internal.view.InputBindResult;
+import com.android.server.EventLogTags;
+import com.android.server.wm.WindowManagerService;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlSerializer;
+
+import android.app.ActivityManagerNative;
+import android.app.AlertDialog;
+import android.app.KeyguardManager;
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.DialogInterface.OnCancelListener;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.ServiceConnection;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.pm.ResolveInfo;
+import android.content.pm.ServiceInfo;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.database.ContentObserver;
+import android.inputmethodservice.InputMethodService;
+import android.os.Binder;
+import android.os.Environment;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.Message;
+import android.os.Parcel;
+import android.os.RemoteException;
+import android.os.ResultReceiver;
+import android.os.ServiceManager;
+import android.os.SystemClock;
+import android.provider.Settings;
+import android.provider.Settings.Secure;
+import android.provider.Settings.SettingNotFoundException;
+import android.text.TextUtils;
+import android.text.style.SuggestionSpan;
+import android.util.EventLog;
+import android.util.LruCache;
+import android.util.Pair;
+import android.util.PrintWriterPrinter;
+import android.util.Printer;
+import android.util.Slog;
+import android.util.Xml;
+import android.view.IWindowManager;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.WindowManager;
+import android.view.inputmethod.EditorInfo;
+import android.view.inputmethod.InputBinding;
+import android.view.inputmethod.InputMethod;
+import android.view.inputmethod.InputMethodInfo;
+import android.view.inputmethod.InputMethodManager;
+import android.view.inputmethod.InputMethodSubtype;
+import android.widget.ArrayAdapter;
+import android.widget.CompoundButton;
+import android.widget.CompoundButton.OnCheckedChangeListener;
+import android.widget.RadioButton;
+import android.widget.Switch;
+import android.widget.TextView;
+
+import java.io.File;
+import java.io.FileDescriptor;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.TreeMap;
+
+/**
+ * This class provides a system service that manages input methods.
+ */
+public class InputMethodManagerService extends IInputMethodManager.Stub
+        implements ServiceConnection, Handler.Callback {
+    static final boolean DEBUG = false;
+    static final String TAG = "InputMethodManagerService";
+
+    static final int MSG_SHOW_IM_PICKER = 1;
+    static final int MSG_SHOW_IM_SUBTYPE_PICKER = 2;
+    static final int MSG_SHOW_IM_SUBTYPE_ENABLER = 3;
+    static final int MSG_SHOW_IM_CONFIG = 4;
+
+    static final int MSG_UNBIND_INPUT = 1000;
+    static final int MSG_BIND_INPUT = 1010;
+    static final int MSG_SHOW_SOFT_INPUT = 1020;
+    static final int MSG_HIDE_SOFT_INPUT = 1030;
+    static final int MSG_ATTACH_TOKEN = 1040;
+    static final int MSG_CREATE_SESSION = 1050;
+
+    static final int MSG_START_INPUT = 2000;
+    static final int MSG_RESTART_INPUT = 2010;
+
+    static final int MSG_UNBIND_METHOD = 3000;
+    static final int MSG_BIND_METHOD = 3010;
+    static final int MSG_SET_ACTIVE = 3020;
+
+    static final int MSG_HARD_KEYBOARD_SWITCH_CHANGED = 4000;
+
+    static final long TIME_TO_RECONNECT = 10*1000;
+
+    static final int SECURE_SUGGESTION_SPANS_MAX_SIZE = 20;
+
+    private static final int NOT_A_SUBTYPE_ID = -1;
+    private static final String NOT_A_SUBTYPE_ID_STR = String.valueOf(NOT_A_SUBTYPE_ID);
+    private static final String SUBTYPE_MODE_KEYBOARD = "keyboard";
+    private static final String SUBTYPE_MODE_VOICE = "voice";
+    private static final String TAG_TRY_SUPPRESSING_IME_SWITCHER = "TrySuppressingImeSwitcher";
+    private static final String TAG_ENABLED_WHEN_DEFAULT_IS_NOT_ASCII_CAPABLE =
+            "EnabledWhenDefaultIsNotAsciiCapable";
+    private static final String TAG_ASCII_CAPABLE = "AsciiCapable";
+    private static final Locale ENGLISH_LOCALE = new Locale("en");
+
+    final Context mContext;
+    final Resources mRes;
+    final Handler mHandler;
+    final InputMethodSettings mSettings;
+    final SettingsObserver mSettingsObserver;
+    final IWindowManager mIWindowManager;
+    final HandlerCaller mCaller;
+    private final InputMethodFileManager mFileManager;
+    private final InputMethodAndSubtypeListManager mImListManager;
+    private final HardKeyboardListener mHardKeyboardListener;
+    private final WindowManagerService mWindowManagerService;
+
+    final InputBindResult mNoBinding = new InputBindResult(null, null, -1);
+
+    // All known input methods.  mMethodMap also serves as the global
+    // lock for this class.
+    final ArrayList<InputMethodInfo> mMethodList = new ArrayList<InputMethodInfo>();
+    final HashMap<String, InputMethodInfo> mMethodMap = new HashMap<String, InputMethodInfo>();
+    private final LruCache<SuggestionSpan, InputMethodInfo> mSecureSuggestionSpans =
+            new LruCache<SuggestionSpan, InputMethodInfo>(SECURE_SUGGESTION_SPANS_MAX_SIZE);
+
+    // Used to bring IME service up to visible adjustment while it is being shown.
+    final ServiceConnection mVisibleConnection = new ServiceConnection() {
+        @Override public void onServiceConnected(ComponentName name, IBinder service) {
+        }
+
+        @Override public void onServiceDisconnected(ComponentName name) {
+        }
+    };
+    boolean mVisibleBound = false;
+
+    // Ongoing notification
+    private NotificationManager mNotificationManager;
+    private KeyguardManager mKeyguardManager;
+    private StatusBarManagerService mStatusBar;
+    private Notification mImeSwitcherNotification;
+    private PendingIntent mImeSwitchPendingIntent;
+    private boolean mShowOngoingImeSwitcherForPhones;
+    private boolean mNotificationShown;
+    private final boolean mImeSelectedOnBoot;
+
+    class SessionState {
+        final ClientState client;
+        final IInputMethod method;
+        final IInputMethodSession session;
+
+        @Override
+        public String toString() {
+            return "SessionState{uid " + client.uid + " pid " + client.pid
+                    + " method " + Integer.toHexString(
+                            System.identityHashCode(method))
+                    + " session " + Integer.toHexString(
+                            System.identityHashCode(session))
+                    + "}";
+        }
+
+        SessionState(ClientState _client, IInputMethod _method,
+                IInputMethodSession _session) {
+            client = _client;
+            method = _method;
+            session = _session;
+        }
+    }
+
+    class ClientState {
+        final IInputMethodClient client;
+        final IInputContext inputContext;
+        final int uid;
+        final int pid;
+        final InputBinding binding;
+
+        boolean sessionRequested;
+        SessionState curSession;
+
+        @Override
+        public String toString() {
+            return "ClientState{" + Integer.toHexString(
+                    System.identityHashCode(this)) + " uid " + uid
+                    + " pid " + pid + "}";
+        }
+
+        ClientState(IInputMethodClient _client, IInputContext _inputContext,
+                int _uid, int _pid) {
+            client = _client;
+            inputContext = _inputContext;
+            uid = _uid;
+            pid = _pid;
+            binding = new InputBinding(null, inputContext.asBinder(), uid, pid);
+        }
+    }
+
+    final HashMap<IBinder, ClientState> mClients
+            = new HashMap<IBinder, ClientState>();
+
+    /**
+     * Set once the system is ready to run third party code.
+     */
+    boolean mSystemReady;
+
+    /**
+     * Id of the currently selected input method.
+     */
+    String mCurMethodId;
+
+    /**
+     * The current binding sequence number, incremented every time there is
+     * a new bind performed.
+     */
+    int mCurSeq;
+
+    /**
+     * The client that is currently bound to an input method.
+     */
+    ClientState mCurClient;
+
+    /**
+     * The last window token that gained focus.
+     */
+    IBinder mCurFocusedWindow;
+
+    /**
+     * The input context last provided by the current client.
+     */
+    IInputContext mCurInputContext;
+
+    /**
+     * The attributes last provided by the current client.
+     */
+    EditorInfo mCurAttribute;
+
+    /**
+     * The input method ID of the input method service that we are currently
+     * connected to or in the process of connecting to.
+     */
+    String mCurId;
+
+    /**
+     * The current subtype of the current input method.
+     */
+    private InputMethodSubtype mCurrentSubtype;
+
+    // This list contains the pairs of InputMethodInfo and InputMethodSubtype.
+    private final HashMap<InputMethodInfo, ArrayList<InputMethodSubtype>>
+            mShortcutInputMethodsAndSubtypes =
+                new HashMap<InputMethodInfo, ArrayList<InputMethodSubtype>>();
+
+    /**
+     * Set to true if our ServiceConnection is currently actively bound to
+     * a service (whether or not we have gotten its IBinder back yet).
+     */
+    boolean mHaveConnection;
+
+    /**
+     * Set if the client has asked for the input method to be shown.
+     */
+    boolean mShowRequested;
+
+    /**
+     * Set if we were explicitly told to show the input method.
+     */
+    boolean mShowExplicitlyRequested;
+
+    /**
+     * Set if we were forced to be shown.
+     */
+    boolean mShowForced;
+
+    /**
+     * Set if we last told the input method to show itself.
+     */
+    boolean mInputShown;
+
+    /**
+     * The Intent used to connect to the current input method.
+     */
+    Intent mCurIntent;
+
+    /**
+     * The token we have made for the currently active input method, to
+     * identify it in the future.
+     */
+    IBinder mCurToken;
+
+    /**
+     * If non-null, this is the input method service we are currently connected
+     * to.
+     */
+    IInputMethod mCurMethod;
+
+    /**
+     * Time that we last initiated a bind to the input method, to determine
+     * if we should try to disconnect and reconnect to it.
+     */
+    long mLastBindTime;
+
+    /**
+     * Have we called mCurMethod.bindInput()?
+     */
+    boolean mBoundToMethod;
+
+    /**
+     * Currently enabled session.  Only touched by service thread, not
+     * protected by a lock.
+     */
+    SessionState mEnabledSession;
+
+    /**
+     * True if the screen is on.  The value is true initially.
+     */
+    boolean mScreenOn = true;
+
+    int mBackDisposition = InputMethodService.BACK_DISPOSITION_DEFAULT;
+    int mImeWindowVis;
+
+    private AlertDialog.Builder mDialogBuilder;
+    private AlertDialog mSwitchingDialog;
+    private View mSwitchingDialogTitleView;
+    private InputMethodInfo[] mIms;
+    private int[] mSubtypeIds;
+    private Locale mLastSystemLocale;
+
+    class SettingsObserver extends ContentObserver {
+        SettingsObserver(Handler handler) {
+            super(handler);
+            ContentResolver resolver = mContext.getContentResolver();
+            resolver.registerContentObserver(Settings.Secure.getUriFor(
+                    Settings.Secure.DEFAULT_INPUT_METHOD), false, this);
+            resolver.registerContentObserver(Settings.Secure.getUriFor(
+                    Settings.Secure.ENABLED_INPUT_METHODS), false, this);
+            resolver.registerContentObserver(Settings.Secure.getUriFor(
+                    Settings.Secure.SELECTED_INPUT_METHOD_SUBTYPE), false, this);
+        }
+
+        @Override public void onChange(boolean selfChange) {
+            synchronized (mMethodMap) {
+                updateFromSettingsLocked();
+            }
+        }
+    }
+
+    class ScreenOnOffReceiver extends android.content.BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (intent.getAction().equals(Intent.ACTION_SCREEN_ON)) {
+                mScreenOn = true;
+                refreshImeWindowVisibilityLocked();
+            } else if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) {
+                mScreenOn = false;
+                setImeWindowVisibilityStatusHiddenLocked();
+            } else if (intent.getAction().equals(Intent.ACTION_CLOSE_SYSTEM_DIALOGS)) {
+                hideInputMethodMenu();
+                return;
+            } else {
+                Slog.w(TAG, "Unexpected intent " + intent);
+            }
+
+            // Inform the current client of the change in active status
+            if (mCurClient != null && mCurClient.client != null) {
+                executeOrSendMessage(mCurClient.client, mCaller.obtainMessageIO(
+                        MSG_SET_ACTIVE, mScreenOn ? 1 : 0, mCurClient));
+            }
+        }
+    }
+
+    class MyPackageMonitor extends PackageMonitor {
+        
+        @Override
+        public boolean onHandleForceStop(Intent intent, String[] packages, int uid, boolean doit) {
+            synchronized (mMethodMap) {
+                String curInputMethodId = Settings.Secure.getString(mContext
+                        .getContentResolver(), Settings.Secure.DEFAULT_INPUT_METHOD);
+                final int N = mMethodList.size();
+                if (curInputMethodId != null) {
+                    for (int i=0; i<N; i++) {
+                        InputMethodInfo imi = mMethodList.get(i);
+                        if (imi.getId().equals(curInputMethodId)) {
+                            for (String pkg : packages) {
+                                if (imi.getPackageName().equals(pkg)) {
+                                    if (!doit) {
+                                        return true;
+                                    }
+                                    resetSelectedInputMethodAndSubtypeLocked("");
+                                    chooseNewDefaultIMELocked();
+                                    return true;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            return false;
+        }
+
+        @Override
+        public void onSomePackagesChanged() {
+            synchronized (mMethodMap) {
+                InputMethodInfo curIm = null;
+                String curInputMethodId = Settings.Secure.getString(mContext
+                        .getContentResolver(), Settings.Secure.DEFAULT_INPUT_METHOD);
+                final int N = mMethodList.size();
+                if (curInputMethodId != null) {
+                    for (int i=0; i<N; i++) {
+                        InputMethodInfo imi = mMethodList.get(i);
+                        final String imiId = imi.getId();
+                        if (imiId.equals(curInputMethodId)) {
+                            curIm = imi;
+                        }
+
+                        int change = isPackageDisappearing(imi.getPackageName());
+                        if (isPackageModified(imi.getPackageName())) {
+                            mFileManager.deleteAllInputMethodSubtypes(imiId);
+                        }
+                        if (change == PACKAGE_TEMPORARY_CHANGE
+                                || change == PACKAGE_PERMANENT_CHANGE) {
+                            Slog.i(TAG, "Input method uninstalled, disabling: "
+                                    + imi.getComponent());
+                            setInputMethodEnabledLocked(imi.getId(), false);
+                        }
+                    }
+                }
+
+                buildInputMethodListLocked(mMethodList, mMethodMap);
+
+                boolean changed = false;
+
+                if (curIm != null) {
+                    int change = isPackageDisappearing(curIm.getPackageName()); 
+                    if (change == PACKAGE_TEMPORARY_CHANGE
+                            || change == PACKAGE_PERMANENT_CHANGE) {
+                        ServiceInfo si = null;
+                        try {
+                            si = mContext.getPackageManager().getServiceInfo(
+                                    curIm.getComponent(), 0);
+                        } catch (PackageManager.NameNotFoundException ex) {
+                        }
+                        if (si == null) {
+                            // Uh oh, current input method is no longer around!
+                            // Pick another one...
+                            Slog.i(TAG, "Current input method removed: " + curInputMethodId);
+                            setImeWindowVisibilityStatusHiddenLocked();
+                            if (!chooseNewDefaultIMELocked()) {
+                                changed = true;
+                                curIm = null;
+                                Slog.i(TAG, "Unsetting current input method");
+                                resetSelectedInputMethodAndSubtypeLocked("");
+                            }
+                        }
+                    }
+                }
+
+                if (curIm == null) {
+                    // We currently don't have a default input method... is
+                    // one now available?
+                    changed = chooseNewDefaultIMELocked();
+                }
+
+                if (changed) {
+                    updateFromSettingsLocked();
+                }
+            }
+        }
+    }
+
+    private static class MethodCallback extends IInputMethodCallback.Stub {
+        private final IInputMethod mMethod;
+        private final InputMethodManagerService mParentIMMS;
+
+        MethodCallback(final IInputMethod method, final InputMethodManagerService imms) {
+            mMethod = method;
+            mParentIMMS = imms;
+        }
+
+        @Override
+        public void finishedEvent(int seq, boolean handled) throws RemoteException {
+        }
+
+        @Override
+        public void sessionCreated(IInputMethodSession session) throws RemoteException {
+            mParentIMMS.onSessionCreated(mMethod, session);
+        }
+    }
+
+    private class HardKeyboardListener
+            implements WindowManagerService.OnHardKeyboardStatusChangeListener {
+        @Override
+        public void onHardKeyboardStatusChange(boolean available, boolean enabled) {
+            mHandler.sendMessage(mHandler.obtainMessage(
+                    MSG_HARD_KEYBOARD_SWITCH_CHANGED, available ? 1 : 0, enabled ? 1 : 0));
+        }
+
+        public void handleHardKeyboardStatusChange(boolean available, boolean enabled) {
+            if (DEBUG) {
+                Slog.w(TAG, "HardKeyboardStatusChanged: available = " + available + ", enabled = "
+                        + enabled);
+            }
+            synchronized(mMethodMap) {
+                if (mSwitchingDialog != null && mSwitchingDialogTitleView != null
+                        && mSwitchingDialog.isShowing()) {
+                    mSwitchingDialogTitleView.findViewById(
+                            com.android.internal.R.id.hard_keyboard_section).setVisibility(
+                                    available ? View.VISIBLE : View.GONE);
+                }
+            }
+        }
+    }
+
+    public InputMethodManagerService(Context context, WindowManagerService windowManager) {
+        mContext = context;
+        mRes = context.getResources();
+        mHandler = new Handler(this);
+        mIWindowManager = IWindowManager.Stub.asInterface(
+                ServiceManager.getService(Context.WINDOW_SERVICE));
+        mCaller = new HandlerCaller(context, new HandlerCaller.Callback() {
+            @Override
+            public void executeMessage(Message msg) {
+                handleMessage(msg);
+            }
+        });
+        mWindowManagerService = windowManager;
+        mHardKeyboardListener = new HardKeyboardListener();
+
+        mImeSwitcherNotification = new Notification();
+        mImeSwitcherNotification.icon = com.android.internal.R.drawable.ic_notification_ime_default;
+        mImeSwitcherNotification.when = 0;
+        mImeSwitcherNotification.flags = Notification.FLAG_ONGOING_EVENT;
+        mImeSwitcherNotification.tickerText = null;
+        mImeSwitcherNotification.defaults = 0; // please be quiet
+        mImeSwitcherNotification.sound = null;
+        mImeSwitcherNotification.vibrate = null;
+
+        // Tag this notification specially so SystemUI knows it's important
+        mImeSwitcherNotification.kind = new String[] { "android.system.imeswitcher" };
+
+        Intent intent = new Intent(Settings.ACTION_SHOW_INPUT_METHOD_PICKER);
+        mImeSwitchPendingIntent = PendingIntent.getBroadcast(mContext, 0, intent, 0);
+
+        mShowOngoingImeSwitcherForPhones = false;
+
+        synchronized (mMethodMap) {
+            mFileManager = new InputMethodFileManager(mMethodMap);
+        }
+        mImListManager = new InputMethodAndSubtypeListManager(context, this);
+
+        (new MyPackageMonitor()).register(mContext, null, true);
+
+        IntentFilter screenOnOffFilt = new IntentFilter();
+        screenOnOffFilt.addAction(Intent.ACTION_SCREEN_ON);
+        screenOnOffFilt.addAction(Intent.ACTION_SCREEN_OFF);
+        screenOnOffFilt.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
+        mContext.registerReceiver(new ScreenOnOffReceiver(), screenOnOffFilt);
+
+        mNotificationShown = false;
+
+        // mSettings should be created before buildInputMethodListLocked
+        mSettings = new InputMethodSettings(
+                mRes, context.getContentResolver(), mMethodMap, mMethodList);
+
+        // Just checking if defaultImiId is empty or not
+        final String defaultImiId = Settings.Secure.getString(
+                mContext.getContentResolver(), Settings.Secure.DEFAULT_INPUT_METHOD);
+        mImeSelectedOnBoot = !TextUtils.isEmpty(defaultImiId);
+
+        buildInputMethodListLocked(mMethodList, mMethodMap);
+        mSettings.enableAllIMEsIfThereIsNoEnabledIME();
+
+        if (!mImeSelectedOnBoot) {
+            Slog.w(TAG, "No IME selected. Choose the most applicable IME.");
+            resetDefaultImeLocked(context);
+        }
+
+        mSettingsObserver = new SettingsObserver(mHandler);
+        updateFromSettingsLocked();
+
+        // IMMS wants to receive Intent.ACTION_LOCALE_CHANGED in order to update the current IME
+        // according to the new system locale.
+        final IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_LOCALE_CHANGED);
+        mContext.registerReceiver(
+                new BroadcastReceiver() {
+                    @Override
+                    public void onReceive(Context context, Intent intent) {
+                        synchronized(mMethodMap) {
+                            checkCurrentLocaleChangedLocked();
+                        }
+                    }
+                }, filter);
+    }
+
+    private void checkCurrentLocaleChangedLocked() {
+        if (!mSystemReady) {
+            // not system ready
+            return;
+        }
+        final Locale newLocale = mRes.getConfiguration().locale;
+        if (newLocale != null && !newLocale.equals(mLastSystemLocale)) {
+            if (DEBUG) {
+                Slog.i(TAG, "Locale has been changed to " + newLocale);
+            }
+            buildInputMethodListLocked(mMethodList, mMethodMap);
+            // Reset the current ime to the proper one
+            resetDefaultImeLocked(mContext);
+            updateFromSettingsLocked();
+            mLastSystemLocale = newLocale;
+        }
+    }
+
+    private void resetDefaultImeLocked(Context context) {
+        // Do not reset the default (current) IME when it is a 3rd-party IME
+        if (mCurMethodId != null && !isSystemIme(mMethodMap.get(mCurMethodId))) {
+            return;
+        }
+
+        InputMethodInfo defIm = null;
+        for (InputMethodInfo imi : mMethodList) {
+            if (defIm == null) {
+                if (isValidSystemDefaultIme(imi, context)) {
+                    defIm = imi;
+                    Slog.i(TAG, "Selected default: " + imi.getId());
+                }
+            }
+        }
+        if (defIm == null && mMethodList.size() > 0) {
+            defIm = getMostApplicableDefaultIMELocked();
+            Slog.i(TAG, "No default found, using " + defIm.getId());
+        }
+        if (defIm != null) {
+            setSelectedInputMethodAndSubtypeLocked(defIm, NOT_A_SUBTYPE_ID, false);
+        }
+    }
+
+    private boolean isValidSystemDefaultIme(InputMethodInfo imi, Context context) {
+        if (!mSystemReady) {
+            return false;
+        }
+        if (!isSystemIme(imi)) {
+            return false;
+        }
+        if (imi.getIsDefaultResourceId() != 0) {
+            try {
+                Resources res = context.createPackageContext(
+                        imi.getPackageName(), 0).getResources();
+                if (res.getBoolean(imi.getIsDefaultResourceId())
+                        && containsSubtypeOf(imi, context.getResources().getConfiguration().
+                                locale.getLanguage())) {
+                    return true;
+                }
+            } catch (PackageManager.NameNotFoundException ex) {
+            } catch (Resources.NotFoundException ex) {
+            }
+        }
+        if (imi.getSubtypeCount() == 0) {
+            Slog.w(TAG, "Found no subtypes in a system IME: " + imi.getPackageName());
+        }
+        return false;
+    }
+
+    private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi) {
+        if (!isSystemIme(imi)) {
+            return false;
+        }
+        return containsSubtypeOf(imi, ENGLISH_LOCALE.getLanguage());
+    }
+
+    private static boolean containsSubtypeOf(InputMethodInfo imi, String language) {
+        final int N = imi.getSubtypeCount();
+        for (int i = 0; i < N; ++i) {
+            if (imi.getSubtypeAt(i).getLocale().startsWith(language)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)
+            throws RemoteException {
+        try {
+            return super.onTransact(code, data, reply, flags);
+        } catch (RuntimeException e) {
+            // The input method manager only throws security exceptions, so let's
+            // log all others.
+            if (!(e instanceof SecurityException)) {
+                Slog.e(TAG, "Input Method Manager Crash", e);
+            }
+            throw e;
+        }
+    }
+
+    public void systemReady(StatusBarManagerService statusBar) {
+        synchronized (mMethodMap) {
+            if (!mSystemReady) {
+                mSystemReady = true;
+                mKeyguardManager = (KeyguardManager)
+                        mContext.getSystemService(Context.KEYGUARD_SERVICE);
+                mNotificationManager = (NotificationManager)
+                        mContext.getSystemService(Context.NOTIFICATION_SERVICE);
+                mStatusBar = statusBar;
+                statusBar.setIconVisibility("ime", false);
+                updateImeWindowStatusLocked();
+                mShowOngoingImeSwitcherForPhones = mRes.getBoolean(
+                        com.android.internal.R.bool.show_ongoing_ime_switcher);
+                if (mShowOngoingImeSwitcherForPhones) {
+                    mWindowManagerService.setOnHardKeyboardStatusChangeListener(
+                            mHardKeyboardListener);
+                }
+                buildInputMethodListLocked(mMethodList, mMethodMap);
+                if (!mImeSelectedOnBoot) {
+                    Slog.w(TAG, "Reset the default IME as \"Resource\" is ready here.");
+                    checkCurrentLocaleChangedLocked();
+                }
+                mLastSystemLocale = mRes.getConfiguration().locale;
+                try {
+                    startInputInnerLocked();
+                } catch (RuntimeException e) {
+                    Slog.w(TAG, "Unexpected exception", e);
+                }
+            }
+        }
+    }
+
+    private void setImeWindowVisibilityStatusHiddenLocked() {
+        mImeWindowVis = 0;
+        updateImeWindowStatusLocked();
+    }
+
+    private void refreshImeWindowVisibilityLocked() {
+        final Configuration conf = mRes.getConfiguration();
+        final boolean haveHardKeyboard = conf.keyboard
+                != Configuration.KEYBOARD_NOKEYS;
+        final boolean hardKeyShown = haveHardKeyboard
+                && conf.hardKeyboardHidden
+                        != Configuration.HARDKEYBOARDHIDDEN_YES;
+        final boolean isScreenLocked = mKeyguardManager != null
+                && mKeyguardManager.isKeyguardLocked()
+                && mKeyguardManager.isKeyguardSecure();
+        mImeWindowVis = (!isScreenLocked && (mInputShown || hardKeyShown)) ?
+                (InputMethodService.IME_ACTIVE | InputMethodService.IME_VISIBLE) : 0;
+        updateImeWindowStatusLocked();
+    }
+
+    private void updateImeWindowStatusLocked() {
+        setImeWindowStatus(mCurToken, mImeWindowVis, mBackDisposition);
+    }
+
+    @Override
+    public List<InputMethodInfo> getInputMethodList() {
+        synchronized (mMethodMap) {
+            return new ArrayList<InputMethodInfo>(mMethodList);
+        }
+    }
+
+    @Override
+    public List<InputMethodInfo> getEnabledInputMethodList() {
+        synchronized (mMethodMap) {
+            return mSettings.getEnabledInputMethodListLocked();
+        }
+    }
+
+    private HashMap<InputMethodInfo, List<InputMethodSubtype>>
+            getExplicitlyOrImplicitlyEnabledInputMethodsAndSubtypeListLocked() {
+        HashMap<InputMethodInfo, List<InputMethodSubtype>> enabledInputMethodAndSubtypes =
+                new HashMap<InputMethodInfo, List<InputMethodSubtype>>();
+        for (InputMethodInfo imi: getEnabledInputMethodList()) {
+            enabledInputMethodAndSubtypes.put(
+                    imi, getEnabledInputMethodSubtypeListLocked(imi, true));
+        }
+        return enabledInputMethodAndSubtypes;
+    }
+
+    public List<InputMethodSubtype> getEnabledInputMethodSubtypeListLocked(InputMethodInfo imi,
+            boolean allowsImplicitlySelectedSubtypes) {
+        if (imi == null && mCurMethodId != null) {
+            imi = mMethodMap.get(mCurMethodId);
+        }
+        List<InputMethodSubtype> enabledSubtypes =
+                mSettings.getEnabledInputMethodSubtypeListLocked(imi);
+        if (allowsImplicitlySelectedSubtypes && enabledSubtypes.isEmpty()) {
+            enabledSubtypes = getImplicitlyApplicableSubtypesLocked(mRes, imi);
+        }
+        return InputMethodSubtype.sort(mContext, 0, imi, enabledSubtypes);
+    }
+
+    @Override
+    public List<InputMethodSubtype> getEnabledInputMethodSubtypeList(InputMethodInfo imi,
+            boolean allowsImplicitlySelectedSubtypes) {
+        synchronized (mMethodMap) {
+            return getEnabledInputMethodSubtypeListLocked(imi, allowsImplicitlySelectedSubtypes);
+        }
+    }
+
+    @Override
+    public void addClient(IInputMethodClient client,
+            IInputContext inputContext, int uid, int pid) {
+        synchronized (mMethodMap) {
+            mClients.put(client.asBinder(), new ClientState(client,
+                    inputContext, uid, pid));
+        }
+    }
+
+    @Override
+    public void removeClient(IInputMethodClient client) {
+        synchronized (mMethodMap) {
+            mClients.remove(client.asBinder());
+        }
+    }
+
+    void executeOrSendMessage(IInterface target, Message msg) {
+         if (target.asBinder() instanceof Binder) {
+             mCaller.sendMessage(msg);
+         } else {
+             handleMessage(msg);
+             msg.recycle();
+         }
+    }
+
+    void unbindCurrentClientLocked() {
+        if (mCurClient != null) {
+            if (DEBUG) Slog.v(TAG, "unbindCurrentInputLocked: client = "
+                    + mCurClient.client.asBinder());
+            if (mBoundToMethod) {
+                mBoundToMethod = false;
+                if (mCurMethod != null) {
+                    executeOrSendMessage(mCurMethod, mCaller.obtainMessageO(
+                            MSG_UNBIND_INPUT, mCurMethod));
+                }
+            }
+
+            executeOrSendMessage(mCurClient.client, mCaller.obtainMessageIO(
+                    MSG_SET_ACTIVE, 0, mCurClient));
+            executeOrSendMessage(mCurClient.client, mCaller.obtainMessageIO(
+                    MSG_UNBIND_METHOD, mCurSeq, mCurClient.client));
+            mCurClient.sessionRequested = false;
+            mCurClient = null;
+
+            hideInputMethodMenuLocked();
+        }
+    }
+
+    private int getImeShowFlags() {
+        int flags = 0;
+        if (mShowForced) {
+            flags |= InputMethod.SHOW_FORCED
+                    | InputMethod.SHOW_EXPLICIT;
+        } else if (mShowExplicitlyRequested) {
+            flags |= InputMethod.SHOW_EXPLICIT;
+        }
+        return flags;
+    }
+
+    private int getAppShowFlags() {
+        int flags = 0;
+        if (mShowForced) {
+            flags |= InputMethodManager.SHOW_FORCED;
+        } else if (!mShowExplicitlyRequested) {
+            flags |= InputMethodManager.SHOW_IMPLICIT;
+        }
+        return flags;
+    }
+
+    InputBindResult attachNewInputLocked(boolean initial) {
+        if (!mBoundToMethod) {
+            executeOrSendMessage(mCurMethod, mCaller.obtainMessageOO(
+                    MSG_BIND_INPUT, mCurMethod, mCurClient.binding));
+            mBoundToMethod = true;
+        }
+        final SessionState session = mCurClient.curSession;
+        if (initial) {
+            executeOrSendMessage(session.method, mCaller.obtainMessageOOO(
+                    MSG_START_INPUT, session, mCurInputContext, mCurAttribute));
+        } else {
+            executeOrSendMessage(session.method, mCaller.obtainMessageOOO(
+                    MSG_RESTART_INPUT, session, mCurInputContext, mCurAttribute));
+        }
+        if (mShowRequested) {
+            if (DEBUG) Slog.v(TAG, "Attach new input asks to show input");
+            showCurrentInputLocked(getAppShowFlags(), null);
+        }
+        return new InputBindResult(session.session, mCurId, mCurSeq);
+    }
+
+    InputBindResult startInputLocked(IInputMethodClient client,
+            IInputContext inputContext, EditorInfo attribute, int controlFlags) {
+        // If no method is currently selected, do nothing.
+        if (mCurMethodId == null) {
+            return mNoBinding;
+        }
+
+        ClientState cs = mClients.get(client.asBinder());
+        if (cs == null) {
+            throw new IllegalArgumentException("unknown client "
+                    + client.asBinder());
+        }
+
+        try {
+            if (!mIWindowManager.inputMethodClientHasFocus(cs.client)) {
+                // Check with the window manager to make sure this client actually
+                // has a window with focus.  If not, reject.  This is thread safe
+                // because if the focus changes some time before or after, the
+                // next client receiving focus that has any interest in input will
+                // be calling through here after that change happens.
+                Slog.w(TAG, "Starting input on non-focused client " + cs.client
+                        + " (uid=" + cs.uid + " pid=" + cs.pid + ")");
+                return null;
+            }
+        } catch (RemoteException e) {
+        }
+
+        return startInputUncheckedLocked(cs, inputContext, attribute, controlFlags);
+    }
+
+    InputBindResult startInputUncheckedLocked(ClientState cs,
+            IInputContext inputContext, EditorInfo attribute, int controlFlags) {
+        // If no method is currently selected, do nothing.
+        if (mCurMethodId == null) {
+            return mNoBinding;
+        }
+
+        if (mCurClient != cs) {
+            // If the client is changing, we need to switch over to the new
+            // one.
+            unbindCurrentClientLocked();
+            if (DEBUG) Slog.v(TAG, "switching to client: client = "
+                    + cs.client.asBinder());
+
+            // If the screen is on, inform the new client it is active
+            if (mScreenOn) {
+                executeOrSendMessage(cs.client, mCaller.obtainMessageIO(
+                        MSG_SET_ACTIVE, mScreenOn ? 1 : 0, cs));
+            }
+        }
+
+        // Bump up the sequence for this client and attach it.
+        mCurSeq++;
+        if (mCurSeq <= 0) mCurSeq = 1;
+        mCurClient = cs;
+        mCurInputContext = inputContext;
+        mCurAttribute = attribute;
+
+        // Check if the input method is changing.
+        if (mCurId != null && mCurId.equals(mCurMethodId)) {
+            if (cs.curSession != null) {
+                // Fast case: if we are already connected to the input method,
+                // then just return it.
+                return attachNewInputLocked(
+                        (controlFlags&InputMethodManager.CONTROL_START_INITIAL) != 0);
+            }
+            if (mHaveConnection) {
+                if (mCurMethod != null) {
+                    if (!cs.sessionRequested) {
+                        cs.sessionRequested = true;
+                        if (DEBUG) Slog.v(TAG, "Creating new session for client " + cs);
+                        executeOrSendMessage(mCurMethod, mCaller.obtainMessageOO(
+                                MSG_CREATE_SESSION, mCurMethod,
+                                new MethodCallback(mCurMethod, this)));
+                    }
+                    // Return to client, and we will get back with it when
+                    // we have had a session made for it.
+                    return new InputBindResult(null, mCurId, mCurSeq);
+                } else if (SystemClock.uptimeMillis()
+                        < (mLastBindTime+TIME_TO_RECONNECT)) {
+                    // In this case we have connected to the service, but
+                    // don't yet have its interface.  If it hasn't been too
+                    // long since we did the connection, we'll return to
+                    // the client and wait to get the service interface so
+                    // we can report back.  If it has been too long, we want
+                    // to fall through so we can try a disconnect/reconnect
+                    // to see if we can get back in touch with the service.
+                    return new InputBindResult(null, mCurId, mCurSeq);
+                } else {
+                    EventLog.writeEvent(EventLogTags.IMF_FORCE_RECONNECT_IME,
+                            mCurMethodId, SystemClock.uptimeMillis()-mLastBindTime, 0);
+                }
+            }
+        }
+
+        return startInputInnerLocked();
+    }
+
+    InputBindResult startInputInnerLocked() {
+        if (mCurMethodId == null) {
+            return mNoBinding;
+        }
+
+        if (!mSystemReady) {
+            // If the system is not yet ready, we shouldn't be running third
+            // party code.
+            return new InputBindResult(null, mCurMethodId, mCurSeq);
+        }
+
+        InputMethodInfo info = mMethodMap.get(mCurMethodId);
+        if (info == null) {
+            throw new IllegalArgumentException("Unknown id: " + mCurMethodId);
+        }
+
+        unbindCurrentMethodLocked(false);
+
+        mCurIntent = new Intent(InputMethod.SERVICE_INTERFACE);
+        mCurIntent.setComponent(info.getComponent());
+        mCurIntent.putExtra(Intent.EXTRA_CLIENT_LABEL,
+                com.android.internal.R.string.input_method_binding_label);
+        mCurIntent.putExtra(Intent.EXTRA_CLIENT_INTENT, PendingIntent.getActivity(
+                mContext, 0, new Intent(Settings.ACTION_INPUT_METHOD_SETTINGS), 0));
+        if (mContext.bindService(mCurIntent, this, Context.BIND_AUTO_CREATE
+                | Context.BIND_NOT_VISIBLE)) {
+            mLastBindTime = SystemClock.uptimeMillis();
+            mHaveConnection = true;
+            mCurId = info.getId();
+            mCurToken = new Binder();
+            try {
+                if (DEBUG) Slog.v(TAG, "Adding window token: " + mCurToken);
+                mIWindowManager.addWindowToken(mCurToken,
+                        WindowManager.LayoutParams.TYPE_INPUT_METHOD);
+            } catch (RemoteException e) {
+            }
+            return new InputBindResult(null, mCurId, mCurSeq);
+        } else {
+            mCurIntent = null;
+            Slog.w(TAG, "Failure connecting to input method service: "
+                    + mCurIntent);
+        }
+        return null;
+    }
+
+    @Override
+    public InputBindResult startInput(IInputMethodClient client,
+            IInputContext inputContext, EditorInfo attribute, int controlFlags) {
+        synchronized (mMethodMap) {
+            final long ident = Binder.clearCallingIdentity();
+            try {
+                return startInputLocked(client, inputContext, attribute, controlFlags);
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+    }
+
+    @Override
+    public void finishInput(IInputMethodClient client) {
+    }
+
+    @Override
+    public void onServiceConnected(ComponentName name, IBinder service) {
+        synchronized (mMethodMap) {
+            if (mCurIntent != null && name.equals(mCurIntent.getComponent())) {
+                mCurMethod = IInputMethod.Stub.asInterface(service);
+                if (mCurToken == null) {
+                    Slog.w(TAG, "Service connected without a token!");
+                    unbindCurrentMethodLocked(false);
+                    return;
+                }
+                if (DEBUG) Slog.v(TAG, "Initiating attach with token: " + mCurToken);
+                executeOrSendMessage(mCurMethod, mCaller.obtainMessageOO(
+                        MSG_ATTACH_TOKEN, mCurMethod, mCurToken));
+                if (mCurClient != null) {
+                    if (DEBUG) Slog.v(TAG, "Creating first session while with client "
+                            + mCurClient);
+                    executeOrSendMessage(mCurMethod, mCaller.obtainMessageOO(
+                            MSG_CREATE_SESSION, mCurMethod,
+                            new MethodCallback(mCurMethod, this)));
+                }
+            }
+        }
+    }
+
+    void onSessionCreated(IInputMethod method, IInputMethodSession session) {
+        synchronized (mMethodMap) {
+            if (mCurMethod != null && method != null
+                    && mCurMethod.asBinder() == method.asBinder()) {
+                if (mCurClient != null) {
+                    mCurClient.curSession = new SessionState(mCurClient,
+                            method, session);
+                    mCurClient.sessionRequested = false;
+                    InputBindResult res = attachNewInputLocked(true);
+                    if (res.method != null) {
+                        executeOrSendMessage(mCurClient.client, mCaller.obtainMessageOO(
+                                MSG_BIND_METHOD, mCurClient.client, res));
+                    }
+                }
+            }
+        }
+    }
+
+    void unbindCurrentMethodLocked(boolean reportToClient) {
+        if (mVisibleBound) {
+            mContext.unbindService(mVisibleConnection);
+            mVisibleBound = false;
+        }
+
+        if (mHaveConnection) {
+            mContext.unbindService(this);
+            mHaveConnection = false;
+        }
+
+        if (mCurToken != null) {
+            try {
+                if (DEBUG) Slog.v(TAG, "Removing window token: " + mCurToken);
+                if ((mImeWindowVis & InputMethodService.IME_ACTIVE) != 0) {
+                    // The current IME is shown. Hence an IME switch (transition) is happening.
+                    mWindowManagerService.saveLastInputMethodWindowForTransition();
+                }
+                mIWindowManager.removeWindowToken(mCurToken);
+            } catch (RemoteException e) {
+            }
+            mCurToken = null;
+        }
+
+        mCurId = null;
+        clearCurMethodLocked();
+
+        if (reportToClient && mCurClient != null) {
+            executeOrSendMessage(mCurClient.client, mCaller.obtainMessageIO(
+                    MSG_UNBIND_METHOD, mCurSeq, mCurClient.client));
+        }
+    }
+    
+    private void finishSession(SessionState sessionState) {
+        if (sessionState != null && sessionState.session != null) {
+            try {
+                sessionState.session.finishSession();
+            } catch (RemoteException e) {
+                Slog.w(TAG, "Session failed to close due to remote exception", e);
+                setImeWindowVisibilityStatusHiddenLocked();
+            }
+        }
+    }
+
+    void clearCurMethodLocked() {
+        if (mCurMethod != null) {
+            for (ClientState cs : mClients.values()) {
+                cs.sessionRequested = false;
+                finishSession(cs.curSession);
+                cs.curSession = null;
+            }
+
+            finishSession(mEnabledSession);
+            mEnabledSession = null;
+            mCurMethod = null;
+        }
+        if (mStatusBar != null) {
+            mStatusBar.setIconVisibility("ime", false);
+        }
+    }
+
+    @Override
+    public void onServiceDisconnected(ComponentName name) {
+        synchronized (mMethodMap) {
+            if (DEBUG) Slog.v(TAG, "Service disconnected: " + name
+                    + " mCurIntent=" + mCurIntent);
+            if (mCurMethod != null && mCurIntent != null
+                    && name.equals(mCurIntent.getComponent())) {
+                clearCurMethodLocked();
+                // We consider this to be a new bind attempt, since the system
+                // should now try to restart the service for us.
+                mLastBindTime = SystemClock.uptimeMillis();
+                mShowRequested = mInputShown;
+                mInputShown = false;
+                if (mCurClient != null) {
+                    executeOrSendMessage(mCurClient.client, mCaller.obtainMessageIO(
+                            MSG_UNBIND_METHOD, mCurSeq, mCurClient.client));
+                }
+            }
+        }
+    }
+
+    @Override
+    public void updateStatusIcon(IBinder token, String packageName, int iconId) {
+        int uid = Binder.getCallingUid();
+        long ident = Binder.clearCallingIdentity();
+        try {
+            if (token == null || mCurToken != token) {
+                Slog.w(TAG, "Ignoring setInputMethod of uid " + uid + " token: " + token);
+                return;
+            }
+
+            synchronized (mMethodMap) {
+                if (iconId == 0) {
+                    if (DEBUG) Slog.d(TAG, "hide the small icon for the input method");
+                    if (mStatusBar != null) {
+                        mStatusBar.setIconVisibility("ime", false);
+                    }
+                } else if (packageName != null) {
+                    if (DEBUG) Slog.d(TAG, "show a small icon for the input method");
+                    CharSequence contentDescription = null;
+                    try {
+                        PackageManager packageManager = mContext.getPackageManager();
+                        contentDescription = packageManager.getApplicationLabel(
+                                packageManager.getApplicationInfo(packageName, 0));
+                    } catch (NameNotFoundException nnfe) {
+                        /* ignore */
+                    }
+                    if (mStatusBar != null) {
+                        mStatusBar.setIcon("ime", packageName, iconId, 0,
+                                contentDescription  != null
+                                        ? contentDescription.toString() : null);
+                        mStatusBar.setIconVisibility("ime", true);
+                    }
+                }
+            }
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    private boolean needsToShowImeSwitchOngoingNotification() {
+        if (!mShowOngoingImeSwitcherForPhones) return false;
+        if (isScreenLocked()) return false;
+        synchronized (mMethodMap) {
+            List<InputMethodInfo> imis = mSettings.getEnabledInputMethodListLocked();
+            final int N = imis.size();
+            if (N > 2) return true;
+            if (N < 1) return false;
+            int nonAuxCount = 0;
+            int auxCount = 0;
+            InputMethodSubtype nonAuxSubtype = null;
+            InputMethodSubtype auxSubtype = null;
+            for(int i = 0; i < N; ++i) {
+                final InputMethodInfo imi = imis.get(i);
+                final List<InputMethodSubtype> subtypes = getEnabledInputMethodSubtypeListLocked(
+                        imi, true);
+                final int subtypeCount = subtypes.size();
+                if (subtypeCount == 0) {
+                    ++nonAuxCount;
+                } else {
+                    for (int j = 0; j < subtypeCount; ++j) {
+                        final InputMethodSubtype subtype = subtypes.get(j);
+                        if (!subtype.isAuxiliary()) {
+                            ++nonAuxCount;
+                            nonAuxSubtype = subtype;
+                        } else {
+                            ++auxCount;
+                            auxSubtype = subtype;
+                        }
+                    }
+                }
+            }
+            if (nonAuxCount > 1 || auxCount > 1) {
+                return true;
+            } else if (nonAuxCount == 1 && auxCount == 1) {
+                if (nonAuxSubtype != null && auxSubtype != null
+                        && (nonAuxSubtype.getLocale().equals(auxSubtype.getLocale())
+                                || auxSubtype.overridesImplicitlyEnabledSubtype()
+                                || nonAuxSubtype.overridesImplicitlyEnabledSubtype())
+                        && nonAuxSubtype.containsExtraValueKey(TAG_TRY_SUPPRESSING_IME_SWITCHER)) {
+                    return false;
+                }
+                return true;
+            }
+            return false;
+        }
+    }
+
+    @SuppressWarnings("deprecation")
+    @Override
+    public void setImeWindowStatus(IBinder token, int vis, int backDisposition) {
+        int uid = Binder.getCallingUid();
+        long ident = Binder.clearCallingIdentity();
+        try {
+            if (token == null || mCurToken != token) {
+                Slog.w(TAG, "Ignoring setImeWindowStatus of uid " + uid + " token: " + token);
+                return;
+            }
+
+            synchronized (mMethodMap) {
+                mImeWindowVis = vis;
+                mBackDisposition = backDisposition;
+                if (mStatusBar != null) {
+                    mStatusBar.setImeWindowStatus(token, vis, backDisposition);
+                }
+                final boolean iconVisibility = (vis & InputMethodService.IME_ACTIVE) != 0;
+                final InputMethodInfo imi = mMethodMap.get(mCurMethodId);
+                if (imi != null && iconVisibility && needsToShowImeSwitchOngoingNotification()) {
+                    final PackageManager pm = mContext.getPackageManager();
+                    final CharSequence title = mRes.getText(
+                            com.android.internal.R.string.select_input_method);
+                    final CharSequence imiLabel = imi.loadLabel(pm);
+                    final CharSequence summary = mCurrentSubtype != null
+                            ? TextUtils.concat(mCurrentSubtype.getDisplayName(mContext,
+                                        imi.getPackageName(), imi.getServiceInfo().applicationInfo),
+                                                (TextUtils.isEmpty(imiLabel) ?
+                                                        "" : " - " + imiLabel))
+                            : imiLabel;
+
+                    mImeSwitcherNotification.setLatestEventInfo(
+                            mContext, title, summary, mImeSwitchPendingIntent);
+                    if (mNotificationManager != null) {
+                        mNotificationManager.notify(
+                                com.android.internal.R.string.select_input_method,
+                                mImeSwitcherNotification);
+                        mNotificationShown = true;
+                    }
+                } else {
+                    if (mNotificationShown && mNotificationManager != null) {
+                        mNotificationManager.cancel(
+                                com.android.internal.R.string.select_input_method);
+                        mNotificationShown = false;
+                    }
+                }
+            }
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    @Override
+    public void registerSuggestionSpansForNotification(SuggestionSpan[] spans) {
+        synchronized (mMethodMap) {
+            final InputMethodInfo currentImi = mMethodMap.get(mCurMethodId);
+            for (int i = 0; i < spans.length; ++i) {
+                SuggestionSpan ss = spans[i];
+                if (!TextUtils.isEmpty(ss.getNotificationTargetClassName())) {
+                    mSecureSuggestionSpans.put(ss, currentImi);
+                    final InputMethodInfo targetImi = mSecureSuggestionSpans.get(ss);
+                }
+            }
+        }
+    }
+
+    @Override
+    public boolean notifySuggestionPicked(SuggestionSpan span, String originalString, int index) {
+        synchronized (mMethodMap) {
+            final InputMethodInfo targetImi = mSecureSuggestionSpans.get(span);
+            // TODO: Do not send the intent if the process of the targetImi is already dead.
+            if (targetImi != null) {
+                final String[] suggestions = span.getSuggestions();
+                if (index < 0 || index >= suggestions.length) return false;
+                final String className = span.getNotificationTargetClassName();
+                final Intent intent = new Intent();
+                // Ensures that only a class in the original IME package will receive the
+                // notification.
+                intent.setClassName(targetImi.getPackageName(), className);
+                intent.setAction(SuggestionSpan.ACTION_SUGGESTION_PICKED);
+                intent.putExtra(SuggestionSpan.SUGGESTION_SPAN_PICKED_BEFORE, originalString);
+                intent.putExtra(SuggestionSpan.SUGGESTION_SPAN_PICKED_AFTER, suggestions[index]);
+                intent.putExtra(SuggestionSpan.SUGGESTION_SPAN_PICKED_HASHCODE, span.hashCode());
+                mContext.sendBroadcast(intent);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    void updateFromSettingsLocked() {
+        // We are assuming that whoever is changing DEFAULT_INPUT_METHOD and
+        // ENABLED_INPUT_METHODS is taking care of keeping them correctly in
+        // sync, so we will never have a DEFAULT_INPUT_METHOD that is not
+        // enabled.
+        String id = Settings.Secure.getString(mContext.getContentResolver(),
+                Settings.Secure.DEFAULT_INPUT_METHOD);
+        // There is no input method selected, try to choose new applicable input method.
+        if (TextUtils.isEmpty(id) && chooseNewDefaultIMELocked()) {
+            id = Settings.Secure.getString(mContext.getContentResolver(),
+                    Settings.Secure.DEFAULT_INPUT_METHOD);
+        }
+        if (!TextUtils.isEmpty(id)) {
+            try {
+                setInputMethodLocked(id, getSelectedInputMethodSubtypeId(id));
+            } catch (IllegalArgumentException e) {
+                Slog.w(TAG, "Unknown input method from prefs: " + id, e);
+                mCurMethodId = null;
+                unbindCurrentMethodLocked(true);
+            }
+            mShortcutInputMethodsAndSubtypes.clear();
+        } else {
+            // There is no longer an input method set, so stop any current one.
+            mCurMethodId = null;
+            unbindCurrentMethodLocked(true);
+        }
+    }
+
+    /* package */ void setInputMethodLocked(String id, int subtypeId) {
+        InputMethodInfo info = mMethodMap.get(id);
+        if (info == null) {
+            throw new IllegalArgumentException("Unknown id: " + id);
+        }
+
+        // See if we need to notify a subtype change within the same IME.
+        if (id.equals(mCurMethodId)) {
+            final int subtypeCount = info.getSubtypeCount();
+            if (subtypeCount <= 0) {
+                return;
+            }
+            final InputMethodSubtype oldSubtype = mCurrentSubtype;
+            final InputMethodSubtype newSubtype;
+            if (subtypeId >= 0 && subtypeId < subtypeCount) {
+                newSubtype = info.getSubtypeAt(subtypeId);
+            } else {
+                // If subtype is null, try to find the most applicable one from
+                // getCurrentInputMethodSubtype.
+                newSubtype = getCurrentInputMethodSubtype();
+            }
+            if (newSubtype == null || oldSubtype == null) {
+                Slog.w(TAG, "Illegal subtype state: old subtype = " + oldSubtype
+                        + ", new subtype = " + newSubtype);
+                return;
+            }
+            if (newSubtype != oldSubtype) {
+                setSelectedInputMethodAndSubtypeLocked(info, subtypeId, true);
+                if (mCurMethod != null) {
+                    try {
+                        refreshImeWindowVisibilityLocked();
+                        mCurMethod.changeInputMethodSubtype(newSubtype);
+                    } catch (RemoteException e) {
+                        Slog.w(TAG, "Failed to call changeInputMethodSubtype");
+                    }
+                }
+            }
+            return;
+        }
+
+        // Changing to a different IME.
+        final long ident = Binder.clearCallingIdentity();
+        try {
+            // Set a subtype to this input method.
+            // subtypeId the name of a subtype which will be set.
+            setSelectedInputMethodAndSubtypeLocked(info, subtypeId, false);
+            // mCurMethodId should be updated after setSelectedInputMethodAndSubtypeLocked()
+            // because mCurMethodId is stored as a history in
+            // setSelectedInputMethodAndSubtypeLocked().
+            mCurMethodId = id;
+
+            if (ActivityManagerNative.isSystemReady()) {
+                Intent intent = new Intent(Intent.ACTION_INPUT_METHOD_CHANGED);
+                intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING);
+                intent.putExtra("input_method_id", id);
+                mContext.sendBroadcast(intent);
+            }
+            unbindCurrentClientLocked();
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    @Override
+    public boolean showSoftInput(IInputMethodClient client, int flags,
+            ResultReceiver resultReceiver) {
+        int uid = Binder.getCallingUid();
+        long ident = Binder.clearCallingIdentity();
+        try {
+            synchronized (mMethodMap) {
+                if (mCurClient == null || client == null
+                        || mCurClient.client.asBinder() != client.asBinder()) {
+                    try {
+                        // We need to check if this is the current client with
+                        // focus in the window manager, to allow this call to
+                        // be made before input is started in it.
+                        if (!mIWindowManager.inputMethodClientHasFocus(client)) {
+                            Slog.w(TAG, "Ignoring showSoftInput of uid " + uid + ": " + client);
+                            return false;
+                        }
+                    } catch (RemoteException e) {
+                        return false;
+                    }
+                }
+
+                if (DEBUG) Slog.v(TAG, "Client requesting input be shown");
+                return showCurrentInputLocked(flags, resultReceiver);
+            }
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    boolean showCurrentInputLocked(int flags, ResultReceiver resultReceiver) {
+        mShowRequested = true;
+        if ((flags&InputMethodManager.SHOW_IMPLICIT) == 0) {
+            mShowExplicitlyRequested = true;
+        }
+        if ((flags&InputMethodManager.SHOW_FORCED) != 0) {
+            mShowExplicitlyRequested = true;
+            mShowForced = true;
+        }
+
+        if (!mSystemReady) {
+            return false;
+        }
+
+        boolean res = false;
+        if (mCurMethod != null) {
+            executeOrSendMessage(mCurMethod, mCaller.obtainMessageIOO(
+                    MSG_SHOW_SOFT_INPUT, getImeShowFlags(), mCurMethod,
+                    resultReceiver));
+            mInputShown = true;
+            if (mHaveConnection && !mVisibleBound) {
+                mContext.bindService(mCurIntent, mVisibleConnection, Context.BIND_AUTO_CREATE);
+                mVisibleBound = true;
+            }
+            res = true;
+        } else if (mHaveConnection && SystemClock.uptimeMillis()
+                >= (mLastBindTime+TIME_TO_RECONNECT)) {
+            // The client has asked to have the input method shown, but
+            // we have been sitting here too long with a connection to the
+            // service and no interface received, so let's disconnect/connect
+            // to try to prod things along.
+            EventLog.writeEvent(EventLogTags.IMF_FORCE_RECONNECT_IME, mCurMethodId,
+                    SystemClock.uptimeMillis()-mLastBindTime,1);
+            Slog.w(TAG, "Force disconnect/connect to the IME in showCurrentInputLocked()");
+            mContext.unbindService(this);
+            mContext.bindService(mCurIntent, this, Context.BIND_AUTO_CREATE
+                    | Context.BIND_NOT_VISIBLE);
+        }
+
+        return res;
+    }
+
+    @Override
+    public boolean hideSoftInput(IInputMethodClient client, int flags,
+            ResultReceiver resultReceiver) {
+        int uid = Binder.getCallingUid();
+        long ident = Binder.clearCallingIdentity();
+        try {
+            synchronized (mMethodMap) {
+                if (mCurClient == null || client == null
+                        || mCurClient.client.asBinder() != client.asBinder()) {
+                    try {
+                        // We need to check if this is the current client with
+                        // focus in the window manager, to allow this call to
+                        // be made before input is started in it.
+                        if (!mIWindowManager.inputMethodClientHasFocus(client)) {
+                            if (DEBUG) Slog.w(TAG, "Ignoring hideSoftInput of uid "
+                                    + uid + ": " + client);
+                            setImeWindowVisibilityStatusHiddenLocked();
+                            return false;
+                        }
+                    } catch (RemoteException e) {
+                        setImeWindowVisibilityStatusHiddenLocked();
+                        return false;
+                    }
+                }
+
+                if (DEBUG) Slog.v(TAG, "Client requesting input be hidden");
+                return hideCurrentInputLocked(flags, resultReceiver);
+            }
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    boolean hideCurrentInputLocked(int flags, ResultReceiver resultReceiver) {
+        if ((flags&InputMethodManager.HIDE_IMPLICIT_ONLY) != 0
+                && (mShowExplicitlyRequested || mShowForced)) {
+            if (DEBUG) Slog.v(TAG,
+                    "Not hiding: explicit show not cancelled by non-explicit hide");
+            return false;
+        }
+        if (mShowForced && (flags&InputMethodManager.HIDE_NOT_ALWAYS) != 0) {
+            if (DEBUG) Slog.v(TAG,
+                    "Not hiding: forced show not cancelled by not-always hide");
+            return false;
+        }
+        boolean res;
+        if (mInputShown && mCurMethod != null) {
+            executeOrSendMessage(mCurMethod, mCaller.obtainMessageOO(
+                    MSG_HIDE_SOFT_INPUT, mCurMethod, resultReceiver));
+            res = true;
+        } else {
+            res = false;
+        }
+        if (mHaveConnection && mVisibleBound) {
+            mContext.unbindService(mVisibleConnection);
+            mVisibleBound = false;
+        }
+        mInputShown = false;
+        mShowRequested = false;
+        mShowExplicitlyRequested = false;
+        mShowForced = false;
+        return res;
+    }
+
+    @Override
+    public InputBindResult windowGainedFocus(IInputMethodClient client, IBinder windowToken,
+            int controlFlags, int softInputMode, int windowFlags,
+            EditorInfo attribute, IInputContext inputContext) {
+        InputBindResult res = null;
+        long ident = Binder.clearCallingIdentity();
+        try {
+            synchronized (mMethodMap) {
+                if (DEBUG) Slog.v(TAG, "windowGainedFocus: " + client.asBinder()
+                        + " controlFlags=#" + Integer.toHexString(controlFlags)
+                        + " softInputMode=#" + Integer.toHexString(softInputMode)
+                        + " windowFlags=#" + Integer.toHexString(windowFlags));
+
+                ClientState cs = mClients.get(client.asBinder());
+                if (cs == null) {
+                    throw new IllegalArgumentException("unknown client "
+                            + client.asBinder());
+                }
+
+                try {
+                    if (!mIWindowManager.inputMethodClientHasFocus(cs.client)) {
+                        // Check with the window manager to make sure this client actually
+                        // has a window with focus.  If not, reject.  This is thread safe
+                        // because if the focus changes some time before or after, the
+                        // next client receiving focus that has any interest in input will
+                        // be calling through here after that change happens.
+                        Slog.w(TAG, "Focus gain on non-focused client " + cs.client
+                                + " (uid=" + cs.uid + " pid=" + cs.pid + ")");
+                        return null;
+                    }
+                } catch (RemoteException e) {
+                }
+
+                if (mCurFocusedWindow == windowToken) {
+                    Slog.w(TAG, "Window already focused, ignoring focus gain of: " + client
+                            + " attribute=" + attribute);
+                    if (attribute != null) {
+                        return startInputUncheckedLocked(cs, inputContext, attribute,
+                                controlFlags);
+                    }
+                    return null;
+                }
+                mCurFocusedWindow = windowToken;
+
+                // Should we auto-show the IME even if the caller has not
+                // specified what should be done with it?
+                // We only do this automatically if the window can resize
+                // to accommodate the IME (so what the user sees will give
+                // them good context without input information being obscured
+                // by the IME) or if running on a large screen where there
+                // is more room for the target window + IME.
+                final boolean doAutoShow =
+                        (softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST)
+                                == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE
+                        || mRes.getConfiguration().isLayoutSizeAtLeast(
+                                Configuration.SCREENLAYOUT_SIZE_LARGE);
+                final boolean isTextEditor =
+                        (controlFlags&InputMethodManager.CONTROL_WINDOW_IS_TEXT_EDITOR) != 0;
+
+                // We want to start input before showing the IME, but after closing
+                // it.  We want to do this after closing it to help the IME disappear
+                // more quickly (not get stuck behind it initializing itself for the
+                // new focused input, even if its window wants to hide the IME).
+                boolean didStart = false;
+                        
+                switch (softInputMode&WindowManager.LayoutParams.SOFT_INPUT_MASK_STATE) {
+                    case WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED:
+                        if (!isTextEditor || !doAutoShow) {
+                            if (WindowManager.LayoutParams.mayUseInputMethod(windowFlags)) {
+                                // There is no focus view, and this window will
+                                // be behind any soft input window, so hide the
+                                // soft input window if it is shown.
+                                if (DEBUG) Slog.v(TAG, "Unspecified window will hide input");
+                                hideCurrentInputLocked(InputMethodManager.HIDE_NOT_ALWAYS, null);
+                            }
+                        } else if (isTextEditor && doAutoShow && (softInputMode &
+                                WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != 0) {
+                            // There is a focus view, and we are navigating forward
+                            // into the window, so show the input window for the user.
+                            // We only do this automatically if the window can resize
+                            // to accommodate the IME (so what the user sees will give
+                            // them good context without input information being obscured
+                            // by the IME) or if running on a large screen where there
+                            // is more room for the target window + IME.
+                            if (DEBUG) Slog.v(TAG, "Unspecified window will show input");
+                            if (attribute != null) {
+                                res = startInputUncheckedLocked(cs, inputContext, attribute,
+                                        controlFlags);
+                                didStart = true;
+                            }
+                            showCurrentInputLocked(InputMethodManager.SHOW_IMPLICIT, null);
+                        }
+                        break;
+                    case WindowManager.LayoutParams.SOFT_INPUT_STATE_UNCHANGED:
+                        // Do nothing.
+                        break;
+                    case WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN:
+                        if ((softInputMode &
+                                WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != 0) {
+                            if (DEBUG) Slog.v(TAG, "Window asks to hide input going forward");
+                            hideCurrentInputLocked(0, null);
+                        }
+                        break;
+                    case WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN:
+                        if (DEBUG) Slog.v(TAG, "Window asks to hide input");
+                        hideCurrentInputLocked(0, null);
+                        break;
+                    case WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE:
+                        if ((softInputMode &
+                                WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != 0) {
+                            if (DEBUG) Slog.v(TAG, "Window asks to show input going forward");
+                            if (attribute != null) {
+                                res = startInputUncheckedLocked(cs, inputContext, attribute,
+                                        controlFlags);
+                                didStart = true;
+                            }
+                            showCurrentInputLocked(InputMethodManager.SHOW_IMPLICIT, null);
+                        }
+                        break;
+                    case WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE:
+                        if (DEBUG) Slog.v(TAG, "Window asks to always show input");
+                        if (attribute != null) {
+                            res = startInputUncheckedLocked(cs, inputContext, attribute,
+                                    controlFlags);
+                            didStart = true;
+                        }
+                        showCurrentInputLocked(InputMethodManager.SHOW_IMPLICIT, null);
+                        break;
+                }
+
+                if (!didStart && attribute != null) {
+                    res = startInputUncheckedLocked(cs, inputContext, attribute,
+                            controlFlags);
+                }
+            }
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+
+        return res;
+    }
+
+    @Override
+    public void showInputMethodPickerFromClient(IInputMethodClient client) {
+        synchronized (mMethodMap) {
+            if (mCurClient == null || client == null
+                    || mCurClient.client.asBinder() != client.asBinder()) {
+                Slog.w(TAG, "Ignoring showInputMethodPickerFromClient of uid "
+                        + Binder.getCallingUid() + ": " + client);
+            }
+
+            // Always call subtype picker, because subtype picker is a superset of input method
+            // picker.
+            mHandler.sendEmptyMessage(MSG_SHOW_IM_SUBTYPE_PICKER);
+        }
+    }
+
+    @Override
+    public void setInputMethod(IBinder token, String id) {
+        setInputMethodWithSubtypeId(token, id, NOT_A_SUBTYPE_ID);
+    }
+
+    @Override
+    public void setInputMethodAndSubtype(IBinder token, String id, InputMethodSubtype subtype) {
+        synchronized (mMethodMap) {
+            if (subtype != null) {
+                setInputMethodWithSubtypeId(token, id, getSubtypeIdFromHashCode(
+                        mMethodMap.get(id), subtype.hashCode()));
+            } else {
+                setInputMethod(token, id);
+            }
+        }
+    }
+
+    @Override
+    public void showInputMethodAndSubtypeEnablerFromClient(
+            IInputMethodClient client, String inputMethodId) {
+        synchronized (mMethodMap) {
+            if (mCurClient == null || client == null
+                || mCurClient.client.asBinder() != client.asBinder()) {
+                Slog.w(TAG, "Ignoring showInputMethodAndSubtypeEnablerFromClient of: " + client);
+            }
+            executeOrSendMessage(mCurMethod, mCaller.obtainMessageO(
+                    MSG_SHOW_IM_SUBTYPE_ENABLER, inputMethodId));
+        }
+    }
+
+    @Override
+    public boolean switchToLastInputMethod(IBinder token) {
+        synchronized (mMethodMap) {
+            final Pair<String, String> lastIme = mSettings.getLastInputMethodAndSubtypeLocked();
+            final InputMethodInfo lastImi;
+            if (lastIme != null) {
+                lastImi = mMethodMap.get(lastIme.first);
+            } else {
+                lastImi = null;
+            }
+            String targetLastImiId = null;
+            int subtypeId = NOT_A_SUBTYPE_ID;
+            if (lastIme != null && lastImi != null) {
+                final boolean imiIdIsSame = lastImi.getId().equals(mCurMethodId);
+                final int lastSubtypeHash = Integer.valueOf(lastIme.second);
+                final int currentSubtypeHash = mCurrentSubtype == null ? NOT_A_SUBTYPE_ID
+                        : mCurrentSubtype.hashCode();
+                // If the last IME is the same as the current IME and the last subtype is not
+                // defined, there is no need to switch to the last IME.
+                if (!imiIdIsSame || lastSubtypeHash != currentSubtypeHash) {
+                    targetLastImiId = lastIme.first;
+                    subtypeId = getSubtypeIdFromHashCode(lastImi, lastSubtypeHash);
+                }
+            }
+
+            if (TextUtils.isEmpty(targetLastImiId) && !canAddToLastInputMethod(mCurrentSubtype)) {
+                // This is a safety net. If the currentSubtype can't be added to the history
+                // and the framework couldn't find the last ime, we will make the last ime be
+                // the most applicable enabled keyboard subtype of the system imes.
+                final List<InputMethodInfo> enabled = mSettings.getEnabledInputMethodListLocked();
+                if (enabled != null) {
+                    final int N = enabled.size();
+                    final String locale = mCurrentSubtype == null
+                            ? mRes.getConfiguration().locale.toString()
+                            : mCurrentSubtype.getLocale();
+                    for (int i = 0; i < N; ++i) {
+                        final InputMethodInfo imi = enabled.get(i);
+                        if (imi.getSubtypeCount() > 0 && isSystemIme(imi)) {
+                            InputMethodSubtype keyboardSubtype =
+                                    findLastResortApplicableSubtypeLocked(mRes, getSubtypes(imi),
+                                            SUBTYPE_MODE_KEYBOARD, locale, true);
+                            if (keyboardSubtype != null) {
+                                targetLastImiId = imi.getId();
+                                subtypeId = getSubtypeIdFromHashCode(
+                                        imi, keyboardSubtype.hashCode());
+                                if(keyboardSubtype.getLocale().equals(locale)) {
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (!TextUtils.isEmpty(targetLastImiId)) {
+                if (DEBUG) {
+                    Slog.d(TAG, "Switch to: " + lastImi.getId() + ", " + lastIme.second
+                            + ", from: " + mCurMethodId + ", " + subtypeId);
+                }
+                setInputMethodWithSubtypeId(token, targetLastImiId, subtypeId);
+                return true;
+            } else {
+                return false;
+            }
+        }
+    }
+
+    @Override
+    public boolean switchToNextInputMethod(IBinder token, boolean onlyCurrentIme) {
+        synchronized (mMethodMap) {
+            final ImeSubtypeListItem nextSubtype = mImListManager.getNextInputMethod(
+                    onlyCurrentIme, mMethodMap.get(mCurMethodId), mCurrentSubtype);
+            if (nextSubtype == null) {
+                return false;
+            }
+            setInputMethodWithSubtypeId(token, nextSubtype.mImi.getId(), nextSubtype.mSubtypeId);
+            return true;
+        }
+    }
+
+    @Override
+    public InputMethodSubtype getLastInputMethodSubtype() {
+        synchronized (mMethodMap) {
+            final Pair<String, String> lastIme = mSettings.getLastInputMethodAndSubtypeLocked();
+            // TODO: Handle the case of the last IME with no subtypes
+            if (lastIme == null || TextUtils.isEmpty(lastIme.first)
+                    || TextUtils.isEmpty(lastIme.second)) return null;
+            final InputMethodInfo lastImi = mMethodMap.get(lastIme.first);
+            if (lastImi == null) return null;
+            try {
+                final int lastSubtypeHash = Integer.valueOf(lastIme.second);
+                final int lastSubtypeId = getSubtypeIdFromHashCode(lastImi, lastSubtypeHash);
+                if (lastSubtypeId < 0 || lastSubtypeId >= lastImi.getSubtypeCount()) {
+                    return null;
+                }
+                return lastImi.getSubtypeAt(lastSubtypeId);
+            } catch (NumberFormatException e) {
+                return null;
+            }
+        }
+    }
+
+    @Override
+    public void setAdditionalInputMethodSubtypes(String imiId, InputMethodSubtype[] subtypes) {
+        // By this IPC call, only a process which shares the same uid with the IME can add
+        // additional input method subtypes to the IME.
+        if (TextUtils.isEmpty(imiId) || subtypes == null || subtypes.length == 0) return;
+        synchronized (mMethodMap) {
+            final InputMethodInfo imi = mMethodMap.get(imiId);
+            if (imi == null) return;
+            final PackageManager pm = mContext.getPackageManager();
+            final String[] packageInfos = pm.getPackagesForUid(Binder.getCallingUid());
+            if (packageInfos != null) {
+                final int packageNum = packageInfos.length;
+                for (int i = 0; i < packageNum; ++i) {
+                    if (packageInfos[i].equals(imi.getPackageName())) {
+                        mFileManager.addInputMethodSubtypes(imi, subtypes);
+                        final long ident = Binder.clearCallingIdentity();
+                        try {
+                            buildInputMethodListLocked(mMethodList, mMethodMap);
+                        } finally {
+                            Binder.restoreCallingIdentity(ident);
+                        }
+                        return;
+                    }
+                }
+            }
+        }
+        return;
+    }
+
+    private void setInputMethodWithSubtypeId(IBinder token, String id, int subtypeId) {
+        synchronized (mMethodMap) {
+            if (token == null) {
+                if (mContext.checkCallingOrSelfPermission(
+                        android.Manifest.permission.WRITE_SECURE_SETTINGS)
+                        != PackageManager.PERMISSION_GRANTED) {
+                    throw new SecurityException(
+                            "Using null token requires permission "
+                            + android.Manifest.permission.WRITE_SECURE_SETTINGS);
+                }
+            } else if (mCurToken != token) {
+                Slog.w(TAG, "Ignoring setInputMethod of uid " + Binder.getCallingUid()
+                        + " token: " + token);
+                return;
+            }
+
+            final long ident = Binder.clearCallingIdentity();
+            try {
+                setInputMethodLocked(id, subtypeId);
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+    }
+
+    @Override
+    public void hideMySoftInput(IBinder token, int flags) {
+        synchronized (mMethodMap) {
+            if (token == null || mCurToken != token) {
+                if (DEBUG) Slog.w(TAG, "Ignoring hideInputMethod of uid "
+                        + Binder.getCallingUid() + " token: " + token);
+                return;
+            }
+            long ident = Binder.clearCallingIdentity();
+            try {
+                hideCurrentInputLocked(flags, null);
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+    }
+
+    @Override
+    public void showMySoftInput(IBinder token, int flags) {
+        synchronized (mMethodMap) {
+            if (token == null || mCurToken != token) {
+                Slog.w(TAG, "Ignoring showMySoftInput of uid "
+                        + Binder.getCallingUid() + " token: " + token);
+                return;
+            }
+            long ident = Binder.clearCallingIdentity();
+            try {
+                showCurrentInputLocked(flags, null);
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+    }
+
+    void setEnabledSessionInMainThread(SessionState session) {
+        if (mEnabledSession != session) {
+            if (mEnabledSession != null) {
+                try {
+                    if (DEBUG) Slog.v(TAG, "Disabling: " + mEnabledSession);
+                    mEnabledSession.method.setSessionEnabled(
+                            mEnabledSession.session, false);
+                } catch (RemoteException e) {
+                }
+            }
+            mEnabledSession = session;
+            try {
+                if (DEBUG) Slog.v(TAG, "Enabling: " + mEnabledSession);
+                session.method.setSessionEnabled(
+                        session.session, true);
+            } catch (RemoteException e) {
+            }
+        }
+    }
+
+    @Override
+    public boolean handleMessage(Message msg) {
+        HandlerCaller.SomeArgs args;
+        switch (msg.what) {
+            case MSG_SHOW_IM_PICKER:
+                showInputMethodMenu();
+                return true;
+
+            case MSG_SHOW_IM_SUBTYPE_PICKER:
+                showInputMethodSubtypeMenu();
+                return true;
+
+            case MSG_SHOW_IM_SUBTYPE_ENABLER:
+                args = (HandlerCaller.SomeArgs)msg.obj;
+                showInputMethodAndSubtypeEnabler((String)args.arg1);
+                return true;
+
+            case MSG_SHOW_IM_CONFIG:
+                showConfigureInputMethods();
+                return true;
+
+            // ---------------------------------------------------------
+
+            case MSG_UNBIND_INPUT:
+                try {
+                    ((IInputMethod)msg.obj).unbindInput();
+                } catch (RemoteException e) {
+                    // There is nothing interesting about the method dying.
+                }
+                return true;
+            case MSG_BIND_INPUT:
+                args = (HandlerCaller.SomeArgs)msg.obj;
+                try {
+                    ((IInputMethod)args.arg1).bindInput((InputBinding)args.arg2);
+                } catch (RemoteException e) {
+                }
+                return true;
+            case MSG_SHOW_SOFT_INPUT:
+                args = (HandlerCaller.SomeArgs)msg.obj;
+                try {
+                    ((IInputMethod)args.arg1).showSoftInput(msg.arg1,
+                            (ResultReceiver)args.arg2);
+                } catch (RemoteException e) {
+                }
+                return true;
+            case MSG_HIDE_SOFT_INPUT:
+                args = (HandlerCaller.SomeArgs)msg.obj;
+                try {
+                    ((IInputMethod)args.arg1).hideSoftInput(0,
+                            (ResultReceiver)args.arg2);
+                } catch (RemoteException e) {
+                }
+                return true;
+            case MSG_ATTACH_TOKEN:
+                args = (HandlerCaller.SomeArgs)msg.obj;
+                try {
+                    if (DEBUG) Slog.v(TAG, "Sending attach of token: " + args.arg2);
+                    ((IInputMethod)args.arg1).attachToken((IBinder)args.arg2);
+                } catch (RemoteException e) {
+                }
+                return true;
+            case MSG_CREATE_SESSION:
+                args = (HandlerCaller.SomeArgs)msg.obj;
+                try {
+                    ((IInputMethod)args.arg1).createSession(
+                            (IInputMethodCallback)args.arg2);
+                } catch (RemoteException e) {
+                }
+                return true;
+            // ---------------------------------------------------------
+
+            case MSG_START_INPUT:
+                args = (HandlerCaller.SomeArgs)msg.obj;
+                try {
+                    SessionState session = (SessionState)args.arg1;
+                    setEnabledSessionInMainThread(session);
+                    session.method.startInput((IInputContext)args.arg2,
+                            (EditorInfo)args.arg3);
+                } catch (RemoteException e) {
+                }
+                return true;
+            case MSG_RESTART_INPUT:
+                args = (HandlerCaller.SomeArgs)msg.obj;
+                try {
+                    SessionState session = (SessionState)args.arg1;
+                    setEnabledSessionInMainThread(session);
+                    session.method.restartInput((IInputContext)args.arg2,
+                            (EditorInfo)args.arg3);
+                } catch (RemoteException e) {
+                }
+                return true;
+
+            // ---------------------------------------------------------
+
+            case MSG_UNBIND_METHOD:
+                try {
+                    ((IInputMethodClient)msg.obj).onUnbindMethod(msg.arg1);
+                } catch (RemoteException e) {
+                    // There is nothing interesting about the last client dying.
+                }
+                return true;
+            case MSG_BIND_METHOD:
+                args = (HandlerCaller.SomeArgs)msg.obj;
+                try {
+                    ((IInputMethodClient)args.arg1).onBindMethod(
+                            (InputBindResult)args.arg2);
+                } catch (RemoteException e) {
+                    Slog.w(TAG, "Client died receiving input method " + args.arg2);
+                }
+                return true;
+            case MSG_SET_ACTIVE:
+                try {
+                    ((ClientState)msg.obj).client.setActive(msg.arg1 != 0);
+                } catch (RemoteException e) {
+                    Slog.w(TAG, "Got RemoteException sending setActive(false) notification to pid "
+                            + ((ClientState)msg.obj).pid + " uid "
+                            + ((ClientState)msg.obj).uid);
+                }
+                return true;
+
+            // --------------------------------------------------------------
+            case MSG_HARD_KEYBOARD_SWITCH_CHANGED:
+                mHardKeyboardListener.handleHardKeyboardStatusChange(
+                        msg.arg1 == 1, msg.arg2 == 1);
+                return true;
+        }
+        return false;
+    }
+
+    private static boolean isSystemIme(InputMethodInfo inputMethod) {
+        return (inputMethod.getServiceInfo().applicationInfo.flags
+                & ApplicationInfo.FLAG_SYSTEM) != 0;
+    }
+
+    private static ArrayList<InputMethodSubtype> getSubtypes(InputMethodInfo imi) {
+        ArrayList<InputMethodSubtype> subtypes = new ArrayList<InputMethodSubtype>();
+        final int subtypeCount = imi.getSubtypeCount();
+        for (int i = 0; i < subtypeCount; ++i) {
+            subtypes.add(imi.getSubtypeAt(i));
+        }
+        return subtypes;
+    }
+
+    private static ArrayList<InputMethodSubtype> getOverridingImplicitlyEnabledSubtypes(
+            InputMethodInfo imi, String mode) {
+        ArrayList<InputMethodSubtype> subtypes = new ArrayList<InputMethodSubtype>();
+        final int subtypeCount = imi.getSubtypeCount();
+        for (int i = 0; i < subtypeCount; ++i) {
+            final InputMethodSubtype subtype = imi.getSubtypeAt(i);
+            if (subtype.overridesImplicitlyEnabledSubtype() && subtype.getMode().equals(mode)) {
+                subtypes.add(subtype);
+            }
+        }
+        return subtypes;
+    }
+
+    private InputMethodInfo getMostApplicableDefaultIMELocked() {
+        List<InputMethodInfo> enabled = mSettings.getEnabledInputMethodListLocked();
+        if (enabled != null && enabled.size() > 0) {
+            // We'd prefer to fall back on a system IME, since that is safer.
+            int i = enabled.size();
+            int firstFoundSystemIme = -1;
+            while (i > 0) {
+                i--;
+                final InputMethodInfo imi = enabled.get(i);
+                if (isSystemImeThatHasEnglishSubtype(imi) && !imi.isAuxiliaryIme()) {
+                    return imi;
+                }
+                if (firstFoundSystemIme < 0 && isSystemIme(imi) && !imi.isAuxiliaryIme()) {
+                    firstFoundSystemIme = i;
+                }
+            }
+            return enabled.get(Math.max(firstFoundSystemIme, 0));
+        }
+        return null;
+    }
+
+    private boolean chooseNewDefaultIMELocked() {
+        final InputMethodInfo imi = getMostApplicableDefaultIMELocked();
+        if (imi != null) {
+            if (DEBUG) {
+                Slog.d(TAG, "New default IME was selected: " + imi.getId());
+            }
+            resetSelectedInputMethodAndSubtypeLocked(imi.getId());
+            return true;
+        }
+
+        return false;
+    }
+
+    void buildInputMethodListLocked(ArrayList<InputMethodInfo> list,
+            HashMap<String, InputMethodInfo> map) {
+        list.clear();
+        map.clear();
+
+        PackageManager pm = mContext.getPackageManager();
+        final Configuration config = mRes.getConfiguration();
+        final boolean haveHardKeyboard = config.keyboard == Configuration.KEYBOARD_QWERTY;
+        String disabledSysImes = Settings.Secure.getString(mContext.getContentResolver(),
+                Secure.DISABLED_SYSTEM_INPUT_METHODS);
+        if (disabledSysImes == null) disabledSysImes = "";
+
+        List<ResolveInfo> services = pm.queryIntentServices(
+                new Intent(InputMethod.SERVICE_INTERFACE),
+                PackageManager.GET_META_DATA);
+
+        final HashMap<String, List<InputMethodSubtype>> additionalSubtypes =
+                mFileManager.getAllAdditionalInputMethodSubtypes();
+        for (int i = 0; i < services.size(); ++i) {
+            ResolveInfo ri = services.get(i);
+            ServiceInfo si = ri.serviceInfo;
+            ComponentName compName = new ComponentName(si.packageName, si.name);
+            if (!android.Manifest.permission.BIND_INPUT_METHOD.equals(
+                    si.permission)) {
+                Slog.w(TAG, "Skipping input method " + compName
+                        + ": it does not require the permission "
+                        + android.Manifest.permission.BIND_INPUT_METHOD);
+                continue;
+            }
+
+            if (DEBUG) Slog.d(TAG, "Checking " + compName);
+
+            try {
+                InputMethodInfo p = new InputMethodInfo(mContext, ri, additionalSubtypes);
+                list.add(p);
+                final String id = p.getId();
+                map.put(id, p);
+
+                // Valid system default IMEs and IMEs that have English subtypes are enabled
+                // by default, unless there's a hard keyboard and the system IME was explicitly
+                // disabled
+                if ((isValidSystemDefaultIme(p, mContext) || isSystemImeThatHasEnglishSubtype(p))
+                        && (!haveHardKeyboard || disabledSysImes.indexOf(id) < 0)) {
+                    setInputMethodEnabledLocked(id, true);
+                }
+
+                if (DEBUG) {
+                    Slog.d(TAG, "Found a third-party input method " + p);
+                }
+
+            } catch (XmlPullParserException e) {
+                Slog.w(TAG, "Unable to load input method " + compName, e);
+            } catch (IOException e) {
+                Slog.w(TAG, "Unable to load input method " + compName, e);
+            }
+        }
+
+        final String defaultImiId = Settings.Secure.getString(mContext
+                .getContentResolver(), Settings.Secure.DEFAULT_INPUT_METHOD);
+        if (!TextUtils.isEmpty(defaultImiId)) {
+            if (!map.containsKey(defaultImiId)) {
+                Slog.w(TAG, "Default IME is uninstalled. Choose new default IME.");
+                if (chooseNewDefaultIMELocked()) {
+                    updateFromSettingsLocked();
+                }
+            } else {
+                // Double check that the default IME is certainly enabled.
+                setInputMethodEnabledLocked(defaultImiId, true);
+            }
+        }
+    }
+
+    // ----------------------------------------------------------------------
+
+    private void showInputMethodMenu() {
+        showInputMethodMenuInternal(false);
+    }
+
+    private void showInputMethodSubtypeMenu() {
+        showInputMethodMenuInternal(true);
+    }
+
+    private void showInputMethodAndSubtypeEnabler(String inputMethodId) {
+        Intent intent = new Intent(Settings.ACTION_INPUT_METHOD_SUBTYPE_SETTINGS);
+        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
+                | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED
+                | Intent.FLAG_ACTIVITY_CLEAR_TOP);
+        if (!TextUtils.isEmpty(inputMethodId)) {
+            intent.putExtra(Settings.EXTRA_INPUT_METHOD_ID, inputMethodId);
+        }
+        mContext.startActivity(intent);
+    }
+
+    private void showConfigureInputMethods() {
+        Intent intent = new Intent(Settings.ACTION_INPUT_METHOD_SETTINGS);
+        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
+                | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED
+                | Intent.FLAG_ACTIVITY_CLEAR_TOP);
+        mContext.startActivity(intent);
+    }
+
+    private boolean isScreenLocked() {
+        return mKeyguardManager != null
+                && mKeyguardManager.isKeyguardLocked() && mKeyguardManager.isKeyguardSecure();
+    }
+    private void showInputMethodMenuInternal(boolean showSubtypes) {
+        if (DEBUG) Slog.v(TAG, "Show switching menu");
+
+        final Context context = mContext;
+        final PackageManager pm = context.getPackageManager();
+        final boolean isScreenLocked = isScreenLocked();
+
+        final String lastInputMethodId = Settings.Secure.getString(context
+                .getContentResolver(), Settings.Secure.DEFAULT_INPUT_METHOD);
+        int lastInputMethodSubtypeId = getSelectedInputMethodSubtypeId(lastInputMethodId);
+        if (DEBUG) Slog.v(TAG, "Current IME: " + lastInputMethodId);
+
+        synchronized (mMethodMap) {
+            final HashMap<InputMethodInfo, List<InputMethodSubtype>> immis =
+                    getExplicitlyOrImplicitlyEnabledInputMethodsAndSubtypeListLocked();
+            if (immis == null || immis.size() == 0) {
+                return;
+            }
+
+            hideInputMethodMenuLocked();
+
+            final List<ImeSubtypeListItem> imList =
+                    mImListManager.getSortedInputMethodAndSubtypeList(
+                            showSubtypes, mInputShown, isScreenLocked);
+
+            if (lastInputMethodSubtypeId == NOT_A_SUBTYPE_ID) {
+                final InputMethodSubtype currentSubtype = getCurrentInputMethodSubtype();
+                if (currentSubtype != null) {
+                    final InputMethodInfo currentImi = mMethodMap.get(mCurMethodId);
+                    lastInputMethodSubtypeId =
+                            getSubtypeIdFromHashCode(currentImi, currentSubtype.hashCode());
+                }
+            }
+
+            final int N = imList.size();
+            mIms = new InputMethodInfo[N];
+            mSubtypeIds = new int[N];
+            int checkedItem = 0;
+            for (int i = 0; i < N; ++i) {
+                final ImeSubtypeListItem item = imList.get(i);
+                mIms[i] = item.mImi;
+                mSubtypeIds[i] = item.mSubtypeId;
+                if (mIms[i].getId().equals(lastInputMethodId)) {
+                    int subtypeId = mSubtypeIds[i];
+                    if ((subtypeId == NOT_A_SUBTYPE_ID)
+                            || (lastInputMethodSubtypeId == NOT_A_SUBTYPE_ID && subtypeId == 0)
+                            || (subtypeId == lastInputMethodSubtypeId)) {
+                        checkedItem = i;
+                    }
+                }
+            }
+            final TypedArray a = context.obtainStyledAttributes(null,
+                    com.android.internal.R.styleable.DialogPreference,
+                    com.android.internal.R.attr.alertDialogStyle, 0);
+            mDialogBuilder = new AlertDialog.Builder(context)
+                    .setOnCancelListener(new OnCancelListener() {
+                        @Override
+                        public void onCancel(DialogInterface dialog) {
+                            hideInputMethodMenu();
+                        }
+                    })
+                    .setIcon(a.getDrawable(
+                            com.android.internal.R.styleable.DialogPreference_dialogTitle));
+            a.recycle();
+            final LayoutInflater inflater =
+                    (LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+            final View tv = inflater.inflate(
+                    com.android.internal.R.layout.input_method_switch_dialog_title, null);
+            mDialogBuilder.setCustomTitle(tv);
+
+            // Setup layout for a toggle switch of the hardware keyboard
+            mSwitchingDialogTitleView = tv;
+            mSwitchingDialogTitleView.findViewById(
+                    com.android.internal.R.id.hard_keyboard_section).setVisibility(
+                            mWindowManagerService.isHardKeyboardAvailable() ?
+                                    View.VISIBLE : View.GONE);
+            final Switch hardKeySwitch =  ((Switch)mSwitchingDialogTitleView.findViewById(
+                    com.android.internal.R.id.hard_keyboard_switch));
+            hardKeySwitch.setChecked(mWindowManagerService.isHardKeyboardEnabled());
+            hardKeySwitch.setOnCheckedChangeListener(
+                    new OnCheckedChangeListener() {
+                        @Override
+                        public void onCheckedChanged(
+                                CompoundButton buttonView, boolean isChecked) {
+                            mWindowManagerService.setHardKeyboardEnabled(isChecked);
+                        }
+                    });
+
+            final ImeSubtypeListAdapter adapter = new ImeSubtypeListAdapter(context,
+                    com.android.internal.R.layout.simple_list_item_2_single_choice, imList,
+                    checkedItem);
+
+            mDialogBuilder.setSingleChoiceItems(adapter, checkedItem,
+                    new AlertDialog.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialog, int which) {
+                            synchronized (mMethodMap) {
+                                if (mIms == null || mIms.length <= which
+                                        || mSubtypeIds == null || mSubtypeIds.length <= which) {
+                                    return;
+                                }
+                                InputMethodInfo im = mIms[which];
+                                int subtypeId = mSubtypeIds[which];
+                                hideInputMethodMenu();
+                                if (im != null) {
+                                    if ((subtypeId < 0)
+                                            || (subtypeId >= im.getSubtypeCount())) {
+                                        subtypeId = NOT_A_SUBTYPE_ID;
+                                    }
+                                    setInputMethodLocked(im.getId(), subtypeId);
+                                }
+                            }
+                        }
+                    });
+
+            if (showSubtypes && !isScreenLocked) {
+                mDialogBuilder.setPositiveButton(
+                        com.android.internal.R.string.configure_input_methods,
+                        new DialogInterface.OnClickListener() {
+                            @Override
+                            public void onClick(DialogInterface dialog, int whichButton) {
+                                showConfigureInputMethods();
+                            }
+                        });
+            }
+            mSwitchingDialog = mDialogBuilder.create();
+            mSwitchingDialog.setCanceledOnTouchOutside(true);
+            mSwitchingDialog.getWindow().setType(
+                    WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG);
+            mSwitchingDialog.getWindow().getAttributes().setTitle("Select input method");
+            mSwitchingDialog.show();
+        }
+    }
+
+    private static class ImeSubtypeListItem implements Comparable<ImeSubtypeListItem> {
+        public final CharSequence mImeName;
+        public final CharSequence mSubtypeName;
+        public final InputMethodInfo mImi;
+        public final int mSubtypeId;
+        private final boolean mIsSystemLocale;
+        private final boolean mIsSystemLanguage;
+
+        public ImeSubtypeListItem(CharSequence imeName, CharSequence subtypeName,
+                InputMethodInfo imi, int subtypeId, String subtypeLocale, String systemLocale) {
+            mImeName = imeName;
+            mSubtypeName = subtypeName;
+            mImi = imi;
+            mSubtypeId = subtypeId;
+            if (TextUtils.isEmpty(subtypeLocale)) {
+                mIsSystemLocale = false;
+                mIsSystemLanguage = false;
+            } else {
+                mIsSystemLocale = subtypeLocale.equals(systemLocale);
+                mIsSystemLanguage = mIsSystemLocale
+                        || subtypeLocale.startsWith(systemLocale.substring(0, 2));
+            }
+        }
+
+        @Override
+        public int compareTo(ImeSubtypeListItem other) {
+            if (TextUtils.isEmpty(mImeName)) {
+                return 1;
+            }
+            if (TextUtils.isEmpty(other.mImeName)) {
+                return -1;
+            }
+            if (!TextUtils.equals(mImeName, other.mImeName)) {
+                return mImeName.toString().compareTo(other.mImeName.toString());
+            }
+            if (TextUtils.equals(mSubtypeName, other.mSubtypeName)) {
+                return 0;
+            }
+            if (mIsSystemLocale) {
+                return -1;
+            }
+            if (other.mIsSystemLocale) {
+                return 1;
+            }
+            if (mIsSystemLanguage) {
+                return -1;
+            }
+            if (other.mIsSystemLanguage) {
+                return 1;
+            }
+            if (TextUtils.isEmpty(mSubtypeName)) {
+                return 1;
+            }
+            if (TextUtils.isEmpty(other.mSubtypeName)) {
+                return -1;
+            }
+            return mSubtypeName.toString().compareTo(other.mSubtypeName.toString());
+        }
+    }
+
+    private static class ImeSubtypeListAdapter extends ArrayAdapter<ImeSubtypeListItem> {
+        private final LayoutInflater mInflater;
+        private final int mTextViewResourceId;
+        private final List<ImeSubtypeListItem> mItemsList;
+        private final int mCheckedItem;
+        public ImeSubtypeListAdapter(Context context, int textViewResourceId,
+                List<ImeSubtypeListItem> itemsList, int checkedItem) {
+            super(context, textViewResourceId, itemsList);
+            mTextViewResourceId = textViewResourceId;
+            mItemsList = itemsList;
+            mCheckedItem = checkedItem;
+            mInflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        }
+
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
+            final View view = convertView != null ? convertView
+                    : mInflater.inflate(mTextViewResourceId, null);
+            if (position < 0 || position >= mItemsList.size()) return view;
+            final ImeSubtypeListItem item = mItemsList.get(position);
+            final CharSequence imeName = item.mImeName;
+            final CharSequence subtypeName = item.mSubtypeName;
+            final TextView firstTextView = (TextView)view.findViewById(android.R.id.text1);
+            final TextView secondTextView = (TextView)view.findViewById(android.R.id.text2);
+            if (TextUtils.isEmpty(subtypeName)) {
+                firstTextView.setText(imeName);
+                secondTextView.setVisibility(View.GONE);
+            } else {
+                firstTextView.setText(subtypeName);
+                secondTextView.setText(imeName);
+                secondTextView.setVisibility(View.VISIBLE);
+            }
+            final RadioButton radioButton =
+                    (RadioButton)view.findViewById(com.android.internal.R.id.radio);
+            radioButton.setChecked(position == mCheckedItem);
+            return view;
+        }
+    }
+
+    void hideInputMethodMenu() {
+        synchronized (mMethodMap) {
+            hideInputMethodMenuLocked();
+        }
+    }
+
+    void hideInputMethodMenuLocked() {
+        if (DEBUG) Slog.v(TAG, "Hide switching menu");
+
+        if (mSwitchingDialog != null) {
+            mSwitchingDialog.dismiss();
+            mSwitchingDialog = null;
+        }
+
+        mDialogBuilder = null;
+        mIms = null;
+    }
+
+    // ----------------------------------------------------------------------
+
+    @Override
+    public boolean setInputMethodEnabled(String id, boolean enabled) {
+        synchronized (mMethodMap) {
+            if (mContext.checkCallingOrSelfPermission(
+                    android.Manifest.permission.WRITE_SECURE_SETTINGS)
+                    != PackageManager.PERMISSION_GRANTED) {
+                throw new SecurityException(
+                        "Requires permission "
+                        + android.Manifest.permission.WRITE_SECURE_SETTINGS);
+            }
+            
+            long ident = Binder.clearCallingIdentity();
+            try {
+                return setInputMethodEnabledLocked(id, enabled);
+            } finally {
+                Binder.restoreCallingIdentity(ident);
+            }
+        }
+    }
+    
+    boolean setInputMethodEnabledLocked(String id, boolean enabled) {
+        // Make sure this is a valid input method.
+        InputMethodInfo imm = mMethodMap.get(id);
+        if (imm == null) {
+            throw new IllegalArgumentException("Unknown id: " + mCurMethodId);
+        }
+
+        List<Pair<String, ArrayList<String>>> enabledInputMethodsList = mSettings
+                .getEnabledInputMethodsAndSubtypeListLocked();
+
+        if (enabled) {
+            for (Pair<String, ArrayList<String>> pair: enabledInputMethodsList) {
+                if (pair.first.equals(id)) {
+                    // We are enabling this input method, but it is already enabled.
+                    // Nothing to do. The previous state was enabled.
+                    return true;
+                }
+            }
+            mSettings.appendAndPutEnabledInputMethodLocked(id, false);
+            // Previous state was disabled.
+            return false;
+        } else {
+            StringBuilder builder = new StringBuilder();
+            if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(
+                    builder, enabledInputMethodsList, id)) {
+                // Disabled input method is currently selected, switch to another one.
+                String selId = Settings.Secure.getString(mContext.getContentResolver(),
+                        Settings.Secure.DEFAULT_INPUT_METHOD);
+                if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
+                    Slog.i(TAG, "Can't find new IME, unsetting the current input method.");
+                    resetSelectedInputMethodAndSubtypeLocked("");
+                }
+                // Previous state was enabled.
+                return true;
+            } else {
+                // We are disabling the input method but it is already disabled.
+                // Nothing to do.  The previous state was disabled.
+                return false;
+            }
+        }
+    }
+
+    private boolean canAddToLastInputMethod(InputMethodSubtype subtype) {
+        if (subtype == null) return true;
+        return !subtype.isAuxiliary();
+    }
+
+    private void saveCurrentInputMethodAndSubtypeToHistory() {
+        String subtypeId = NOT_A_SUBTYPE_ID_STR;
+        if (mCurrentSubtype != null) {
+            subtypeId = String.valueOf(mCurrentSubtype.hashCode());
+        }
+        if (canAddToLastInputMethod(mCurrentSubtype)) {
+            mSettings.addSubtypeToHistory(mCurMethodId, subtypeId);
+        }
+    }
+
+    private void setSelectedInputMethodAndSubtypeLocked(InputMethodInfo imi, int subtypeId,
+            boolean setSubtypeOnly) {
+        // Update the history of InputMethod and Subtype
+        saveCurrentInputMethodAndSubtypeToHistory();
+
+        // Set Subtype here
+        if (imi == null || subtypeId < 0) {
+            mSettings.putSelectedSubtype(NOT_A_SUBTYPE_ID);
+            mCurrentSubtype = null;
+        } else {
+            if (subtypeId < imi.getSubtypeCount()) {
+                InputMethodSubtype subtype = imi.getSubtypeAt(subtypeId);
+                mSettings.putSelectedSubtype(subtype.hashCode());
+                mCurrentSubtype = subtype;
+            } else {
+                mSettings.putSelectedSubtype(NOT_A_SUBTYPE_ID);
+                // If the subtype is not specified, choose the most applicable one
+                mCurrentSubtype = getCurrentInputMethodSubtype();
+            }
+        }
+
+        // Workaround.
+        // ASEC is not ready in the IMMS constructor. Accordingly, forward-locked
+        // IMEs are not recognized and considered uninstalled.
+        // Actually, we can't move everything after SystemReady because
+        // IMMS needs to run in the encryption lock screen. So, we just skip changing
+        // the default IME here and try cheking the default IME again in systemReady().
+        // TODO: Do nothing before system ready and implement a separated logic for
+        // the encryption lock screen.
+        // TODO: ASEC should be ready before IMMS is instantiated.
+        if (mSystemReady && !setSubtypeOnly) {
+            // Set InputMethod here
+            mSettings.putSelectedInputMethod(imi != null ? imi.getId() : "");
+        }
+    }
+
+    private void resetSelectedInputMethodAndSubtypeLocked(String newDefaultIme) {
+        InputMethodInfo imi = mMethodMap.get(newDefaultIme);
+        int lastSubtypeId = NOT_A_SUBTYPE_ID;
+        // newDefaultIme is empty when there is no candidate for the selected IME.
+        if (imi != null && !TextUtils.isEmpty(newDefaultIme)) {
+            String subtypeHashCode = mSettings.getLastSubtypeForInputMethodLocked(newDefaultIme);
+            if (subtypeHashCode != null) {
+                try {
+                    lastSubtypeId = getSubtypeIdFromHashCode(
+                            imi, Integer.valueOf(subtypeHashCode));
+                } catch (NumberFormatException e) {
+                    Slog.w(TAG, "HashCode for subtype looks broken: " + subtypeHashCode, e);
+                }
+            }
+        }
+        setSelectedInputMethodAndSubtypeLocked(imi, lastSubtypeId, false);
+    }
+
+    private int getSelectedInputMethodSubtypeId(String id) {
+        InputMethodInfo imi = mMethodMap.get(id);
+        if (imi == null) {
+            return NOT_A_SUBTYPE_ID;
+        }
+        int subtypeId;
+        try {
+            subtypeId = Settings.Secure.getInt(mContext.getContentResolver(),
+                    Settings.Secure.SELECTED_INPUT_METHOD_SUBTYPE);
+        } catch (SettingNotFoundException e) {
+            return NOT_A_SUBTYPE_ID;
+        }
+        return getSubtypeIdFromHashCode(imi, subtypeId);
+    }
+
+    private static boolean isValidSubtypeId(InputMethodInfo imi, int subtypeHashCode) {
+        return getSubtypeIdFromHashCode(imi, subtypeHashCode) != NOT_A_SUBTYPE_ID;
+    }
+
+    private static int getSubtypeIdFromHashCode(InputMethodInfo imi, int subtypeHashCode) {
+        if (imi != null) {
+            final int subtypeCount = imi.getSubtypeCount();
+            for (int i = 0; i < subtypeCount; ++i) {
+                InputMethodSubtype ims = imi.getSubtypeAt(i);
+                if (subtypeHashCode == ims.hashCode()) {
+                    return i;
+                }
+            }
+        }
+        return NOT_A_SUBTYPE_ID;
+    }
+
+    private static ArrayList<InputMethodSubtype> getImplicitlyApplicableSubtypesLocked(
+            Resources res, InputMethodInfo imi) {
+        final List<InputMethodSubtype> subtypes = getSubtypes(imi);
+        final String systemLocale = res.getConfiguration().locale.toString();
+        if (TextUtils.isEmpty(systemLocale)) return new ArrayList<InputMethodSubtype>();
+        final HashMap<String, InputMethodSubtype> applicableModeAndSubtypesMap =
+                new HashMap<String, InputMethodSubtype>();
+        final int N = subtypes.size();
+        for (int i = 0; i < N; ++i) {
+            // scan overriding implicitly enabled subtypes.
+            InputMethodSubtype subtype = subtypes.get(i);
+            if (subtype.overridesImplicitlyEnabledSubtype()) {
+                final String mode = subtype.getMode();
+                if (!applicableModeAndSubtypesMap.containsKey(mode)) {
+                    applicableModeAndSubtypesMap.put(mode, subtype);
+                }
+            }
+        }
+        if (applicableModeAndSubtypesMap.size() > 0) {
+            return new ArrayList<InputMethodSubtype>(applicableModeAndSubtypesMap.values());
+        }
+        for (int i = 0; i < N; ++i) {
+            final InputMethodSubtype subtype = subtypes.get(i);
+            final String locale = subtype.getLocale();
+            final String mode = subtype.getMode();
+            // When system locale starts with subtype's locale, that subtype will be applicable
+            // for system locale
+            // For instance, it's clearly applicable for cases like system locale = en_US and
+            // subtype = en, but it is not necessarily considered applicable for cases like system
+            // locale = en and subtype = en_US.
+            // We just call systemLocale.startsWith(locale) in this function because there is no
+            // need to find applicable subtypes aggressively unlike
+            // findLastResortApplicableSubtypeLocked.
+            if (systemLocale.startsWith(locale)) {
+                final InputMethodSubtype applicableSubtype = applicableModeAndSubtypesMap.get(mode);
+                // If more applicable subtypes are contained, skip.
+                if (applicableSubtype != null) {
+                    if (systemLocale.equals(applicableSubtype.getLocale())) continue;
+                    if (!systemLocale.equals(locale)) continue;
+                }
+                applicableModeAndSubtypesMap.put(mode, subtype);
+            }
+        }
+        final InputMethodSubtype keyboardSubtype
+                = applicableModeAndSubtypesMap.get(SUBTYPE_MODE_KEYBOARD);
+        final ArrayList<InputMethodSubtype> applicableSubtypes = new ArrayList<InputMethodSubtype>(
+                applicableModeAndSubtypesMap.values());
+        if (keyboardSubtype != null && !keyboardSubtype.containsExtraValueKey(TAG_ASCII_CAPABLE)) {
+            for (int i = 0; i < N; ++i) {
+                final InputMethodSubtype subtype = subtypes.get(i);
+                final String mode = subtype.getMode();
+                if (SUBTYPE_MODE_KEYBOARD.equals(mode) && subtype.containsExtraValueKey(
+                        TAG_ENABLED_WHEN_DEFAULT_IS_NOT_ASCII_CAPABLE)) {
+                    applicableSubtypes.add(subtype);
+                }
+            }
+        }
+        if (keyboardSubtype == null) {
+            InputMethodSubtype lastResortKeyboardSubtype = findLastResortApplicableSubtypeLocked(
+                    res, subtypes, SUBTYPE_MODE_KEYBOARD, systemLocale, true);
+            if (lastResortKeyboardSubtype != null) {
+                applicableSubtypes.add(lastResortKeyboardSubtype);
+            }
+        }
+        return applicableSubtypes;
+    }
+
+    /**
+     * If there are no selected subtypes, tries finding the most applicable one according to the
+     * given locale.
+     * @param subtypes this function will search the most applicable subtype in subtypes
+     * @param mode subtypes will be filtered by mode
+     * @param locale subtypes will be filtered by locale
+     * @param canIgnoreLocaleAsLastResort if this function can't find the most applicable subtype,
+     * it will return the first subtype matched with mode
+     * @return the most applicable subtypeId
+     */
+    private static InputMethodSubtype findLastResortApplicableSubtypeLocked(
+            Resources res, List<InputMethodSubtype> subtypes, String mode, String locale,
+            boolean canIgnoreLocaleAsLastResort) {
+        if (subtypes == null || subtypes.size() == 0) {
+            return null;
+        }
+        if (TextUtils.isEmpty(locale)) {
+            locale = res.getConfiguration().locale.toString();
+        }
+        final String language = locale.substring(0, 2);
+        boolean partialMatchFound = false;
+        InputMethodSubtype applicableSubtype = null;
+        InputMethodSubtype firstMatchedModeSubtype = null;
+        final int N = subtypes.size();
+        for (int i = 0; i < N; ++i) {
+            InputMethodSubtype subtype = subtypes.get(i);
+            final String subtypeLocale = subtype.getLocale();
+            // An applicable subtype should match "mode". If mode is null, mode will be ignored,
+            // and all subtypes with all modes can be candidates.
+            if (mode == null || subtypes.get(i).getMode().equalsIgnoreCase(mode)) {
+                if (firstMatchedModeSubtype == null) {
+                    firstMatchedModeSubtype = subtype;
+                }
+                if (locale.equals(subtypeLocale)) {
+                    // Exact match (e.g. system locale is "en_US" and subtype locale is "en_US")
+                    applicableSubtype = subtype;
+                    break;
+                } else if (!partialMatchFound && subtypeLocale.startsWith(language)) {
+                    // Partial match (e.g. system locale is "en_US" and subtype locale is "en")
+                    applicableSubtype = subtype;
+                    partialMatchFound = true;
+                }
+            }
+        }
+
+        if (applicableSubtype == null && canIgnoreLocaleAsLastResort) {
+            return firstMatchedModeSubtype;
+        }
+
+        // The first subtype applicable to the system locale will be defined as the most applicable
+        // subtype.
+        if (DEBUG) {
+            if (applicableSubtype != null) {
+                Slog.d(TAG, "Applicable InputMethodSubtype was found: "
+                        + applicableSubtype.getMode() + "," + applicableSubtype.getLocale());
+            }
+        }
+        return applicableSubtype;
+    }
+
+    // If there are no selected shortcuts, tries finding the most applicable ones.
+    private Pair<InputMethodInfo, InputMethodSubtype>
+            findLastResortApplicableShortcutInputMethodAndSubtypeLocked(String mode) {
+        List<InputMethodInfo> imis = mSettings.getEnabledInputMethodListLocked();
+        InputMethodInfo mostApplicableIMI = null;
+        InputMethodSubtype mostApplicableSubtype = null;
+        boolean foundInSystemIME = false;
+
+        // Search applicable subtype for each InputMethodInfo
+        for (InputMethodInfo imi: imis) {
+            final String imiId = imi.getId();
+            if (foundInSystemIME && !imiId.equals(mCurMethodId)) {
+                continue;
+            }
+            InputMethodSubtype subtype = null;
+            final List<InputMethodSubtype> enabledSubtypes =
+                    getEnabledInputMethodSubtypeList(imi, true);
+            // 1. Search by the current subtype's locale from enabledSubtypes.
+            if (mCurrentSubtype != null) {
+                subtype = findLastResortApplicableSubtypeLocked(
+                        mRes, enabledSubtypes, mode, mCurrentSubtype.getLocale(), false);
+            }
+            // 2. Search by the system locale from enabledSubtypes.
+            // 3. Search the first enabled subtype matched with mode from enabledSubtypes.
+            if (subtype == null) {
+                subtype = findLastResortApplicableSubtypeLocked(
+                        mRes, enabledSubtypes, mode, null, true);
+            }
+            final ArrayList<InputMethodSubtype> overridingImplicitlyEnabledSubtypes =
+                    getOverridingImplicitlyEnabledSubtypes(imi, mode);
+            final ArrayList<InputMethodSubtype> subtypesForSearch =
+                    overridingImplicitlyEnabledSubtypes.isEmpty()
+                            ? getSubtypes(imi) : overridingImplicitlyEnabledSubtypes;
+            // 4. Search by the current subtype's locale from all subtypes.
+            if (subtype == null && mCurrentSubtype != null) {
+                subtype = findLastResortApplicableSubtypeLocked(
+                        mRes, subtypesForSearch, mode, mCurrentSubtype.getLocale(), false);
+            }
+            // 5. Search by the system locale from all subtypes.
+            // 6. Search the first enabled subtype matched with mode from all subtypes.
+            if (subtype == null) {
+                subtype = findLastResortApplicableSubtypeLocked(
+                        mRes, subtypesForSearch, mode, null, true);
+            }
+            if (subtype != null) {
+                if (imiId.equals(mCurMethodId)) {
+                    // The current input method is the most applicable IME.
+                    mostApplicableIMI = imi;
+                    mostApplicableSubtype = subtype;
+                    break;
+                } else if (!foundInSystemIME) {
+                    // The system input method is 2nd applicable IME.
+                    mostApplicableIMI = imi;
+                    mostApplicableSubtype = subtype;
+                    if ((imi.getServiceInfo().applicationInfo.flags
+                            & ApplicationInfo.FLAG_SYSTEM) != 0) {
+                        foundInSystemIME = true;
+                    }
+                }
+            }
+        }
+        if (DEBUG) {
+            if (mostApplicableIMI != null) {
+                Slog.w(TAG, "Most applicable shortcut input method was:"
+                        + mostApplicableIMI.getId());
+                if (mostApplicableSubtype != null) {
+                    Slog.w(TAG, "Most applicable shortcut input method subtype was:"
+                            + "," + mostApplicableSubtype.getMode() + ","
+                            + mostApplicableSubtype.getLocale());
+                }
+            }
+        }
+        if (mostApplicableIMI != null) {
+            return new Pair<InputMethodInfo, InputMethodSubtype> (mostApplicableIMI,
+                    mostApplicableSubtype);
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * @return Return the current subtype of this input method.
+     */
+    @Override
+    public InputMethodSubtype getCurrentInputMethodSubtype() {
+        if (mCurMethodId == null) {
+            return null;
+        }
+        boolean subtypeIsSelected = false;
+        try {
+            subtypeIsSelected = Settings.Secure.getInt(mContext.getContentResolver(),
+                    Settings.Secure.SELECTED_INPUT_METHOD_SUBTYPE) != NOT_A_SUBTYPE_ID;
+        } catch (SettingNotFoundException e) {
+        }
+        synchronized (mMethodMap) {
+            final InputMethodInfo imi = mMethodMap.get(mCurMethodId);
+            if (imi == null || imi.getSubtypeCount() == 0) {
+                return null;
+            }
+            if (!subtypeIsSelected || mCurrentSubtype == null
+                    || !isValidSubtypeId(imi, mCurrentSubtype.hashCode())) {
+                int subtypeId = getSelectedInputMethodSubtypeId(mCurMethodId);
+                if (subtypeId == NOT_A_SUBTYPE_ID) {
+                    // If there are no selected subtypes, the framework will try to find
+                    // the most applicable subtype from explicitly or implicitly enabled
+                    // subtypes.
+                    List<InputMethodSubtype> explicitlyOrImplicitlyEnabledSubtypes =
+                            getEnabledInputMethodSubtypeList(imi, true);
+                    // If there is only one explicitly or implicitly enabled subtype,
+                    // just returns it.
+                    if (explicitlyOrImplicitlyEnabledSubtypes.size() == 1) {
+                        mCurrentSubtype = explicitlyOrImplicitlyEnabledSubtypes.get(0);
+                    } else if (explicitlyOrImplicitlyEnabledSubtypes.size() > 1) {
+                        mCurrentSubtype = findLastResortApplicableSubtypeLocked(
+                                mRes, explicitlyOrImplicitlyEnabledSubtypes,
+                                SUBTYPE_MODE_KEYBOARD, null, true);
+                        if (mCurrentSubtype == null) {
+                            mCurrentSubtype = findLastResortApplicableSubtypeLocked(
+                                    mRes, explicitlyOrImplicitlyEnabledSubtypes, null, null,
+                                    true);
+                        }
+                    }
+                } else {
+                    mCurrentSubtype = getSubtypes(imi).get(subtypeId);
+                }
+            }
+            return mCurrentSubtype;
+        }
+    }
+
+    private void addShortcutInputMethodAndSubtypes(InputMethodInfo imi,
+            InputMethodSubtype subtype) {
+        if (mShortcutInputMethodsAndSubtypes.containsKey(imi)) {
+            mShortcutInputMethodsAndSubtypes.get(imi).add(subtype);
+        } else {
+            ArrayList<InputMethodSubtype> subtypes = new ArrayList<InputMethodSubtype>();
+            subtypes.add(subtype);
+            mShortcutInputMethodsAndSubtypes.put(imi, subtypes);
+        }
+    }
+
+    // TODO: We should change the return type from List to List<Parcelable>
+    @SuppressWarnings("rawtypes")
+    @Override
+    public List getShortcutInputMethodsAndSubtypes() {
+        synchronized (mMethodMap) {
+            ArrayList<Object> ret = new ArrayList<Object>();
+            if (mShortcutInputMethodsAndSubtypes.size() == 0) {
+                // If there are no selected shortcut subtypes, the framework will try to find
+                // the most applicable subtype from all subtypes whose mode is
+                // SUBTYPE_MODE_VOICE. This is an exceptional case, so we will hardcode the mode.
+                Pair<InputMethodInfo, InputMethodSubtype> info =
+                    findLastResortApplicableShortcutInputMethodAndSubtypeLocked(
+                            SUBTYPE_MODE_VOICE);
+                if (info != null) {
+                    ret.add(info.first);
+                    ret.add(info.second);
+                }
+                return ret;
+            }
+            for (InputMethodInfo imi: mShortcutInputMethodsAndSubtypes.keySet()) {
+                ret.add(imi);
+                for (InputMethodSubtype subtype: mShortcutInputMethodsAndSubtypes.get(imi)) {
+                    ret.add(subtype);
+                }
+            }
+            return ret;
+        }
+    }
+
+    @Override
+    public boolean setCurrentInputMethodSubtype(InputMethodSubtype subtype) {
+        synchronized (mMethodMap) {
+            if (subtype != null && mCurMethodId != null) {
+                InputMethodInfo imi = mMethodMap.get(mCurMethodId);
+                int subtypeId = getSubtypeIdFromHashCode(imi, subtype.hashCode());
+                if (subtypeId != NOT_A_SUBTYPE_ID) {
+                    setInputMethodLocked(mCurMethodId, subtypeId);
+                    return true;
+                }
+            }
+            return false;
+        }
+    }
+
+    private static class InputMethodAndSubtypeListManager {
+        private final Context mContext;
+        private final PackageManager mPm;
+        private final InputMethodManagerService mImms;
+        private final String mSystemLocaleStr;
+        public InputMethodAndSubtypeListManager(Context context, InputMethodManagerService imms) {
+            mContext = context;
+            mPm = context.getPackageManager();
+            mImms = imms;
+            final Locale locale = context.getResources().getConfiguration().locale;
+            mSystemLocaleStr = locale != null ? locale.toString() : "";
+        }
+
+        private final TreeMap<InputMethodInfo, List<InputMethodSubtype>> mSortedImmis =
+                new TreeMap<InputMethodInfo, List<InputMethodSubtype>>(
+                        new Comparator<InputMethodInfo>() {
+                            @Override
+                            public int compare(InputMethodInfo imi1, InputMethodInfo imi2) {
+                                if (imi2 == null) return 0;
+                                if (imi1 == null) return 1;
+                                if (mPm == null) {
+                                    return imi1.getId().compareTo(imi2.getId());
+                                }
+                                CharSequence imiId1 = imi1.loadLabel(mPm) + "/" + imi1.getId();
+                                CharSequence imiId2 = imi2.loadLabel(mPm) + "/" + imi2.getId();
+                                return imiId1.toString().compareTo(imiId2.toString());
+                            }
+                        });
+
+        public ImeSubtypeListItem getNextInputMethod(
+                boolean onlyCurrentIme, InputMethodInfo imi, InputMethodSubtype subtype) {
+            if (imi == null) {
+                return null;
+            }
+            final List<ImeSubtypeListItem> imList = getSortedInputMethodAndSubtypeList();
+            if (imList.size() <= 1) {
+                return null;
+            }
+            final int N = imList.size();
+            final int currentSubtypeId = subtype != null
+                    ? getSubtypeIdFromHashCode(imi, subtype.hashCode())
+                    : NOT_A_SUBTYPE_ID;
+            for (int i = 0; i < N; ++i) {
+                final ImeSubtypeListItem isli = imList.get(i);
+                if (isli.mImi.equals(imi) && isli.mSubtypeId == currentSubtypeId) {
+                    if (!onlyCurrentIme) {
+                        return imList.get((i + 1) % N);
+                    }
+                    for (int j = 0; j < N - 1; ++j) {
+                        final ImeSubtypeListItem candidate = imList.get((i + j + 1) % N);
+                        if (candidate.mImi.equals(imi)) {
+                            return candidate;
+                        }
+                    }
+                    return null;
+                }
+            }
+            return null;
+        }
+
+        public List<ImeSubtypeListItem> getSortedInputMethodAndSubtypeList() {
+            return getSortedInputMethodAndSubtypeList(true, false, false);
+        }
+
+        public List<ImeSubtypeListItem> getSortedInputMethodAndSubtypeList(boolean showSubtypes,
+                boolean inputShown, boolean isScreenLocked) {
+            final ArrayList<ImeSubtypeListItem> imList = new ArrayList<ImeSubtypeListItem>();
+            final HashMap<InputMethodInfo, List<InputMethodSubtype>> immis =
+                    mImms.getExplicitlyOrImplicitlyEnabledInputMethodsAndSubtypeListLocked();
+            if (immis == null || immis.size() == 0) {
+                return Collections.emptyList();
+            }
+            mSortedImmis.clear();
+            mSortedImmis.putAll(immis);
+            for (InputMethodInfo imi : mSortedImmis.keySet()) {
+                if (imi == null) continue;
+                List<InputMethodSubtype> explicitlyOrImplicitlyEnabledSubtypeList = immis.get(imi);
+                HashSet<String> enabledSubtypeSet = new HashSet<String>();
+                for (InputMethodSubtype subtype: explicitlyOrImplicitlyEnabledSubtypeList) {
+                    enabledSubtypeSet.add(String.valueOf(subtype.hashCode()));
+                }
+                ArrayList<InputMethodSubtype> subtypes = getSubtypes(imi);
+                final CharSequence imeLabel = imi.loadLabel(mPm);
+                if (showSubtypes && enabledSubtypeSet.size() > 0) {
+                    final int subtypeCount = imi.getSubtypeCount();
+                    if (DEBUG) {
+                        Slog.v(TAG, "Add subtypes: " + subtypeCount + ", " + imi.getId());
+                    }
+                    for (int j = 0; j < subtypeCount; ++j) {
+                        final InputMethodSubtype subtype = imi.getSubtypeAt(j);
+                        final String subtypeHashCode = String.valueOf(subtype.hashCode());
+                        // We show all enabled IMEs and subtypes when an IME is shown.
+                        if (enabledSubtypeSet.contains(subtypeHashCode)
+                                && ((inputShown && !isScreenLocked) || !subtype.isAuxiliary())) {
+                            final CharSequence subtypeLabel =
+                                    subtype.overridesImplicitlyEnabledSubtype() ? null
+                                            : subtype.getDisplayName(mContext, imi.getPackageName(),
+                                                    imi.getServiceInfo().applicationInfo);
+                            imList.add(new ImeSubtypeListItem(imeLabel, subtypeLabel, imi, j,
+                                    subtype.getLocale(), mSystemLocaleStr));
+
+                            // Removing this subtype from enabledSubtypeSet because we no longer
+                            // need to add an entry of this subtype to imList to avoid duplicated
+                            // entries.
+                            enabledSubtypeSet.remove(subtypeHashCode);
+                        }
+                    }
+                } else {
+                    imList.add(new ImeSubtypeListItem(imeLabel, null, imi, NOT_A_SUBTYPE_ID,
+                            null, mSystemLocaleStr));
+                }
+            }
+            Collections.sort(imList);
+            return imList;
+        }
+    }
+
+    /**
+     * Utility class for putting and getting settings for InputMethod
+     * TODO: Move all putters and getters of settings to this class.
+     */
+    private static class InputMethodSettings {
+        // The string for enabled input method is saved as follows:
+        // example: ("ime0;subtype0;subtype1;subtype2:ime1:ime2;subtype0")
+        private static final char INPUT_METHOD_SEPARATER = ':';
+        private static final char INPUT_METHOD_SUBTYPE_SEPARATER = ';';
+        private final TextUtils.SimpleStringSplitter mInputMethodSplitter =
+                new TextUtils.SimpleStringSplitter(INPUT_METHOD_SEPARATER);
+
+        private final TextUtils.SimpleStringSplitter mSubtypeSplitter =
+                new TextUtils.SimpleStringSplitter(INPUT_METHOD_SUBTYPE_SEPARATER);
+
+        private final Resources mRes;
+        private final ContentResolver mResolver;
+        private final HashMap<String, InputMethodInfo> mMethodMap;
+        private final ArrayList<InputMethodInfo> mMethodList;
+
+        private String mEnabledInputMethodsStrCache;
+
+        private static void buildEnabledInputMethodsSettingString(
+                StringBuilder builder, Pair<String, ArrayList<String>> pair) {
+            String id = pair.first;
+            ArrayList<String> subtypes = pair.second;
+            builder.append(id);
+            // Inputmethod and subtypes are saved in the settings as follows:
+            // ime0;subtype0;subtype1:ime1;subtype0:ime2:ime3;subtype0;subtype1
+            for (String subtypeId: subtypes) {
+                builder.append(INPUT_METHOD_SUBTYPE_SEPARATER).append(subtypeId);
+            }
+        }
+
+        public InputMethodSettings(
+                Resources res, ContentResolver resolver,
+                HashMap<String, InputMethodInfo> methodMap, ArrayList<InputMethodInfo> methodList) {
+            mRes = res;
+            mResolver = resolver;
+            mMethodMap = methodMap;
+            mMethodList = methodList;
+        }
+
+        public List<InputMethodInfo> getEnabledInputMethodListLocked() {
+            return createEnabledInputMethodListLocked(
+                    getEnabledInputMethodsAndSubtypeListLocked());
+        }
+
+        public List<Pair<InputMethodInfo, ArrayList<String>>>
+                getEnabledInputMethodAndSubtypeHashCodeListLocked() {
+            return createEnabledInputMethodAndSubtypeHashCodeListLocked(
+                    getEnabledInputMethodsAndSubtypeListLocked());
+        }
+
+        public List<InputMethodSubtype> getEnabledInputMethodSubtypeListLocked(
+                InputMethodInfo imi) {
+            List<Pair<String, ArrayList<String>>> imsList =
+                    getEnabledInputMethodsAndSubtypeListLocked();
+            ArrayList<InputMethodSubtype> enabledSubtypes =
+                    new ArrayList<InputMethodSubtype>();
+            if (imi != null) {
+                for (Pair<String, ArrayList<String>> imsPair : imsList) {
+                    InputMethodInfo info = mMethodMap.get(imsPair.first);
+                    if (info != null && info.getId().equals(imi.getId())) {
+                        final int subtypeCount = info.getSubtypeCount();
+                        for (int i = 0; i < subtypeCount; ++i) {
+                            InputMethodSubtype ims = info.getSubtypeAt(i);
+                            for (String s: imsPair.second) {
+                                if (String.valueOf(ims.hashCode()).equals(s)) {
+                                    enabledSubtypes.add(ims);
+                                }
+                            }
+                        }
+                        break;
+                    }
+                }
+            }
+            return enabledSubtypes;
+        }
+
+        // At the initial boot, the settings for input methods are not set,
+        // so we need to enable IME in that case.
+        public void enableAllIMEsIfThereIsNoEnabledIME() {
+            if (TextUtils.isEmpty(getEnabledInputMethodsStr())) {
+                StringBuilder sb = new StringBuilder();
+                final int N = mMethodList.size();
+                for (int i = 0; i < N; i++) {
+                    InputMethodInfo imi = mMethodList.get(i);
+                    Slog.i(TAG, "Adding: " + imi.getId());
+                    if (i > 0) sb.append(':');
+                    sb.append(imi.getId());
+                }
+                putEnabledInputMethodsStr(sb.toString());
+            }
+        }
+
+        private List<Pair<String, ArrayList<String>>> getEnabledInputMethodsAndSubtypeListLocked() {
+            ArrayList<Pair<String, ArrayList<String>>> imsList
+                    = new ArrayList<Pair<String, ArrayList<String>>>();
+            final String enabledInputMethodsStr = getEnabledInputMethodsStr();
+            if (TextUtils.isEmpty(enabledInputMethodsStr)) {
+                return imsList;
+            }
+            mInputMethodSplitter.setString(enabledInputMethodsStr);
+            while (mInputMethodSplitter.hasNext()) {
+                String nextImsStr = mInputMethodSplitter.next();
+                mSubtypeSplitter.setString(nextImsStr);
+                if (mSubtypeSplitter.hasNext()) {
+                    ArrayList<String> subtypeHashes = new ArrayList<String>();
+                    // The first element is ime id.
+                    String imeId = mSubtypeSplitter.next();
+                    while (mSubtypeSplitter.hasNext()) {
+                        subtypeHashes.add(mSubtypeSplitter.next());
+                    }
+                    imsList.add(new Pair<String, ArrayList<String>>(imeId, subtypeHashes));
+                }
+            }
+            return imsList;
+        }
+
+        public void appendAndPutEnabledInputMethodLocked(String id, boolean reloadInputMethodStr) {
+            if (reloadInputMethodStr) {
+                getEnabledInputMethodsStr();
+            }
+            if (TextUtils.isEmpty(mEnabledInputMethodsStrCache)) {
+                // Add in the newly enabled input method.
+                putEnabledInputMethodsStr(id);
+            } else {
+                putEnabledInputMethodsStr(
+                        mEnabledInputMethodsStrCache + INPUT_METHOD_SEPARATER + id);
+            }
+        }
+
+        /**
+         * Build and put a string of EnabledInputMethods with removing specified Id.
+         * @return the specified id was removed or not.
+         */
+        public boolean buildAndPutEnabledInputMethodsStrRemovingIdLocked(
+                StringBuilder builder, List<Pair<String, ArrayList<String>>> imsList, String id) {
+            boolean isRemoved = false;
+            boolean needsAppendSeparator = false;
+            for (Pair<String, ArrayList<String>> ims: imsList) {
+                String curId = ims.first;
+                if (curId.equals(id)) {
+                    // We are disabling this input method, and it is
+                    // currently enabled.  Skip it to remove from the
+                    // new list.
+                    isRemoved = true;
+                } else {
+                    if (needsAppendSeparator) {
+                        builder.append(INPUT_METHOD_SEPARATER);
+                    } else {
+                        needsAppendSeparator = true;
+                    }
+                    buildEnabledInputMethodsSettingString(builder, ims);
+                }
+            }
+            if (isRemoved) {
+                // Update the setting with the new list of input methods.
+                putEnabledInputMethodsStr(builder.toString());
+            }
+            return isRemoved;
+        }
+
+        private List<InputMethodInfo> createEnabledInputMethodListLocked(
+                List<Pair<String, ArrayList<String>>> imsList) {
+            final ArrayList<InputMethodInfo> res = new ArrayList<InputMethodInfo>();
+            for (Pair<String, ArrayList<String>> ims: imsList) {
+                InputMethodInfo info = mMethodMap.get(ims.first);
+                if (info != null) {
+                    res.add(info);
+                }
+            }
+            return res;
+        }
+
+        private List<Pair<InputMethodInfo, ArrayList<String>>>
+                createEnabledInputMethodAndSubtypeHashCodeListLocked(
+                        List<Pair<String, ArrayList<String>>> imsList) {
+            final ArrayList<Pair<InputMethodInfo, ArrayList<String>>> res
+                    = new ArrayList<Pair<InputMethodInfo, ArrayList<String>>>();
+            for (Pair<String, ArrayList<String>> ims : imsList) {
+                InputMethodInfo info = mMethodMap.get(ims.first);
+                if (info != null) {
+                    res.add(new Pair<InputMethodInfo, ArrayList<String>>(info, ims.second));
+                }
+            }
+            return res;
+        }
+
+        private void putEnabledInputMethodsStr(String str) {
+            Settings.Secure.putString(mResolver, Settings.Secure.ENABLED_INPUT_METHODS, str);
+            mEnabledInputMethodsStrCache = str;
+        }
+
+        private String getEnabledInputMethodsStr() {
+            mEnabledInputMethodsStrCache = Settings.Secure.getString(
+                    mResolver, Settings.Secure.ENABLED_INPUT_METHODS);
+            if (DEBUG) {
+                Slog.d(TAG, "getEnabledInputMethodsStr: " + mEnabledInputMethodsStrCache);
+            }
+            return mEnabledInputMethodsStrCache;
+        }
+
+        private void saveSubtypeHistory(
+                List<Pair<String, String>> savedImes, String newImeId, String newSubtypeId) {
+            StringBuilder builder = new StringBuilder();
+            boolean isImeAdded = false;
+            if (!TextUtils.isEmpty(newImeId) && !TextUtils.isEmpty(newSubtypeId)) {
+                builder.append(newImeId).append(INPUT_METHOD_SUBTYPE_SEPARATER).append(
+                        newSubtypeId);
+                isImeAdded = true;
+            }
+            for (Pair<String, String> ime: savedImes) {
+                String imeId = ime.first;
+                String subtypeId = ime.second;
+                if (TextUtils.isEmpty(subtypeId)) {
+                    subtypeId = NOT_A_SUBTYPE_ID_STR;
+                }
+                if (isImeAdded) {
+                    builder.append(INPUT_METHOD_SEPARATER);
+                } else {
+                    isImeAdded = true;
+                }
+                builder.append(imeId).append(INPUT_METHOD_SUBTYPE_SEPARATER).append(
+                        subtypeId);
+            }
+            // Remove the last INPUT_METHOD_SEPARATER
+            putSubtypeHistoryStr(builder.toString());
+        }
+
+        public void addSubtypeToHistory(String imeId, String subtypeId) {
+            List<Pair<String, String>> subtypeHistory = loadInputMethodAndSubtypeHistoryLocked();
+            for (Pair<String, String> ime: subtypeHistory) {
+                if (ime.first.equals(imeId)) {
+                    if (DEBUG) {
+                        Slog.v(TAG, "Subtype found in the history: " + imeId + ", "
+                                + ime.second);
+                    }
+                    // We should break here
+                    subtypeHistory.remove(ime);
+                    break;
+                }
+            }
+            if (DEBUG) {
+                Slog.v(TAG, "Add subtype to the history: " + imeId + ", " + subtypeId);
+            }
+            saveSubtypeHistory(subtypeHistory, imeId, subtypeId);
+        }
+
+        private void putSubtypeHistoryStr(String str) {
+            if (DEBUG) {
+                Slog.d(TAG, "putSubtypeHistoryStr: " + str);
+            }
+            Settings.Secure.putString(
+                    mResolver, Settings.Secure.INPUT_METHODS_SUBTYPE_HISTORY, str);
+        }
+
+        public Pair<String, String> getLastInputMethodAndSubtypeLocked() {
+            // Gets the first one from the history
+            return getLastSubtypeForInputMethodLockedInternal(null);
+        }
+
+        public String getLastSubtypeForInputMethodLocked(String imeId) {
+            Pair<String, String> ime = getLastSubtypeForInputMethodLockedInternal(imeId);
+            if (ime != null) {
+                return ime.second;
+            } else {
+                return null;
+            }
+        }
+
+        private Pair<String, String> getLastSubtypeForInputMethodLockedInternal(String imeId) {
+            List<Pair<String, ArrayList<String>>> enabledImes =
+                    getEnabledInputMethodsAndSubtypeListLocked();
+            List<Pair<String, String>> subtypeHistory = loadInputMethodAndSubtypeHistoryLocked();
+            for (Pair<String, String> imeAndSubtype : subtypeHistory) {
+                final String imeInTheHistory = imeAndSubtype.first;
+                // If imeId is empty, returns the first IME and subtype in the history
+                if (TextUtils.isEmpty(imeId) || imeInTheHistory.equals(imeId)) {
+                    final String subtypeInTheHistory = imeAndSubtype.second;
+                    final String subtypeHashCode =
+                            getEnabledSubtypeHashCodeForInputMethodAndSubtypeLocked(
+                                    enabledImes, imeInTheHistory, subtypeInTheHistory);
+                    if (!TextUtils.isEmpty(subtypeHashCode)) {
+                        if (DEBUG) {
+                            Slog.d(TAG, "Enabled subtype found in the history: " + subtypeHashCode);
+                        }
+                        return new Pair<String, String>(imeInTheHistory, subtypeHashCode);
+                    }
+                }
+            }
+            if (DEBUG) {
+                Slog.d(TAG, "No enabled IME found in the history");
+            }
+            return null;
+        }
+
+        private String getEnabledSubtypeHashCodeForInputMethodAndSubtypeLocked(List<Pair<String,
+                ArrayList<String>>> enabledImes, String imeId, String subtypeHashCode) {
+            for (Pair<String, ArrayList<String>> enabledIme: enabledImes) {
+                if (enabledIme.first.equals(imeId)) {
+                    final ArrayList<String> explicitlyEnabledSubtypes = enabledIme.second;
+                    final InputMethodInfo imi = mMethodMap.get(imeId);
+                    if (explicitlyEnabledSubtypes.size() == 0) {
+                        // If there are no explicitly enabled subtypes, applicable subtypes are
+                        // enabled implicitly.
+                        // If IME is enabled and no subtypes are enabled, applicable subtypes
+                        // are enabled implicitly, so needs to treat them to be enabled.
+                        if (imi != null && imi.getSubtypeCount() > 0) {
+                            List<InputMethodSubtype> implicitlySelectedSubtypes =
+                                    getImplicitlyApplicableSubtypesLocked(mRes, imi);
+                            if (implicitlySelectedSubtypes != null) {
+                                final int N = implicitlySelectedSubtypes.size();
+                                for (int i = 0; i < N; ++i) {
+                                    final InputMethodSubtype st = implicitlySelectedSubtypes.get(i);
+                                    if (String.valueOf(st.hashCode()).equals(subtypeHashCode)) {
+                                        return subtypeHashCode;
+                                    }
+                                }
+                            }
+                        }
+                    } else {
+                        for (String s: explicitlyEnabledSubtypes) {
+                            if (s.equals(subtypeHashCode)) {
+                                // If both imeId and subtypeId are enabled, return subtypeId.
+                                try {
+                                    final int hashCode = Integer.valueOf(subtypeHashCode);
+                                    // Check whether the subtype id is valid or not
+                                    if (isValidSubtypeId(imi, hashCode)) {
+                                        return s;
+                                    } else {
+                                        return NOT_A_SUBTYPE_ID_STR;
+                                    }
+                                } catch (NumberFormatException e) {
+                                    return NOT_A_SUBTYPE_ID_STR;
+                                }
+                            }
+                        }
+                    }
+                    // If imeId was enabled but subtypeId was disabled.
+                    return NOT_A_SUBTYPE_ID_STR;
+                }
+            }
+            // If both imeId and subtypeId are disabled, return null
+            return null;
+        }
+
+        private List<Pair<String, String>> loadInputMethodAndSubtypeHistoryLocked() {
+            ArrayList<Pair<String, String>> imsList = new ArrayList<Pair<String, String>>();
+            final String subtypeHistoryStr = getSubtypeHistoryStr();
+            if (TextUtils.isEmpty(subtypeHistoryStr)) {
+                return imsList;
+            }
+            mInputMethodSplitter.setString(subtypeHistoryStr);
+            while (mInputMethodSplitter.hasNext()) {
+                String nextImsStr = mInputMethodSplitter.next();
+                mSubtypeSplitter.setString(nextImsStr);
+                if (mSubtypeSplitter.hasNext()) {
+                    String subtypeId = NOT_A_SUBTYPE_ID_STR;
+                    // The first element is ime id.
+                    String imeId = mSubtypeSplitter.next();
+                    while (mSubtypeSplitter.hasNext()) {
+                        subtypeId = mSubtypeSplitter.next();
+                        break;
+                    }
+                    imsList.add(new Pair<String, String>(imeId, subtypeId));
+                }
+            }
+            return imsList;
+        }
+
+        private String getSubtypeHistoryStr() {
+            if (DEBUG) {
+                Slog.d(TAG, "getSubtypeHistoryStr: " + Settings.Secure.getString(
+                        mResolver, Settings.Secure.INPUT_METHODS_SUBTYPE_HISTORY));
+            }
+            return Settings.Secure.getString(
+                    mResolver, Settings.Secure.INPUT_METHODS_SUBTYPE_HISTORY);
+        }
+
+        public void putSelectedInputMethod(String imeId) {
+            Settings.Secure.putString(mResolver, Settings.Secure.DEFAULT_INPUT_METHOD, imeId);
+        }
+
+        public void putSelectedSubtype(int subtypeId) {
+            Settings.Secure.putInt(
+                    mResolver, Settings.Secure.SELECTED_INPUT_METHOD_SUBTYPE, subtypeId);
+        }
+    }
+
+    private static class InputMethodFileManager {
+        private static final String SYSTEM_PATH = "system";
+        private static final String INPUT_METHOD_PATH = "inputmethod";
+        private static final String ADDITIONAL_SUBTYPES_FILE_NAME = "subtypes.xml";
+        private static final String NODE_SUBTYPES = "subtypes";
+        private static final String NODE_SUBTYPE = "subtype";
+        private static final String NODE_IMI = "imi";
+        private static final String ATTR_ID = "id";
+        private static final String ATTR_LABEL = "label";
+        private static final String ATTR_ICON = "icon";
+        private static final String ATTR_IME_SUBTYPE_LOCALE = "imeSubtypeLocale";
+        private static final String ATTR_IME_SUBTYPE_MODE = "imeSubtypeMode";
+        private static final String ATTR_IME_SUBTYPE_EXTRA_VALUE = "imeSubtypeExtraValue";
+        private static final String ATTR_IS_AUXILIARY = "isAuxiliary";
+        private final AtomicFile mAdditionalInputMethodSubtypeFile;
+        private final HashMap<String, InputMethodInfo> mMethodMap;
+        private final HashMap<String, List<InputMethodSubtype>> mSubtypesMap =
+                new HashMap<String, List<InputMethodSubtype>>();
+        public InputMethodFileManager(HashMap<String, InputMethodInfo> methodMap) {
+            if (methodMap == null) {
+                throw new NullPointerException("methodMap is null");
+            }
+            mMethodMap = methodMap;
+            final File systemDir = new File(Environment.getDataDirectory(), SYSTEM_PATH);
+            final File inputMethodDir = new File(systemDir, INPUT_METHOD_PATH);
+            if (!inputMethodDir.mkdirs()) {
+                Slog.w(TAG, "Couldn't create dir.: " + inputMethodDir.getAbsolutePath());
+            }
+            final File subtypeFile = new File(inputMethodDir, ADDITIONAL_SUBTYPES_FILE_NAME);
+            mAdditionalInputMethodSubtypeFile = new AtomicFile(subtypeFile);
+            if (!subtypeFile.exists()) {
+                // If "subtypes.xml" doesn't exist, create a blank file.
+                writeAdditionalInputMethodSubtypes(mSubtypesMap, mAdditionalInputMethodSubtypeFile,
+                        methodMap);
+            } else {
+                readAdditionalInputMethodSubtypes(mSubtypesMap, mAdditionalInputMethodSubtypeFile);
+            }
+        }
+
+        private void deleteAllInputMethodSubtypes(String imiId) {
+            synchronized (mMethodMap) {
+                mSubtypesMap.remove(imiId);
+                writeAdditionalInputMethodSubtypes(mSubtypesMap, mAdditionalInputMethodSubtypeFile,
+                        mMethodMap);
+            }
+        }
+
+        public void addInputMethodSubtypes(
+                InputMethodInfo imi, InputMethodSubtype[] additionalSubtypes) {
+            synchronized (mMethodMap) {
+                final ArrayList<InputMethodSubtype> subtypes = new ArrayList<InputMethodSubtype>();
+                final int N = additionalSubtypes.length;
+                for (int i = 0; i < N; ++i) {
+                    final InputMethodSubtype subtype = additionalSubtypes[i];
+                    if (!subtypes.contains(subtype)) {
+                        subtypes.add(subtype);
+                    }
+                }
+                mSubtypesMap.put(imi.getId(), subtypes);
+                writeAdditionalInputMethodSubtypes(mSubtypesMap, mAdditionalInputMethodSubtypeFile,
+                        mMethodMap);
+            }
+        }
+
+        public HashMap<String, List<InputMethodSubtype>> getAllAdditionalInputMethodSubtypes() {
+            synchronized (mMethodMap) {
+                return mSubtypesMap;
+            }
+        }
+
+        private static void writeAdditionalInputMethodSubtypes(
+                HashMap<String, List<InputMethodSubtype>> allSubtypes, AtomicFile subtypesFile,
+                HashMap<String, InputMethodInfo> methodMap) {
+            // Safety net for the case that this function is called before methodMap is set.
+            final boolean isSetMethodMap = methodMap != null && methodMap.size() > 0;
+            FileOutputStream fos = null;
+            try {
+                fos = subtypesFile.startWrite();
+                final XmlSerializer out = new FastXmlSerializer();
+                out.setOutput(fos, "utf-8");
+                out.startDocument(null, true);
+                out.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", true);
+                out.startTag(null, NODE_SUBTYPES);
+                for (String imiId : allSubtypes.keySet()) {
+                    if (isSetMethodMap && !methodMap.containsKey(imiId)) {
+                        Slog.w(TAG, "IME uninstalled or not valid.: " + imiId);
+                        continue;
+                    }
+                    out.startTag(null, NODE_IMI);
+                    out.attribute(null, ATTR_ID, imiId);
+                    final List<InputMethodSubtype> subtypesList = allSubtypes.get(imiId);
+                    final int N = subtypesList.size();
+                    for (int i = 0; i < N; ++i) {
+                        final InputMethodSubtype subtype = subtypesList.get(i);
+                        out.startTag(null, NODE_SUBTYPE);
+                        out.attribute(null, ATTR_ICON, String.valueOf(subtype.getIconResId()));
+                        out.attribute(null, ATTR_LABEL, String.valueOf(subtype.getNameResId()));
+                        out.attribute(null, ATTR_IME_SUBTYPE_LOCALE, subtype.getLocale());
+                        out.attribute(null, ATTR_IME_SUBTYPE_MODE, subtype.getMode());
+                        out.attribute(null, ATTR_IME_SUBTYPE_EXTRA_VALUE, subtype.getExtraValue());
+                        out.attribute(null, ATTR_IS_AUXILIARY,
+                                String.valueOf(subtype.isAuxiliary() ? 1 : 0));
+                        out.endTag(null, NODE_SUBTYPE);
+                    }
+                    out.endTag(null, NODE_IMI);
+                }
+                out.endTag(null, NODE_SUBTYPES);
+                out.endDocument();
+                subtypesFile.finishWrite(fos);
+            } catch (java.io.IOException e) {
+                Slog.w(TAG, "Error writing subtypes", e);
+                if (fos != null) {
+                    subtypesFile.failWrite(fos);
+                }
+            }
+        }
+
+        private static void readAdditionalInputMethodSubtypes(
+                HashMap<String, List<InputMethodSubtype>> allSubtypes, AtomicFile subtypesFile) {
+            if (allSubtypes == null || subtypesFile == null) return;
+            allSubtypes.clear();
+            FileInputStream fis = null;
+            try {
+                fis = subtypesFile.openRead();
+                final XmlPullParser parser = Xml.newPullParser();
+                parser.setInput(fis, null);
+                int type = parser.getEventType();
+                // Skip parsing until START_TAG
+                while ((type = parser.next()) != XmlPullParser.START_TAG
+                        && type != XmlPullParser.END_DOCUMENT) {}
+                String firstNodeName = parser.getName();
+                if (!NODE_SUBTYPES.equals(firstNodeName)) {
+                    throw new XmlPullParserException("Xml doesn't start with subtypes");
+                }
+                final int depth =parser.getDepth();
+                String currentImiId = null;
+                ArrayList<InputMethodSubtype> tempSubtypesArray = null;
+                while (((type = parser.next()) != XmlPullParser.END_TAG
+                        || parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {
+                    if (type != XmlPullParser.START_TAG)
+                        continue;
+                    final String nodeName = parser.getName();
+                    if (NODE_IMI.equals(nodeName)) {
+                        currentImiId = parser.getAttributeValue(null, ATTR_ID);
+                        if (TextUtils.isEmpty(currentImiId)) {
+                            Slog.w(TAG, "Invalid imi id found in subtypes.xml");
+                            continue;
+                        }
+                        tempSubtypesArray = new ArrayList<InputMethodSubtype>();
+                        allSubtypes.put(currentImiId, tempSubtypesArray);
+                    } else if (NODE_SUBTYPE.equals(nodeName)) {
+                        if (TextUtils.isEmpty(currentImiId) || tempSubtypesArray == null) {
+                            Slog.w(TAG, "IME uninstalled or not valid.: " + currentImiId);
+                            continue;
+                        }
+                        final int icon = Integer.valueOf(
+                                parser.getAttributeValue(null, ATTR_ICON));
+                        final int label = Integer.valueOf(
+                                parser.getAttributeValue(null, ATTR_LABEL));
+                        final String imeSubtypeLocale =
+                                parser.getAttributeValue(null, ATTR_IME_SUBTYPE_LOCALE);
+                        final String imeSubtypeMode =
+                                parser.getAttributeValue(null, ATTR_IME_SUBTYPE_MODE);
+                        final String imeSubtypeExtraValue =
+                                parser.getAttributeValue(null, ATTR_IME_SUBTYPE_EXTRA_VALUE);
+                        final boolean isAuxiliary = "1".equals(String.valueOf(
+                                parser.getAttributeValue(null, ATTR_IS_AUXILIARY)));
+                        final InputMethodSubtype subtype =
+                                new InputMethodSubtype(label, icon, imeSubtypeLocale,
+                                        imeSubtypeMode, imeSubtypeExtraValue, isAuxiliary);
+                        tempSubtypesArray.add(subtype);
+                    }
+                }
+            } catch (XmlPullParserException e) {
+                Slog.w(TAG, "Error reading subtypes: " + e);
+                return;
+            } catch (java.io.IOException e) {
+                Slog.w(TAG, "Error reading subtypes: " + e);
+                return;
+            } catch (NumberFormatException e) {
+                Slog.w(TAG, "Error reading subtypes: " + e);
+                return;
+            } finally {
+                if (fis != null) {
+                    try {
+                        fis.close();
+                    } catch (java.io.IOException e1) {
+                        Slog.w(TAG, "Failed to close.");
+                    }
+                }
+            }
+        }
+    }
+
+    // ----------------------------------------------------------------------
+
+    @Override
+    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP)
+                != PackageManager.PERMISSION_GRANTED) {
+
+            pw.println("Permission Denial: can't dump InputMethodManager from from pid="
+                    + Binder.getCallingPid()
+                    + ", uid=" + Binder.getCallingUid());
+            return;
+        }
+
+        IInputMethod method;
+        ClientState client;
+
+        final Printer p = new PrintWriterPrinter(pw);
+
+        synchronized (mMethodMap) {
+            p.println("Current Input Method Manager state:");
+            int N = mMethodList.size();
+            p.println("  Input Methods:");
+            for (int i=0; i<N; i++) {
+                InputMethodInfo info = mMethodList.get(i);
+                p.println("  InputMethod #" + i + ":");
+                info.dump(p, "    ");
+            }
+            p.println("  Clients:");
+            for (ClientState ci : mClients.values()) {
+                p.println("  Client " + ci + ":");
+                p.println("    client=" + ci.client);
+                p.println("    inputContext=" + ci.inputContext);
+                p.println("    sessionRequested=" + ci.sessionRequested);
+                p.println("    curSession=" + ci.curSession);
+            }
+            p.println("  mCurMethodId=" + mCurMethodId);
+            client = mCurClient;
+            p.println("  mCurClient=" + client + " mCurSeq=" + mCurSeq);
+            p.println("  mCurFocusedWindow=" + mCurFocusedWindow);
+            p.println("  mCurId=" + mCurId + " mHaveConnect=" + mHaveConnection
+                    + " mBoundToMethod=" + mBoundToMethod);
+            p.println("  mCurToken=" + mCurToken);
+            p.println("  mCurIntent=" + mCurIntent);
+            method = mCurMethod;
+            p.println("  mCurMethod=" + mCurMethod);
+            p.println("  mEnabledSession=" + mEnabledSession);
+            p.println("  mShowRequested=" + mShowRequested
+                    + " mShowExplicitlyRequested=" + mShowExplicitlyRequested
+                    + " mShowForced=" + mShowForced
+                    + " mInputShown=" + mInputShown);
+            p.println("  mSystemReady=" + mSystemReady + " mScreenOn=" + mScreenOn);
+        }
+
+        p.println(" ");
+        if (client != null) {
+            pw.flush();
+            try {
+                client.client.asBinder().dump(fd, args);
+            } catch (RemoteException e) {
+                p.println("Input method client dead: " + e);
+            }
+        } else {
+            p.println("No input method client.");
+        }
+
+        p.println(" ");
+        if (method != null) {
+            pw.flush();
+            try {
+                method.asBinder().dump(fd, args);
+            } catch (RemoteException e) {
+                p.println("Input method service dead: " + e);
+            }
+        } else {
+            p.println("No input method service.");
+        }
+    }
+}
diff --git a/src/frameworks/base/services/java/com/android/server/StatusBarManagerService.java b/src/frameworks/base/services/java/com/android/server/StatusBarManagerService.java
new file mode 100644
index 0000000..78c0c12
--- /dev/null
+++ b/src/frameworks/base/services/java/com/android/server/StatusBarManagerService.java
@@ -0,0 +1,616 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server;
+
+import android.app.StatusBarManager;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.res.Resources;
+import android.os.Binder;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Slog;
+import android.view.View;
+
+import com.android.internal.statusbar.IStatusBar;
+import com.android.internal.statusbar.IStatusBarService;
+import com.android.internal.statusbar.StatusBarIcon;
+import com.android.internal.statusbar.StatusBarIconList;
+import com.android.internal.statusbar.StatusBarNotification;
+import com.android.server.wm.WindowManagerService;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+
+/**
+ * A note on locking:  We rely on the fact that calls onto mBar are oneway or
+ * if they are local, that they just enqueue messages to not deadlock.
+ */
+public class StatusBarManagerService extends IStatusBarService.Stub
+    implements WindowManagerService.OnHardKeyboardStatusChangeListener
+{
+    static final String TAG = "StatusBarManagerService";
+    static final boolean SPEW = false;
+
+    final Context mContext;
+    final WindowManagerService mWindowManager;
+    Handler mHandler = new Handler();
+    NotificationCallbacks mNotificationCallbacks;
+    volatile IStatusBar mBar;
+    StatusBarIconList mIcons = new StatusBarIconList();
+    HashMap<IBinder,StatusBarNotification> mNotifications
+            = new HashMap<IBinder,StatusBarNotification>();
+
+    // for disabling the status bar
+    ArrayList<DisableRecord> mDisableRecords = new ArrayList<DisableRecord>();
+    IBinder mSysUiVisToken = new Binder();
+    int mDisabled = 0;
+
+    Object mLock = new Object();
+    // encompasses lights-out mode and other flags defined on View
+    int mSystemUiVisibility = 0;
+    boolean mMenuVisible = false;
+    int mImeWindowVis = 0;
+    int mImeBackDisposition;
+    IBinder mImeToken = null;
+
+    private class DisableRecord implements IBinder.DeathRecipient {
+        String pkg;
+        int what;
+        IBinder token;
+
+        public void binderDied() {
+            Slog.i(TAG, "binder died for pkg=" + pkg);
+            disable(0, token, pkg);
+            token.unlinkToDeath(this, 0);
+        }
+    }
+
+    public interface NotificationCallbacks {
+        void onSetDisabled(int status);
+        void onClearAll();
+        void onNotificationClick(String pkg, String tag, int id);
+        void onNotificationClear(String pkg, String tag, int id);
+        void onPanelRevealed();
+        void onNotificationError(String pkg, String tag, int id,
+                int uid, int initialPid, String message);
+    }
+
+    /**
+     * Construct the service, add the status bar view to the window manager
+     */
+    public StatusBarManagerService(Context context, WindowManagerService windowManager) {
+        mContext = context;
+        mWindowManager = windowManager;
+        mWindowManager.setOnHardKeyboardStatusChangeListener(this);
+
+        final Resources res = context.getResources();
+        mIcons.defineSlots(res.getStringArray(com.android.internal.R.array.config_statusBarIcons));
+    }
+
+    public void setNotificationCallbacks(NotificationCallbacks listener) {
+        mNotificationCallbacks = listener;
+    }
+
+    // ================================================================================
+    // From IStatusBarService
+    // ================================================================================
+    public void expand() {
+        enforceExpandStatusBar();
+
+        if (mBar != null) {
+            try {
+                mBar.animateExpand();
+            } catch (RemoteException ex) {
+            }
+        }
+    }
+
+    public void collapse() {
+        enforceExpandStatusBar();
+
+        if (mBar != null) {
+            try {
+                mBar.animateCollapse();
+            } catch (RemoteException ex) {
+            }
+        }
+    }
+
+    public void disable(int what, IBinder token, String pkg) {
+        enforceStatusBar();
+
+        synchronized (mLock) {
+            disableLocked(what, token, pkg);
+        }
+    }
+
+    private void disableLocked(int what, IBinder token, String pkg) {
+        // It's important that the the callback and the call to mBar get done
+        // in the same order when multiple threads are calling this function
+        // so they are paired correctly.  The messages on the handler will be
+        // handled in the order they were enqueued, but will be outside the lock.
+        manageDisableListLocked(what, token, pkg);
+        final int net = gatherDisableActionsLocked();
+        if (net != mDisabled) {
+            mDisabled = net;
+            mHandler.post(new Runnable() {
+                    public void run() {
+                        mNotificationCallbacks.onSetDisabled(net);
+                    }
+                });
+            if (mBar != null) {
+                try {
+                    mBar.disable(net);
+                } catch (RemoteException ex) {
+                }
+            }
+        }
+    }
+
+    public void setIcon(String slot, String iconPackage, int iconId, int iconLevel,
+            String contentDescription) {
+        enforceStatusBar();
+
+        synchronized (mIcons) {
+            int index = mIcons.getSlotIndex(slot);
+            if (index < 0) {
+                throw new SecurityException("invalid status bar icon slot: " + slot);
+            }
+
+            StatusBarIcon icon = new StatusBarIcon(iconPackage, iconId, iconLevel, 0,
+                    contentDescription);
+            //Slog.d(TAG, "setIcon slot=" + slot + " index=" + index + " icon=" + icon);
+            mIcons.setIcon(index, icon);
+
+            if (mBar != null) {
+                try {
+                    mBar.setIcon(index, icon);
+                } catch (RemoteException ex) {
+                }
+            }
+        }
+    }
+
+    public void setIconVisibility(String slot, boolean visible) {
+        enforceStatusBar();
+
+        synchronized (mIcons) {
+            int index = mIcons.getSlotIndex(slot);
+            if (index < 0) {
+                throw new SecurityException("invalid status bar icon slot: " + slot);
+            }
+
+            StatusBarIcon icon = mIcons.getIcon(index);
+            if (icon == null) {
+                return;
+            }
+
+            if (icon.visible != visible) {
+                icon.visible = visible;
+
+                if (mBar != null) {
+                    try {
+                        mBar.setIcon(index, icon);
+                    } catch (RemoteException ex) {
+                    }
+                }
+            }
+        }
+    }
+
+    public void removeIcon(String slot) {
+        enforceStatusBar();
+
+        synchronized (mIcons) {
+            int index = mIcons.getSlotIndex(slot);
+            if (index < 0) {
+                throw new SecurityException("invalid status bar icon slot: " + slot);
+            }
+
+            mIcons.removeIcon(index);
+
+            if (mBar != null) {
+                try {
+                    mBar.removeIcon(index);
+                } catch (RemoteException ex) {
+                }
+            }
+        }
+    }
+
+    /** 
+     * Hide or show the on-screen Menu key. Only call this from the window manager, typically in
+     * response to a window with FLAG_NEEDS_MENU_KEY set.
+     */
+    public void topAppWindowChanged(final boolean menuVisible) {
+        enforceStatusBar();
+
+        if (SPEW) Slog.d(TAG, (menuVisible?"showing":"hiding") + " MENU key");
+
+        synchronized(mLock) {
+            mMenuVisible = menuVisible;
+            mHandler.post(new Runnable() {
+                    public void run() {
+                        if (mBar != null) {
+                            try {
+                                mBar.topAppWindowChanged(menuVisible);
+                            } catch (RemoteException ex) {
+                            }
+                        }
+                    }
+                });
+        }
+    }
+
+    public void setImeWindowStatus(final IBinder token, final int vis, final int backDisposition) {
+        enforceStatusBar();
+
+        if (SPEW) {
+            Slog.d(TAG, "swetImeWindowStatus vis=" + vis + " backDisposition=" + backDisposition);
+        }
+
+        synchronized(mLock) {
+            // In case of IME change, we need to call up setImeWindowStatus() regardless of
+            // mImeWindowVis because mImeWindowVis may not have been set to false when the
+            // previous IME was destroyed.
+            mImeWindowVis = vis;
+            mImeBackDisposition = backDisposition;
+            mImeToken = token;
+            mHandler.post(new Runnable() {
+                public void run() {
+                    if (mBar != null) {
+                        try {
+                            mBar.setImeWindowStatus(token, vis, backDisposition);
+                        } catch (RemoteException ex) {
+                        }
+                    }
+                }
+            });
+        }
+    }
+
+    public void setSystemUiVisibility(int vis, int mask) {
+        // also allows calls from window manager which is in this process.
+        enforceStatusBarService();
+
+        if (SPEW) Slog.d(TAG, "setSystemUiVisibility(0x" + Integer.toHexString(vis) + ")");
+
+        synchronized (mLock) {
+            updateUiVisibilityLocked(vis, mask);
+            disableLocked(vis & StatusBarManager.DISABLE_MASK, mSysUiVisToken,
+                    "WindowManager.LayoutParams");
+        }
+    }
+
+    private void updateUiVisibilityLocked(final int vis, final int mask) {
+        if (mSystemUiVisibility != vis) {
+            mSystemUiVisibility = vis;
+            mHandler.post(new Runnable() {
+                    public void run() {
+                        if (mBar != null) {
+                            try {
+                                mBar.setSystemUiVisibility(vis, mask);
+                            } catch (RemoteException ex) {
+                            }
+                        }
+                    }
+                });
+        }
+    }
+
+    public void setHardKeyboardEnabled(final boolean enabled) {
+        mHandler.post(new Runnable() {
+            public void run() {
+                mWindowManager.setHardKeyboardEnabled(enabled);
+            }
+        });
+    }
+
+    @Override
+    public void onHardKeyboardStatusChange(final boolean available, final boolean enabled) {
+        mHandler.post(new Runnable() {
+            public void run() {
+                if (mBar != null) {
+                    try {
+                        mBar.setHardKeyboardStatus(available, enabled);
+                    } catch (RemoteException ex) {
+                    }
+                }
+            }
+        });
+    }
+
+    @Override
+    public void toggleRecentApps() {
+        if (mBar != null) {
+            try {
+                mBar.toggleRecentApps();
+            } catch (RemoteException ex) {}
+        }
+    }
+
+    @Override
+    public void preloadRecentApps() {
+        if (mBar != null) {
+            try {
+                mBar.preloadRecentApps();
+            } catch (RemoteException ex) {}
+        }
+    }
+
+    @Override
+    public void cancelPreloadRecentApps() {
+        if (mBar != null) {
+            try {
+                mBar.cancelPreloadRecentApps();
+            } catch (RemoteException ex) {}
+        }
+    }
+
+    private void enforceStatusBar() {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR,
+                "StatusBarManagerService");
+    }
+
+    private void enforceExpandStatusBar() {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.EXPAND_STATUS_BAR,
+                "StatusBarManagerService");
+    }
+
+    private void enforceStatusBarService() {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE,
+                "StatusBarManagerService");
+    }
+
+    // ================================================================================
+    // Callbacks from the status bar service.
+    // ================================================================================
+    public void registerStatusBar(IStatusBar bar, StatusBarIconList iconList,
+            List<IBinder> notificationKeys, List<StatusBarNotification> notifications,
+            int switches[], List<IBinder> binders) {
+        enforceStatusBarService();
+
+        Slog.i(TAG, "registerStatusBar bar=" + bar);
+        mBar = bar;
+        synchronized (mIcons) {
+            iconList.copyFrom(mIcons);
+        }
+        synchronized (mNotifications) {
+            for (Map.Entry<IBinder,StatusBarNotification> e: mNotifications.entrySet()) {
+                notificationKeys.add(e.getKey());
+                notifications.add(e.getValue());
+            }
+        }
+        synchronized (mLock) {
+            switches[0] = gatherDisableActionsLocked();
+            switches[1] = mSystemUiVisibility;
+            switches[2] = mMenuVisible ? 1 : 0;
+            switches[3] = mImeWindowVis;
+            switches[4] = mImeBackDisposition;
+            binders.add(mImeToken);
+        }
+        switches[5] = mWindowManager.isHardKeyboardAvailable() ? 1 : 0;
+        switches[6] = mWindowManager.isHardKeyboardEnabled() ? 1 : 0;
+    }
+
+    /**
+     * The status bar service should call this each time the user brings the panel from
+     * invisible to visible in order to clear the notification light.
+     */
+    public void onPanelRevealed() {
+        enforceStatusBarService();
+
+        // tell the notification manager to turn off the lights.
+        mNotificationCallbacks.onPanelRevealed();
+    }
+
+    public void onNotificationClick(String pkg, String tag, int id) {
+        enforceStatusBarService();
+
+        mNotificationCallbacks.onNotificationClick(pkg, tag, id);
+    }
+
+    public void onNotificationError(String pkg, String tag, int id,
+            int uid, int initialPid, String message) {
+        enforceStatusBarService();
+
+        // WARNING: this will call back into us to do the remove.  Don't hold any locks.
+        mNotificationCallbacks.onNotificationError(pkg, tag, id, uid, initialPid, message);
+    }
+
+    public void onNotificationClear(String pkg, String tag, int id) {
+        enforceStatusBarService();
+
+        mNotificationCallbacks.onNotificationClear(pkg, tag, id);
+    }
+
+    public void onClearAllNotifications() {
+        enforceStatusBarService();
+
+        mNotificationCallbacks.onClearAll();
+    }
+
+    // ================================================================================
+    // Callbacks for NotificationManagerService.
+    // ================================================================================
+    public IBinder addNotification(StatusBarNotification notification) {
+        synchronized (mNotifications) {
+            IBinder key = new Binder();
+            mNotifications.put(key, notification);
+            if (mBar != null) {
+                try {
+                    mBar.addNotification(key, notification);
+                } catch (RemoteException ex) {
+                }
+            }
+            return key;
+        }
+    }
+
+    public void updateNotification(IBinder key, StatusBarNotification notification) {
+        synchronized (mNotifications) {
+            if (!mNotifications.containsKey(key)) {
+                throw new IllegalArgumentException("updateNotification key not found: " + key);
+            }
+            mNotifications.put(key, notification);
+            if (mBar != null) {
+                try {
+                    mBar.updateNotification(key, notification);
+                } catch (RemoteException ex) {
+                }
+            }
+        }
+    }
+
+    public void removeNotification(IBinder key) {
+        synchronized (mNotifications) {
+            final StatusBarNotification n = mNotifications.remove(key);
+            if (n == null) {
+                Slog.e(TAG, "removeNotification key not found: " + key);
+                return;
+            }
+            if (mBar != null) {
+                try {
+                    mBar.removeNotification(key);
+                } catch (RemoteException ex) {
+                }
+            }
+        }
+    }
+
+    // ================================================================================
+    // Can be called from any thread
+    // ================================================================================
+
+    // lock on mDisableRecords
+    void manageDisableListLocked(int what, IBinder token, String pkg) {
+        if (SPEW) {
+            Slog.d(TAG, "manageDisableList what=0x" + Integer.toHexString(what) + " pkg=" + pkg);
+        }
+        // update the list
+        final int N = mDisableRecords.size();
+        DisableRecord tok = null;
+        int i;
+        for (i=0; i<N; i++) {
+            DisableRecord t = mDisableRecords.get(i);
+            if (t.token == token) {
+                tok = t;
+                break;
+            }
+        }
+        if (what == 0 || !token.isBinderAlive()) {
+            if (tok != null) {
+                mDisableRecords.remove(i);
+                tok.token.unlinkToDeath(tok, 0);
+            }
+        } else {
+            if (tok == null) {
+                tok = new DisableRecord();
+                try {
+                    token.linkToDeath(tok, 0);
+                }
+                catch (RemoteException ex) {
+                    return; // give up
+                }
+                mDisableRecords.add(tok);
+            }
+            tok.what = what;
+            tok.token = token;
+            tok.pkg = pkg;
+        }
+    }
+
+    // lock on mDisableRecords
+    int gatherDisableActionsLocked() {
+        final int N = mDisableRecords.size();
+        // gather the new net flags
+        int net = 0;
+        for (int i=0; i<N; i++) {
+            net |= mDisableRecords.get(i).what;
+        }
+        return net;
+    }
+
+    // ================================================================================
+    // Always called from UI thread
+    // ================================================================================
+
+    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP)
+                != PackageManager.PERMISSION_GRANTED) {
+            pw.println("Permission Denial: can't dump StatusBar from from pid="
+                    + Binder.getCallingPid()
+                    + ", uid=" + Binder.getCallingUid());
+            return;
+        }
+
+        synchronized (mIcons) {
+            mIcons.dump(pw);
+        }
+
+        synchronized (mNotifications) {
+            int i=0;
+            pw.println("Notification list:");
+            for (Map.Entry<IBinder,StatusBarNotification> e: mNotifications.entrySet()) {
+                pw.printf("  %2d: %s\n", i, e.getValue().toString());
+                i++;
+            }
+        }
+
+        synchronized (mLock) {
+            final int N = mDisableRecords.size();
+            pw.println("  mDisableRecords.size=" + N
+                    + " mDisabled=0x" + Integer.toHexString(mDisabled));
+            for (int i=0; i<N; i++) {
+                DisableRecord tok = mDisableRecords.get(i);
+                pw.println("    [" + i + "] what=0x" + Integer.toHexString(tok.what)
+                                + " pkg=" + tok.pkg + " token=" + tok.token);
+            }
+        }
+    }
+
+    private BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action)
+                    || Intent.ACTION_SCREEN_OFF.equals(action)) {
+                collapse();
+            }
+            /*
+            else if (Telephony.Intents.SPN_STRINGS_UPDATED_ACTION.equals(action)) {
+                updateNetworkName(intent.getBooleanExtra(Telephony.Intents.EXTRA_SHOW_SPN, false),
+                        intent.getStringExtra(Telephony.Intents.EXTRA_SPN),
+                        intent.getBooleanExtra(Telephony.Intents.EXTRA_SHOW_PLMN, false),
+                        intent.getStringExtra(Telephony.Intents.EXTRA_PLMN));
+            }
+            else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
+                updateResources();
+            }
+            */
+        }
+    };
+
+}
diff --git a/src/frameworks/base/services/java/com/android/server/am/ProcessList.java b/src/frameworks/base/services/java/com/android/server/am/ProcessList.java
new file mode 100644
index 0000000..af7b314
--- /dev/null
+++ b/src/frameworks/base/services/java/com/android/server/am/ProcessList.java
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.am;
+
+import java.io.FileOutputStream;
+import java.io.IOException;
+
+import com.android.internal.util.MemInfoReader;
+import com.android.server.wm.WindowManagerService;
+
+import android.graphics.Point;
+import android.util.Slog;
+
+/**
+ * Activity manager code dealing with processes.
+ */
+class ProcessList {
+    // The minimum time we allow between crashes, for us to consider this
+    // application to be bad and stop and its services and reject broadcasts.
+    static final int MIN_CRASH_INTERVAL = 60*1000;
+
+    // OOM adjustments for processes in various states:
+
+    // This is a process only hosting activities that are not visible,
+    // so it can be killed without any disruption.
+    static final int HIDDEN_APP_MAX_ADJ = 15;
+    static int HIDDEN_APP_MIN_ADJ = 9;
+
+    // The B list of SERVICE_ADJ -- these are the old and decrepit
+    // services that aren't as shiny and interesting as the ones in the A list.
+    static final int SERVICE_B_ADJ = 8;
+
+    // This is the process of the previous application that the user was in.
+    // This process is kept above other things, because it is very common to
+    // switch back to the previous app.  This is important both for recent
+    // task switch (toggling between the two top recent apps) as well as normal
+    // UI flow such as clicking on a URI in the e-mail app to view in the browser,
+    // and then pressing back to return to e-mail.
+    static final int PREVIOUS_APP_ADJ = 7;
+
+    // This is a process holding the home application -- we want to try
+    // avoiding killing it, even if it would normally be in the background,
+    // because the user interacts with it so much.
+    static final int HOME_APP_ADJ = 6;
+
+    // This is a process holding an application service -- killing it will not
+    // have much of an impact as far as the user is concerned.
+    static final int SERVICE_ADJ = 5;
+
+    // This is a process currently hosting a backup operation.  Killing it
+    // is not entirely fatal but is generally a bad idea.
+    static final int BACKUP_APP_ADJ = 4;
+
+    // This is a process with a heavy-weight application.  It is in the
+    // background, but we want to try to avoid killing it.  Value set in
+    // system/rootdir/init.rc on startup.
+    static final int HEAVY_WEIGHT_APP_ADJ = 3;
+
+    // This is a process only hosting components that are perceptible to the
+    // user, and we really want to avoid killing them, but they are not
+    // immediately visible. An example is background music playback.
+    static final int PERCEPTIBLE_APP_ADJ = 2;
+
+    // This is a process only hosting activities that are visible to the
+    // user, so we'd prefer they don't disappear.
+    static final int VISIBLE_APP_ADJ = 1;
+
+    // This is the process running the current foreground app.  We'd really
+    // rather not kill it!
+    static final int FOREGROUND_APP_ADJ = 0;
+
+    // This is a system persistent process, such as telephony.  Definitely
+    // don't want to kill it, but doing so is not completely fatal.
+    static final int PERSISTENT_PROC_ADJ = -12;
+
+    // The system process runs at the default adjustment.
+    static final int SYSTEM_ADJ = -16;
+
+    // Memory pages are 4K.
+    static final int PAGE_SIZE = 4*1024;
+
+    // The minimum number of hidden apps we want to be able to keep around,
+    // without empty apps being able to push them out of memory.
+    static final int MIN_HIDDEN_APPS = 2;
+
+    // The maximum number of hidden processes we will keep around before
+    // killing them; this is just a control to not let us go too crazy with
+    // keeping around processes on devices with large amounts of RAM.
+    static final int MAX_HIDDEN_APPS = 15;
+
+    // We put empty content processes after any hidden processes that have
+    // been idle for less than 15 seconds.
+    static final long CONTENT_APP_IDLE_OFFSET = 15*1000;
+
+    // We put empty content processes after any hidden processes that have
+    // been idle for less than 120 seconds.
+    static final long EMPTY_APP_IDLE_OFFSET = 120*1000;
+
+    // These are the various interesting memory levels that we will give to
+    // the OOM killer.  Note that the OOM killer only supports 6 slots, so we
+    // can't give it a different value for every possible kind of process.
+    private final int[] mOomAdj = new int[] {
+            FOREGROUND_APP_ADJ, VISIBLE_APP_ADJ, PERCEPTIBLE_APP_ADJ,
+            BACKUP_APP_ADJ, HIDDEN_APP_MIN_ADJ, HIDDEN_APP_MAX_ADJ
+    };
+    // These are the low-end OOM level limits.  This is appropriate for an
+    // HVGA or smaller phone with less than 512MB.  Values are in KB.
+    private final long[] mOomMinFreeLow = new long[] {
+            8192, 12288, 16384,
+            24576, 28672, 32768
+    };
+    // These are the high-end OOM level limits.  This is appropriate for a
+    // 1280x800 or larger screen with around 1GB RAM.  Values are in KB.
+    private final long[] mOomMinFreeHigh = new long[] {
+            32768, 40960, 49152,
+            57344, 65536, 81920
+    };
+    // The actual OOM killer memory levels we are using.
+    private final long[] mOomMinFree = new long[mOomAdj.length];
+
+    private final long mTotalMemMb;
+
+    private boolean mHaveDisplaySize;
+
+    ProcessList() {
+        MemInfoReader minfo = new MemInfoReader();
+        minfo.readMemInfo();
+        mTotalMemMb = minfo.getTotalSize()/(1024*1024);
+        updateOomLevels(0, 0, false);
+    }
+
+    void applyDisplaySize(WindowManagerService wm) {
+        if (!mHaveDisplaySize) {
+            Point p = new Point();
+            wm.getInitialDisplaySize(p);
+            if (p.x != 0 && p.y != 0) {
+                updateOomLevels(p.x, p.y, true);
+                mHaveDisplaySize = true;
+            }
+        }
+    }
+
+    private void updateOomLevels(int displayWidth, int displayHeight, boolean write) {
+        // Scale buckets from avail memory: at 300MB we use the lowest values to
+        // 700MB or more for the top values.
+        float scaleMem = ((float)(mTotalMemMb-300))/(700-300);
+
+        // Scale buckets from screen size.
+        int minSize = 320*480;  //  153600
+        int maxSize = 1280*800; // 1024000  230400 870400  .264
+        float scaleDisp = ((float)(displayWidth*displayHeight)-minSize)/(maxSize-minSize);
+        //Slog.i("XXXXXX", "scaleDisp=" + scaleDisp + " dw=" + displayWidth + " dh=" + displayHeight);
+
+        StringBuilder adjString = new StringBuilder();
+        StringBuilder memString = new StringBuilder();
+
+        float scale = scaleMem > scaleDisp ? scaleMem : scaleDisp;
+        if (scale < 0) scale = 0;
+        else if (scale > 1) scale = 1;
+        for (int i=0; i<mOomAdj.length; i++) {
+            long low = mOomMinFreeLow[i];
+            long high = mOomMinFreeHigh[i];
+            mOomMinFree[i] = (long)(low + ((high-low)*scale));
+
+            if (i > 0) {
+                adjString.append(',');
+                memString.append(',');
+            }
+            adjString.append(mOomAdj[i]);
+            memString.append((mOomMinFree[i]*1024)/PAGE_SIZE);
+        }
+
+        //Slog.i("XXXXXXX", "******************************* MINFREE: " + memString);
+        if (write) {
+            writeFile("/sys/module/lowmemorykiller/parameters/adj", adjString.toString());
+            writeFile("/sys/module/lowmemorykiller/parameters/minfree", memString.toString());
+        }
+        // GB: 2048,3072,4096,6144,7168,8192
+        // HC: 8192,10240,12288,14336,16384,20480
+    }
+
+    long getMemLevel(int adjustment) {
+        for (int i=0; i<mOomAdj.length; i++) {
+            if (adjustment <= mOomAdj[i]) {
+                return mOomMinFree[i] * 1024;
+            }
+        }
+        return mOomMinFree[mOomAdj.length-1] * 1024;
+    }
+
+    private void writeFile(String path, String data) {
+        FileOutputStream fos = null;
+        try {
+            fos = new FileOutputStream(path);
+            fos.write(data.getBytes());
+        } catch (IOException e) {
+            Slog.w(ActivityManagerService.TAG, "Unable to write " + path);
+        } finally {
+            if (fos != null) {
+                try {
+                    fos.close();
+                } catch (IOException e) {
+                }
+            }
+        }
+    }
+}
diff --git a/src/frameworks/base/services/java/com/android/server/am/UsageStatsService.java b/src/frameworks/base/services/java/com/android/server/am/UsageStatsService.java
new file mode 100644
index 0000000..ba65f39
--- /dev/null
+++ b/src/frameworks/base/services/java/com/android/server/am/UsageStatsService.java
@@ -0,0 +1,1082 @@
+/*
+ * Copyright (C) 2006-2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.am;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.os.Binder;
+import android.os.IBinder;
+import android.os.FileUtils;
+import android.os.Parcel;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.os.SystemClock;
+import android.util.Slog;
+import android.util.Xml;
+
+import com.android.internal.app.IUsageStats;
+import com.android.internal.content.PackageMonitor;
+import com.android.internal.os.AtomicFile;
+import com.android.internal.os.PkgUsageStats;
+import com.android.internal.util.FastXmlSerializer;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlSerializer;
+
+import java.io.File;
+import java.io.FileDescriptor;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.TimeZone;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
+
+/**
+ * This service collects the statistics associated with usage
+ * of various components, like when a particular package is launched or
+ * paused and aggregates events like number of time a component is launched
+ * total duration of a component launch.
+ */
+public final class UsageStatsService extends IUsageStats.Stub {
+    public static final String SERVICE_NAME = "usagestats";
+    private static final boolean localLOGV = false;
+    private static final boolean REPORT_UNEXPECTED = false;
+    private static final String TAG = "UsageStats";
+    
+    // Current on-disk Parcel version
+    private static final int VERSION = 1007;
+
+    private static final int CHECKIN_VERSION = 4;
+    
+    private static final String FILE_PREFIX = "usage-";
+
+    private static final String FILE_HISTORY = FILE_PREFIX + "history.xml";
+
+    private static final int FILE_WRITE_INTERVAL = 30*60*1000; //ms
+    
+    private static final int MAX_NUM_FILES = 5;
+    
+    private static final int NUM_LAUNCH_TIME_BINS = 10;
+    private static final int[] LAUNCH_TIME_BINS = {
+        250, 500, 750, 1000, 1500, 2000, 3000, 4000, 5000
+    };
+    
+    static IUsageStats sService;
+    private Context mContext;
+    // structure used to maintain statistics since the last checkin.
+    final private Map<String, PkgUsageStatsExtended> mStats;
+
+    // Maintains the last time any component was resumed, for all time.
+    final private Map<String, Map<String, Long>> mLastResumeTimes;
+
+    // To remove last-resume time stats when a pacakge is removed.
+    private PackageMonitor mPackageMonitor;
+
+    // Lock to update package stats. Methods suffixed by SLOCK should invoked with
+    // this lock held
+    final Object mStatsLock;
+    // Lock to write to file. Methods suffixed by FLOCK should invoked with
+    // this lock held.
+    final Object mFileLock;
+    // Order of locks is mFileLock followed by mStatsLock to avoid deadlocks
+    private String mLastResumedPkg;
+    private String mLastResumedComp;
+    private boolean mIsResumed;
+    private File mFile;
+    private AtomicFile mHistoryFile;
+    private String mFileLeaf;
+    private File mDir;
+
+    private Calendar mCal; // guarded by itself
+
+    private final AtomicInteger mLastWriteDay = new AtomicInteger(-1);
+    private final AtomicLong mLastWriteElapsedTime = new AtomicLong(0);
+    private final AtomicBoolean mUnforcedDiskWriteRunning = new AtomicBoolean(false);
+    
+    static class TimeStats {
+        int count;
+        int[] times = new int[NUM_LAUNCH_TIME_BINS];
+        
+        TimeStats() {
+        }
+        
+        void incCount() {
+            count++;
+        }
+        
+        void add(int val) {
+            final int[] bins = LAUNCH_TIME_BINS;
+            for (int i=0; i<NUM_LAUNCH_TIME_BINS-1; i++) {
+                if (val < bins[i]) {
+                    times[i]++;
+                    return;
+                }
+            }
+            times[NUM_LAUNCH_TIME_BINS-1]++;
+        }
+        
+        TimeStats(Parcel in) {
+            count = in.readInt();
+            final int[] localTimes = times;
+            for (int i=0; i<NUM_LAUNCH_TIME_BINS; i++) {
+                localTimes[i] = in.readInt();
+            }
+        }
+        
+        void writeToParcel(Parcel out) {
+            out.writeInt(count);
+            final int[] localTimes = times;
+            for (int i=0; i<NUM_LAUNCH_TIME_BINS; i++) {
+                out.writeInt(localTimes[i]);
+            }
+        }
+    }
+    
+    private class PkgUsageStatsExtended {
+        final HashMap<String, TimeStats> mLaunchTimes
+                = new HashMap<String, TimeStats>();
+        int mLaunchCount;
+        long mUsageTime;
+        long mPausedTime;
+        long mResumedTime;
+        
+        PkgUsageStatsExtended() {
+            mLaunchCount = 0;
+            mUsageTime = 0;
+        }
+        
+        PkgUsageStatsExtended(Parcel in) {
+            mLaunchCount = in.readInt();
+            mUsageTime = in.readLong();
+            if (localLOGV) Slog.v(TAG, "Launch count: " + mLaunchCount
+                    + ", Usage time:" + mUsageTime);
+            
+            final int numTimeStats = in.readInt();
+            if (localLOGV) Slog.v(TAG, "Reading comps: " + numTimeStats);
+            for (int i=0; i<numTimeStats; i++) {
+                String comp = in.readString();
+                if (localLOGV) Slog.v(TAG, "Component: " + comp);
+                TimeStats times = new TimeStats(in);
+                mLaunchTimes.put(comp, times);
+            }
+        }
+
+        void updateResume(String comp, boolean launched) {
+            if (launched) {
+                mLaunchCount ++;
+            }
+            mResumedTime = SystemClock.elapsedRealtime();
+        }
+        
+        void updatePause() {
+            mPausedTime =  SystemClock.elapsedRealtime();
+            mUsageTime += (mPausedTime - mResumedTime);
+        }
+        
+        void addLaunchCount(String comp) {
+            TimeStats times = mLaunchTimes.get(comp);
+            if (times == null) {
+                times = new TimeStats();
+                mLaunchTimes.put(comp, times);
+            }
+            times.incCount();
+        }
+        
+        void addLaunchTime(String comp, int millis) {
+            TimeStats times = mLaunchTimes.get(comp);
+            if (times == null) {
+                times = new TimeStats();
+                mLaunchTimes.put(comp, times);
+            }
+            times.add(millis);
+        }
+        
+        void writeToParcel(Parcel out) {
+            out.writeInt(mLaunchCount);
+            out.writeLong(mUsageTime);
+            final int numTimeStats = mLaunchTimes.size();
+            out.writeInt(numTimeStats);
+            if (numTimeStats > 0) {
+                for (Map.Entry<String, TimeStats> ent : mLaunchTimes.entrySet()) {
+                    out.writeString(ent.getKey());
+                    TimeStats times = ent.getValue();
+                    times.writeToParcel(out);
+                }
+            }
+        }
+        
+        void clear() {
+            mLaunchTimes.clear();
+            mLaunchCount = 0;
+            mUsageTime = 0;
+        }
+    }
+    
+    UsageStatsService(String dir) {
+        mStats = new HashMap<String, PkgUsageStatsExtended>();
+        mLastResumeTimes = new HashMap<String, Map<String, Long>>();
+        mStatsLock = new Object();
+        mFileLock = new Object();
+        mDir = new File(dir);
+        mCal = Calendar.getInstance(TimeZone.getTimeZone("GMT+0"));
+        
+        mDir.mkdir();
+        
+        // Remove any old usage files from previous versions.
+        File parentDir = mDir.getParentFile();
+        String fList[] = parentDir.list();
+        if (fList != null) {
+            String prefix = mDir.getName() + ".";
+            int i = fList.length;
+            while (i > 0) {
+                i--;
+                if (fList[i].startsWith(prefix)) {
+                    Slog.i(TAG, "Deleting old usage file: " + fList[i]);
+                    (new File(parentDir, fList[i])).delete();
+                }
+            }
+        }
+        
+        // Update current stats which are binned by date
+        mFileLeaf = getCurrentDateStr(FILE_PREFIX);
+        mFile = new File(mDir, mFileLeaf);
+        mHistoryFile = new AtomicFile(new File(mDir, FILE_HISTORY));
+        readStatsFromFile();
+        readHistoryStatsFromFile();
+        mLastWriteElapsedTime.set(SystemClock.elapsedRealtime());
+        // mCal was set by getCurrentDateStr(), want to use that same time.
+        mLastWriteDay.set(mCal.get(Calendar.DAY_OF_YEAR));
+    }
+
+    /*
+     * Utility method to convert date into string.
+     */
+    private String getCurrentDateStr(String prefix) {
+        StringBuilder sb = new StringBuilder();
+        synchronized (mCal) {
+            mCal.setTimeInMillis(System.currentTimeMillis());
+            if (prefix != null) {
+                sb.append(prefix);
+            }
+            sb.append(mCal.get(Calendar.YEAR));
+            int mm = mCal.get(Calendar.MONTH) - Calendar.JANUARY +1;
+            if (mm < 10) {
+                sb.append("0");
+            }
+            sb.append(mm);
+            int dd = mCal.get(Calendar.DAY_OF_MONTH);
+            if (dd < 10) {
+                sb.append("0");
+            }
+            sb.append(dd);
+        }
+        return sb.toString();
+    }
+    
+    private Parcel getParcelForFile(File file) throws IOException {
+        FileInputStream stream = new FileInputStream(file);
+        byte[] raw = readFully(stream);
+        Parcel in = Parcel.obtain();
+        in.unmarshall(raw, 0, raw.length);
+        in.setDataPosition(0);
+        stream.close();
+        return in;
+    }
+    
+    private void readStatsFromFile() {
+        File newFile = mFile;
+        synchronized (mFileLock) {
+            try {
+                if (newFile.exists()) {
+                    readStatsFLOCK(newFile);
+                } else {
+                    // Check for file limit before creating a new file
+                    checkFileLimitFLOCK();
+                    newFile.createNewFile();
+                }
+            } catch (IOException e) {
+                Slog.w(TAG,"Error : " + e + " reading data from file:" + newFile);
+            }
+        }
+    }
+    
+    private void readStatsFLOCK(File file) throws IOException {
+        Parcel in = getParcelForFile(file);
+        int vers = in.readInt();
+        if (vers != VERSION) {
+            Slog.w(TAG, "Usage stats version changed; dropping");
+            return;
+        }
+        int N = in.readInt();
+        while (N > 0) {
+            N--;
+            String pkgName = in.readString();
+            if (pkgName == null) {
+                break;
+            }
+            if (localLOGV) Slog.v(TAG, "Reading package #" + N + ": " + pkgName);
+            PkgUsageStatsExtended pus = new PkgUsageStatsExtended(in);
+            synchronized (mStatsLock) {
+                mStats.put(pkgName, pus);
+            }
+        }
+    }
+
+    private void readHistoryStatsFromFile() {
+        synchronized (mFileLock) {
+            if (mHistoryFile.getBaseFile().exists()) {
+                readHistoryStatsFLOCK(mHistoryFile);
+            }
+        }
+    }
+
+    private void readHistoryStatsFLOCK(AtomicFile file) {
+        FileInputStream fis = null;
+        try {
+            fis = mHistoryFile.openRead();
+            XmlPullParser parser = Xml.newPullParser();
+            parser.setInput(fis, null);
+            int eventType = parser.getEventType();
+            while (eventType != XmlPullParser.START_TAG) {
+                eventType = parser.next();
+            }
+            String tagName = parser.getName();
+            if ("usage-history".equals(tagName)) {
+                String pkg = null;
+                do {
+                    eventType = parser.next();
+                    if (eventType == XmlPullParser.START_TAG) {
+                        tagName = parser.getName();
+                        int depth = parser.getDepth();
+                        if ("pkg".equals(tagName) && depth == 2) {
+                            pkg = parser.getAttributeValue(null, "name");
+                        } else if ("comp".equals(tagName) && depth == 3 && pkg != null) {
+                            String comp = parser.getAttributeValue(null, "name");
+                            String lastResumeTimeStr = parser.getAttributeValue(null, "lrt");
+                            if (comp != null && lastResumeTimeStr != null) {
+                                try {
+                                    long lastResumeTime = Long.parseLong(lastResumeTimeStr);
+                                    synchronized (mStatsLock) {
+                                        Map<String, Long> lrt = mLastResumeTimes.get(pkg);
+                                        if (lrt == null) {
+                                            lrt = new HashMap<String, Long>();
+                                            mLastResumeTimes.put(pkg, lrt);
+                                        }
+                                        lrt.put(comp, lastResumeTime);
+                                    }
+                                } catch (NumberFormatException e) {
+                                }
+                            }
+                        }
+                    } else if (eventType == XmlPullParser.END_TAG) {
+                        if ("pkg".equals(parser.getName())) {
+                            pkg = null;
+                        }
+                    }
+                } while (eventType != XmlPullParser.END_DOCUMENT);
+            }
+        } catch (XmlPullParserException e) {
+            Slog.w(TAG,"Error reading history stats: " + e);
+        } catch (IOException e) {
+            Slog.w(TAG,"Error reading history stats: " + e);
+        } finally {
+            if (fis != null) {
+                try {
+                    fis.close();
+                } catch (IOException e) {
+                }
+            }
+        }
+    }
+
+    private ArrayList<String> getUsageStatsFileListFLOCK() {
+        // Check if there are too many files in the system and delete older files
+        String fList[] = mDir.list();
+        if (fList == null) {
+            return null;
+        }
+        ArrayList<String> fileList = new ArrayList<String>();
+        for (String file : fList) {
+            if (!file.startsWith(FILE_PREFIX)) {
+                continue;
+            }
+            if (file.endsWith(".bak")) {
+                (new File(mDir, file)).delete();
+                continue;
+            }
+            fileList.add(file);
+        }
+        return fileList;
+    }
+    
+    private void checkFileLimitFLOCK() {
+        // Get all usage stats output files
+        ArrayList<String> fileList = getUsageStatsFileListFLOCK();
+        if (fileList == null) {
+            // Strange but we dont have to delete any thing
+            return;
+        }
+        int count = fileList.size();
+        if (count <= MAX_NUM_FILES) {
+            return;
+        }
+        // Sort files
+        Collections.sort(fileList);
+        count -= MAX_NUM_FILES;
+        // Delete older files
+        for (int i = 0; i < count; i++) {
+            String fileName = fileList.get(i);
+            File file = new File(mDir, fileName);
+            Slog.i(TAG, "Deleting usage file : " + fileName);
+            file.delete();
+        }
+    }
+
+    /**
+     * Conditionally start up a disk write if it's been awhile, or the
+     * day has rolled over.
+     *
+     * This is called indirectly from user-facing actions (when
+     * 'force' is false) so it tries to be quick, without writing to
+     * disk directly or acquiring heavy locks.
+     *
+     * @params force  do an unconditional, synchronous stats flush
+     *                to disk on the current thread.
+     * @params forceWriteHistoryStats Force writing of historical stats.
+     */
+    private void writeStatsToFile(final boolean force, final boolean forceWriteHistoryStats) {
+        int curDay;
+        synchronized (mCal) {
+            mCal.setTimeInMillis(System.currentTimeMillis());
+            curDay = mCal.get(Calendar.DAY_OF_YEAR);
+        }
+        final boolean dayChanged = curDay != mLastWriteDay.get();
+
+        // Determine if the day changed...  note that this will be wrong
+        // if the year has changed but we are in the same day of year...
+        // we can probably live with this.
+        final long currElapsedTime = SystemClock.elapsedRealtime();
+
+        // Fast common path, without taking the often-contentious
+        // mFileLock.
+        if (!force) {
+            if (!dayChanged &&
+                (currElapsedTime - mLastWriteElapsedTime.get()) < FILE_WRITE_INTERVAL) {
+                // wait till the next update
+                return;
+            }
+            if (mUnforcedDiskWriteRunning.compareAndSet(false, true)) {
+                new Thread("UsageStatsService_DiskWriter") {
+                    public void run() {
+                        try {
+                            if (localLOGV) Slog.d(TAG, "Disk writer thread starting.");
+                            writeStatsToFile(true, false);
+                        } finally {
+                            mUnforcedDiskWriteRunning.set(false);
+                            if (localLOGV) Slog.d(TAG, "Disk writer thread ending.");
+                        }
+                    }
+                }.start();
+            }
+            return;
+        }
+
+        synchronized (mFileLock) {
+            // Get the most recent file
+            mFileLeaf = getCurrentDateStr(FILE_PREFIX);
+            // Copy current file to back up
+            File backupFile = null;
+            if (mFile != null && mFile.exists()) {
+                backupFile = new File(mFile.getPath() + ".bak");
+                if (!backupFile.exists()) {
+                    if (!mFile.renameTo(backupFile)) {
+                        Slog.w(TAG, "Failed to persist new stats");
+                        return;
+                    }
+                } else {
+                    mFile.delete();
+                }
+            }
+
+            try {
+                // Write mStats to file
+                writeStatsFLOCK(mFile);
+                mLastWriteElapsedTime.set(currElapsedTime);
+                if (dayChanged) {
+                    mLastWriteDay.set(curDay);
+                    // clear stats
+                    synchronized (mStats) {
+                        mStats.clear();
+                    }
+                    mFile = new File(mDir, mFileLeaf);
+                    checkFileLimitFLOCK();
+                }
+
+                if (dayChanged || forceWriteHistoryStats) {
+                    // Write history stats daily, or when forced (due to shutdown).
+                    writeHistoryStatsFLOCK(mHistoryFile);
+                }
+
+                // Delete the backup file
+                if (backupFile != null) {
+                    backupFile.delete();
+                }
+            } catch (IOException e) {
+                Slog.w(TAG, "Failed writing stats to file:" + mFile);
+                if (backupFile != null) {
+                    mFile.delete();
+                    backupFile.renameTo(mFile);
+                }
+            }
+        }
+        if (localLOGV) Slog.d(TAG, "Dumped usage stats.");
+    }
+
+    private void writeStatsFLOCK(File file) throws IOException {
+        FileOutputStream stream = new FileOutputStream(file);
+        try {
+            Parcel out = Parcel.obtain();
+            writeStatsToParcelFLOCK(out);
+            stream.write(out.marshall());
+            out.recycle();
+            stream.flush();
+        } finally {
+            FileUtils.sync(stream);
+            stream.close();
+        }
+    }
+
+    private void writeStatsToParcelFLOCK(Parcel out) {
+        synchronized (mStatsLock) {
+            out.writeInt(VERSION);
+            Set<String> keys = mStats.keySet();
+            out.writeInt(keys.size());
+            for (String key : keys) {
+                PkgUsageStatsExtended pus = mStats.get(key);
+                out.writeString(key);
+                pus.writeToParcel(out);
+            }
+        }
+    }
+
+    /** Filter out stats for any packages which aren't present anymore. */
+    private void filterHistoryStats() {
+        synchronized (mStatsLock) {
+            // Copy and clear the last resume times map, then copy back stats
+            // for all installed packages.
+            Map<String, Map<String, Long>> tmpLastResumeTimes =
+                new HashMap<String, Map<String, Long>>(mLastResumeTimes);
+            mLastResumeTimes.clear();
+            for (PackageInfo info : mContext.getPackageManager().getInstalledPackages(0)) {
+                if (tmpLastResumeTimes.containsKey(info.packageName)) {
+                    mLastResumeTimes.put(info.packageName, tmpLastResumeTimes.get(info.packageName));
+                }
+            }
+        }
+    }
+
+    private void writeHistoryStatsFLOCK(AtomicFile historyFile) {
+        FileOutputStream fos = null;
+        try {
+            fos = historyFile.startWrite();
+            XmlSerializer out = new FastXmlSerializer();
+            out.setOutput(fos, "utf-8");
+            out.startDocument(null, true);
+            out.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", true);
+            out.startTag(null, "usage-history");
+            synchronized (mStatsLock) {
+                for (Map.Entry<String, Map<String, Long>> pkgEntry : mLastResumeTimes.entrySet()) {
+                    out.startTag(null, "pkg");
+                    out.attribute(null, "name", pkgEntry.getKey());
+                    for (Map.Entry<String, Long> compEntry : pkgEntry.getValue().entrySet()) {
+                        out.startTag(null, "comp");
+                        out.attribute(null, "name", compEntry.getKey());
+                        out.attribute(null, "lrt", compEntry.getValue().toString());
+                        out.endTag(null, "comp");
+                    }
+                    out.endTag(null, "pkg");
+                }
+            }
+            out.endTag(null, "usage-history");
+            out.endDocument();
+
+            historyFile.finishWrite(fos);
+        } catch (IOException e) {
+            Slog.w(TAG,"Error writing history stats" + e);
+            if (fos != null) {
+                historyFile.failWrite(fos);
+            }
+        }
+    }
+
+    public void publish(Context context) {
+        mContext = context;
+        ServiceManager.addService(SERVICE_NAME, asBinder());
+    }
+
+    /**
+     * Start watching packages to remove stats when a package is uninstalled.
+     * May only be called when the package manager is ready.
+     */
+    public void monitorPackages() {
+        mPackageMonitor = new PackageMonitor() {
+            @Override
+            public void onPackageRemoved(String packageName, int uid) {
+                synchronized (mStatsLock) {
+                    mLastResumeTimes.remove(packageName);
+                }
+            }
+        };
+        mPackageMonitor.register(mContext, null, true);
+        filterHistoryStats();
+    }
+
+    public void shutdown() {
+        if (mPackageMonitor != null) {
+            mPackageMonitor.unregister();
+        }
+        Slog.i(TAG, "Writing usage stats before shutdown...");
+        writeStatsToFile(true, true);
+    }
+
+    public static IUsageStats getService() {
+        if (sService != null) {
+            return sService;
+        }
+        IBinder b = ServiceManager.getService(SERVICE_NAME);
+        sService = asInterface(b);
+        return sService;
+    }
+    
+    public void noteResumeComponent(ComponentName componentName) {
+        enforceCallingPermission();
+        String pkgName;
+        synchronized (mStatsLock) {
+            if ((componentName == null) ||
+                    ((pkgName = componentName.getPackageName()) == null)) {
+                return;
+            }
+            
+            final boolean samePackage = pkgName.equals(mLastResumedPkg);
+            if (mIsResumed) {
+                if (mLastResumedPkg != null) {
+                    // We last resumed some other package...  just pause it now
+                    // to recover.
+                    if (REPORT_UNEXPECTED) Slog.i(TAG, "Unexpected resume of " + pkgName
+                            + " while already resumed in " + mLastResumedPkg);
+                    PkgUsageStatsExtended pus = mStats.get(mLastResumedPkg);
+                    if (pus != null) {
+                        pus.updatePause();
+                    }
+                }
+            }
+            
+            final boolean sameComp = samePackage
+                    && componentName.getClassName().equals(mLastResumedComp);
+            
+            mIsResumed = true;
+            mLastResumedPkg = pkgName;
+            mLastResumedComp = componentName.getClassName();
+            
+            if (localLOGV) Slog.i(TAG, "started component:" + pkgName);
+            PkgUsageStatsExtended pus = mStats.get(pkgName);
+            if (pus == null) {
+                pus = new PkgUsageStatsExtended();
+                mStats.put(pkgName, pus);
+            }
+            pus.updateResume(mLastResumedComp, !samePackage);
+            if (!sameComp) {
+                pus.addLaunchCount(mLastResumedComp);
+            }
+
+            Map<String, Long> componentResumeTimes = mLastResumeTimes.get(pkgName);
+            if (componentResumeTimes == null) {
+                componentResumeTimes = new HashMap<String, Long>();
+                mLastResumeTimes.put(pkgName, componentResumeTimes);
+            }
+            componentResumeTimes.put(mLastResumedComp, System.currentTimeMillis());
+        }
+    }
+
+    public void notePauseComponent(ComponentName componentName) {
+        enforceCallingPermission();
+        
+        synchronized (mStatsLock) {
+            String pkgName;
+            if ((componentName == null) ||
+                    ((pkgName = componentName.getPackageName()) == null)) {
+                return;
+            }
+            if (!mIsResumed) {
+                if (REPORT_UNEXPECTED) Slog.i(TAG, "Something wrong here, didn't expect "
+                        + pkgName + " to be paused");
+                return;
+            }
+            mIsResumed = false;
+            
+            if (localLOGV) Slog.i(TAG, "paused component:"+pkgName);
+        
+            PkgUsageStatsExtended pus = mStats.get(pkgName);
+            if (pus == null) {
+                // Weird some error here
+                Slog.i(TAG, "No package stats for pkg:"+pkgName);
+                return;
+            }
+            pus.updatePause();
+        }
+        
+        // Persist current data to file if needed.
+        writeStatsToFile(false, false);
+    }
+    
+    public void noteLaunchTime(ComponentName componentName, int millis) {
+        enforceCallingPermission();
+        String pkgName;
+        if ((componentName == null) ||
+                ((pkgName = componentName.getPackageName()) == null)) {
+            return;
+        }
+        
+        // Persist current data to file if needed.
+        writeStatsToFile(false, false);
+        
+        synchronized (mStatsLock) {
+            PkgUsageStatsExtended pus = mStats.get(pkgName);
+            if (pus != null) {
+                pus.addLaunchTime(componentName.getClassName(), millis);
+            }
+        }
+    }
+    
+    public void enforceCallingPermission() {
+        if (Binder.getCallingPid() == Process.myPid()) {
+            return;
+        }
+        mContext.enforcePermission(android.Manifest.permission.UPDATE_DEVICE_STATS,
+                Binder.getCallingPid(), Binder.getCallingUid(), null);
+    }
+    
+    public PkgUsageStats getPkgUsageStats(ComponentName componentName) {
+        mContext.enforceCallingOrSelfPermission(
+                android.Manifest.permission.PACKAGE_USAGE_STATS, null);
+        String pkgName;
+        if ((componentName == null) ||
+                ((pkgName = componentName.getPackageName()) == null)) {
+            return null;
+        }
+        synchronized (mStatsLock) {
+            PkgUsageStatsExtended pus = mStats.get(pkgName);
+            Map<String, Long> lastResumeTimes = mLastResumeTimes.get(pkgName);
+            if (pus == null && lastResumeTimes == null) {
+                return null;
+            }
+            int launchCount = pus != null ? pus.mLaunchCount : 0;
+            long usageTime = pus != null ? pus.mUsageTime : 0;
+            return new PkgUsageStats(pkgName, launchCount, usageTime, lastResumeTimes);
+        }
+    }
+    
+    public PkgUsageStats[] getAllPkgUsageStats() {
+        mContext.enforceCallingOrSelfPermission(
+                android.Manifest.permission.PACKAGE_USAGE_STATS, null);
+        synchronized (mStatsLock) {
+            int size = mLastResumeTimes.size();
+            if (size <= 0) {
+                return null;
+            }
+            PkgUsageStats retArr[] = new PkgUsageStats[size];
+            int i = 0;
+            for (Map.Entry<String, Map<String, Long>> entry : mLastResumeTimes.entrySet()) {
+                String pkg = entry.getKey();
+                long usageTime = 0;
+                int launchCount = 0;
+
+                PkgUsageStatsExtended pus = mStats.get(pkg);
+                if (pus != null) {
+                    usageTime = pus.mUsageTime;
+                    launchCount = pus.mLaunchCount;
+                }
+                retArr[i] = new PkgUsageStats(pkg, launchCount, usageTime, entry.getValue());
+                i++;
+            }
+            return retArr;
+        }
+    }
+    
+    static byte[] readFully(FileInputStream stream) throws java.io.IOException {
+        int pos = 0;
+        int avail = stream.available();
+        byte[] data = new byte[avail];
+        while (true) {
+            int amt = stream.read(data, pos, data.length-pos);
+            if (amt <= 0) {
+                return data;
+            }
+            pos += amt;
+            avail = stream.available();
+            if (avail > data.length-pos) {
+                byte[] newData = new byte[pos+avail];
+                System.arraycopy(data, 0, newData, 0, pos);
+                data = newData;
+            }
+        }
+    }
+    
+    private void collectDumpInfoFLOCK(PrintWriter pw, boolean isCompactOutput,
+            boolean deleteAfterPrint, HashSet<String> packages) {
+        List<String> fileList = getUsageStatsFileListFLOCK();
+        if (fileList == null) {
+            return;
+        }
+        Collections.sort(fileList);
+        for (String file : fileList) {
+            if (deleteAfterPrint && file.equalsIgnoreCase(mFileLeaf)) {
+                // In this mode we don't print the current day's stats, since
+                // they are incomplete.
+                continue;
+            }
+            File dFile = new File(mDir, file);
+            String dateStr = file.substring(FILE_PREFIX.length());
+            try {
+                Parcel in = getParcelForFile(dFile);
+                collectDumpInfoFromParcelFLOCK(in, pw, dateStr, isCompactOutput,
+                        packages);
+                if (deleteAfterPrint) {
+                    // Delete old file after collecting info only for checkin requests
+                    dFile.delete();
+                }
+            } catch (FileNotFoundException e) {
+                Slog.w(TAG, "Failed with "+e+" when collecting dump info from file : " + file);
+                return;
+            } catch (IOException e) {
+                Slog.w(TAG, "Failed with "+e+" when collecting dump info from file : "+file);
+            }      
+        }
+    }
+    
+    private void collectDumpInfoFromParcelFLOCK(Parcel in, PrintWriter pw,
+            String date, boolean isCompactOutput, HashSet<String> packages) {
+        StringBuilder sb = new StringBuilder(512);
+        if (isCompactOutput) {
+            sb.append("D:");
+            sb.append(CHECKIN_VERSION);
+            sb.append(',');
+        } else {
+            sb.append("Date: ");
+        }
+        
+        sb.append(date);
+        
+        int vers = in.readInt();
+        if (vers != VERSION) {
+            sb.append(" (old data version)");
+            pw.println(sb.toString());
+            return;
+        }
+        
+        pw.println(sb.toString());
+        int N = in.readInt();
+        
+        while (N > 0) {
+            N--;
+            String pkgName = in.readString();
+            if (pkgName == null) {
+                break;
+            }
+            sb.setLength(0);
+            PkgUsageStatsExtended pus = new PkgUsageStatsExtended(in);
+            if (packages != null && !packages.contains(pkgName)) {
+                // This package has not been requested -- don't print
+                // anything for it.
+            } else if (isCompactOutput) {
+                sb.append("P:");
+                sb.append(pkgName);
+                sb.append(',');
+                sb.append(pus.mLaunchCount);
+                sb.append(',');
+                sb.append(pus.mUsageTime);
+                sb.append('\n');
+                final int NC = pus.mLaunchTimes.size();
+                if (NC > 0) {
+                    for (Map.Entry<String, TimeStats> ent : pus.mLaunchTimes.entrySet()) {
+                        sb.append("A:");
+                        String activity = ent.getKey();
+                        if (activity.startsWith(pkgName)) {
+                            sb.append('*');
+                            sb.append(activity.substring(
+                                    pkgName.length(), activity.length()));
+                        } else {
+                            sb.append(activity);
+                        }
+                        TimeStats times = ent.getValue();
+                        sb.append(',');
+                        sb.append(times.count);
+                        for (int i=0; i<NUM_LAUNCH_TIME_BINS; i++) {
+                            sb.append(",");
+                            sb.append(times.times[i]);
+                        }
+                        sb.append('\n');
+                    }
+                }
+                
+            } else {
+                sb.append("  ");
+                sb.append(pkgName);
+                sb.append(": ");
+                sb.append(pus.mLaunchCount);
+                sb.append(" times, ");
+                sb.append(pus.mUsageTime);
+                sb.append(" ms");
+                sb.append('\n');
+                final int NC = pus.mLaunchTimes.size();
+                if (NC > 0) {
+                    for (Map.Entry<String, TimeStats> ent : pus.mLaunchTimes.entrySet()) {
+                        sb.append("    ");
+                        sb.append(ent.getKey());
+                        TimeStats times = ent.getValue();
+                        sb.append(": ");
+                        sb.append(times.count);
+                        sb.append(" starts");
+                        int lastBin = 0;
+                        for (int i=0; i<NUM_LAUNCH_TIME_BINS-1; i++) {
+                            if (times.times[i] != 0) {
+                                sb.append(", ");
+                                sb.append(lastBin);
+                                sb.append('-');
+                                sb.append(LAUNCH_TIME_BINS[i]);
+                                sb.append("ms=");
+                                sb.append(times.times[i]);
+                            }
+                            lastBin = LAUNCH_TIME_BINS[i];
+                        }
+                        if (times.times[NUM_LAUNCH_TIME_BINS-1] != 0) {
+                            sb.append(", ");
+                            sb.append(">=");
+                            sb.append(lastBin);
+                            sb.append("ms=");
+                            sb.append(times.times[NUM_LAUNCH_TIME_BINS-1]);
+                        }
+                        sb.append('\n');
+                    }
+                }
+            }
+            
+            pw.write(sb.toString());
+        }
+    }
+    
+    /**
+     * Searches array of arguments for the specified string
+     * @param args array of argument strings
+     * @param value value to search for
+     * @return true if the value is contained in the array
+     */
+    private static boolean scanArgs(String[] args, String value) {
+        if (args != null) {
+            for (String arg : args) {
+                if (value.equals(arg)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+    
+    /**
+     * Searches array of arguments for the specified string's data
+     * @param args array of argument strings
+     * @param value value to search for
+     * @return the string of data after the arg, or null if there is none
+     */
+    private static String scanArgsData(String[] args, String value) {
+        if (args != null) {
+            final int N = args.length;
+            for (int i=0; i<N; i++) {
+                if (value.equals(args[i])) {
+                    i++;
+                    return i < N ? args[i] : null;
+                }
+            }
+        }
+        return null;
+    }
+    
+    @Override
+    /*
+     * The data persisted to file is parsed and the stats are computed. 
+     */
+    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        if (mContext.checkCallingPermission(android.Manifest.permission.DUMP)
+                != PackageManager.PERMISSION_GRANTED) {
+            pw.println("Permission Denial: can't dump UsageStats from from pid="
+                    + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid()
+                    + " without permission " + android.Manifest.permission.DUMP);
+            return;
+        }
+
+        final boolean isCheckinRequest = scanArgs(args, "--checkin");
+        final boolean isCompactOutput = isCheckinRequest || scanArgs(args, "-c");
+        final boolean deleteAfterPrint = isCheckinRequest || scanArgs(args, "-d");
+        final String rawPackages = scanArgsData(args, "--packages");
+        
+        // Make sure the current stats are written to the file.  This
+        // doesn't need to be done if we are deleting files after printing,
+        // since it that case we won't print the current stats.
+        if (!deleteAfterPrint) {
+            writeStatsToFile(true, false);
+        }
+        
+        HashSet<String> packages = null;
+        if (rawPackages != null) {
+            if (!"*".equals(rawPackages)) {
+                // A * is a wildcard to show all packages.
+                String[] names = rawPackages.split(",");
+                for (String n : names) {
+                    if (packages == null) {
+                        packages = new HashSet<String>();
+                    }
+                    packages.add(n);
+                }
+            }
+        } else if (isCheckinRequest) {
+            // If checkin doesn't specify any packages, then we simply won't
+            // show anything.
+            Slog.w(TAG, "Checkin without packages");
+            return;
+        }
+        
+        synchronized (mFileLock) {
+            collectDumpInfoFLOCK(pw, isCompactOutput, deleteAfterPrint, packages);
+        }
+    }
+
+}
diff --git a/src/frameworks/base/services/java/com/android/server/pm/Installer.java b/src/frameworks/base/services/java/com/android/server/pm/Installer.java
new file mode 100644
index 0000000..48004bb
--- /dev/null
+++ b/src/frameworks/base/services/java/com/android/server/pm/Installer.java
@@ -0,0 +1,402 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.pm;
+
+import android.content.pm.PackageStats;
+import android.net.LocalSocket;
+import android.net.LocalSocketAddress;
+import android.util.Slog;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+class Installer {
+    private static final String TAG = "Installer";
+
+    private static final boolean LOCAL_DEBUG = false;
+
+    InputStream mIn;
+
+    OutputStream mOut;
+
+    LocalSocket mSocket;
+
+    byte buf[] = new byte[1024];
+
+    int buflen = 0;
+
+    private boolean connect() {
+        if (mSocket != null) {
+            return true;
+        }
+        Slog.i(TAG, "connecting...");
+        try {
+            mSocket = new LocalSocket();
+
+            LocalSocketAddress address = new LocalSocketAddress("installd",
+                    LocalSocketAddress.Namespace.RESERVED);
+
+            mSocket.connect(address);
+
+            mIn = mSocket.getInputStream();
+            mOut = mSocket.getOutputStream();
+        } catch (IOException ex) {
+            disconnect();
+            return false;
+        }
+        return true;
+    }
+
+    private void disconnect() {
+        Slog.i(TAG, "disconnecting...");
+        try {
+            if (mSocket != null)
+                mSocket.close();
+        } catch (IOException ex) {
+        }
+        try {
+            if (mIn != null)
+                mIn.close();
+        } catch (IOException ex) {
+        }
+        try {
+            if (mOut != null)
+                mOut.close();
+        } catch (IOException ex) {
+        }
+        mSocket = null;
+        mIn = null;
+        mOut = null;
+    }
+
+    private boolean readBytes(byte buffer[], int len) {
+        int off = 0, count;
+        if (len < 0)
+            return false;
+        while (off != len) {
+            try {
+                count = mIn.read(buffer, off, len - off);
+                if (count <= 0) {
+                    Slog.e(TAG, "read error " + count);
+                    break;
+                }
+                off += count;
+            } catch (IOException ex) {
+                Slog.e(TAG, "read exception");
+                break;
+            }
+        }
+        if (LOCAL_DEBUG) {
+            Slog.i(TAG, "read " + len + " bytes");
+        }
+        if (off == len)
+            return true;
+        disconnect();
+        return false;
+    }
+
+    private boolean readReply() {
+        int len;
+        buflen = 0;
+        if (!readBytes(buf, 2))
+            return false;
+        len = (((int) buf[0]) & 0xff) | ((((int) buf[1]) & 0xff) << 8);
+        if ((len < 1) || (len > 1024)) {
+            Slog.e(TAG, "invalid reply length (" + len + ")");
+            disconnect();
+            return false;
+        }
+        if (!readBytes(buf, len))
+            return false;
+        buflen = len;
+        return true;
+    }
+
+    private boolean writeCommand(String _cmd) {
+        byte[] cmd = _cmd.getBytes();
+        int len = cmd.length;
+        if ((len < 1) || (len > 1024))
+            return false;
+        buf[0] = (byte) (len & 0xff);
+        buf[1] = (byte) ((len >> 8) & 0xff);
+        try {
+            mOut.write(buf, 0, 2);
+            mOut.write(cmd, 0, len);
+        } catch (IOException ex) {
+            Slog.e(TAG, "write error");
+            disconnect();
+            return false;
+        }
+        return true;
+    }
+
+    private synchronized String transaction(String cmd) {
+        if (!connect()) {
+            Slog.e(TAG, "connection failed");
+            return "-1";
+        }
+
+        if (!writeCommand(cmd)) {
+            /*
+             * If installd died and restarted in the background (unlikely but
+             * possible) we'll fail on the next write (this one). Try to
+             * reconnect and write the command one more time before giving up.
+             */
+            Slog.e(TAG, "write command failed? reconnect!");
+            if (!connect() || !writeCommand(cmd)) {
+                return "-1";
+            }
+        }
+        if (LOCAL_DEBUG) {
+            Slog.i(TAG, "send: '" + cmd + "'");
+        }
+        if (readReply()) {
+            String s = new String(buf, 0, buflen);
+            if (LOCAL_DEBUG) {
+                Slog.i(TAG, "recv: '" + s + "'");
+            }
+            return s;
+        } else {
+            if (LOCAL_DEBUG) {
+                Slog.i(TAG, "fail");
+            }
+            return "-1";
+        }
+    }
+
+    private int execute(String cmd) {
+        String res = transaction(cmd);
+        try {
+            return Integer.parseInt(res);
+        } catch (NumberFormatException ex) {
+            return -1;
+        }
+    }
+
+    public int install(String name, int uid, int gid) {
+        StringBuilder builder = new StringBuilder("install");
+        builder.append(' ');
+        builder.append(name);
+        builder.append(' ');
+        builder.append(uid);
+        builder.append(' ');
+        builder.append(gid);
+        return execute(builder.toString());
+    }
+
+    public int dexopt(String apkPath, int uid, boolean isPublic) {
+        StringBuilder builder = new StringBuilder("dexopt");
+        builder.append(' ');
+        builder.append(apkPath);
+        builder.append(' ');
+        builder.append(uid);
+        builder.append(isPublic ? " 1" : " 0");
+        return execute(builder.toString());
+    }
+
+    public int movedex(String srcPath, String dstPath) {
+        StringBuilder builder = new StringBuilder("movedex");
+        builder.append(' ');
+        builder.append(srcPath);
+        builder.append(' ');
+        builder.append(dstPath);
+        return execute(builder.toString());
+    }
+
+    public int rmdex(String codePath) {
+        StringBuilder builder = new StringBuilder("rmdex");
+        builder.append(' ');
+        builder.append(codePath);
+        return execute(builder.toString());
+    }
+
+    public int remove(String name, int userId) {
+        StringBuilder builder = new StringBuilder("remove");
+        builder.append(' ');
+        builder.append(name);
+        builder.append(' ');
+        builder.append(userId);
+        return execute(builder.toString());
+    }
+
+    public int rename(String oldname, String newname) {
+        StringBuilder builder = new StringBuilder("rename");
+        builder.append(' ');
+        builder.append(oldname);
+        builder.append(' ');
+        builder.append(newname);
+        return execute(builder.toString());
+    }
+
+    public int fixUid(String name, int uid, int gid) {
+        StringBuilder builder = new StringBuilder("fixuid");
+        builder.append(' ');
+        builder.append(name);
+        builder.append(' ');
+        builder.append(uid);
+        builder.append(' ');
+        builder.append(gid);
+        return execute(builder.toString());
+    }
+
+    public int deleteCacheFiles(String name) {
+        StringBuilder builder = new StringBuilder("rmcache");
+        builder.append(' ');
+        builder.append(name);
+        return execute(builder.toString());
+    }
+
+    public int createUserData(String name, int uid, int userId) {
+        StringBuilder builder = new StringBuilder("mkuserdata");
+        builder.append(' ');
+        builder.append(name);
+        builder.append(' ');
+        builder.append(uid);
+        builder.append(' ');
+        builder.append(userId);
+        return execute(builder.toString());
+    }
+
+    public int removeUserDataDirs(int userId) {
+        StringBuilder builder = new StringBuilder("rmuser");
+        builder.append(' ');
+        builder.append(userId);
+        return execute(builder.toString());
+    }
+
+    public int clearUserData(String name, int userId) {
+        StringBuilder builder = new StringBuilder("rmuserdata");
+        builder.append(' ');
+        builder.append(name);
+        builder.append(' ');
+        builder.append(userId);
+        return execute(builder.toString());
+    }
+
+    /**
+     * Clone all the package data directories from srcUserId to targetUserId. If copyData is true,
+     * some of the data is also copied, otherwise just empty directories are created with the
+     * correct access rights.
+     * @param srcUserId user to copy the data directories from
+     * @param targetUserId user to copy the data directories to
+     * @param copyData whether the data itself is to be copied. If false, empty directories are
+     * created.
+     * @return success/error code
+     */
+    public int cloneUserData(int srcUserId, int targetUserId, boolean copyData) {
+        StringBuilder builder = new StringBuilder("cloneuserdata");
+        builder.append(' ');
+        builder.append(srcUserId);
+        builder.append(' ');
+        builder.append(targetUserId);
+        builder.append(' ');
+        builder.append(copyData ? '1' : '0');
+        return execute(builder.toString());
+    }
+
+    public boolean ping() {
+        if (execute("ping") < 0) {
+            return false;
+        } else {
+            return true;
+        }
+    }
+
+    public int freeCache(long freeStorageSize) {
+        StringBuilder builder = new StringBuilder("freecache");
+        builder.append(' ');
+        builder.append(String.valueOf(freeStorageSize));
+        return execute(builder.toString());
+    }
+
+    /*
+     * @param packagePathSuffix The name of the path relative to install
+     * directory. Say if the path name is /data/app/com.test-1.apk, the package
+     * suffix path will be com.test-1
+     */
+    public int setForwardLockPerm(String packagePathSuffix, int gid) {
+        StringBuilder builder = new StringBuilder("protect");
+        builder.append(' ');
+        builder.append(packagePathSuffix);
+        builder.append(' ');
+        builder.append(gid);
+        return execute(builder.toString());
+    }
+
+    public int getSizeInfo(String pkgName, String apkPath, String fwdLockApkPath,
+            String asecPath, PackageStats pStats) {
+        StringBuilder builder = new StringBuilder("getsize");
+        builder.append(' ');
+        builder.append(pkgName);
+        builder.append(' ');
+        builder.append(apkPath);
+        builder.append(' ');
+        builder.append(fwdLockApkPath != null ? fwdLockApkPath : "!");
+        builder.append(' ');
+        builder.append(asecPath != null ? asecPath : "!");
+
+        String s = transaction(builder.toString());
+        String res[] = s.split(" ");
+
+        if ((res == null) || (res.length != 5)) {
+            return -1;
+        }
+        try {
+            pStats.codeSize = Long.parseLong(res[1]);
+            pStats.dataSize = Long.parseLong(res[2]);
+            pStats.cacheSize = Long.parseLong(res[3]);
+            pStats.externalCodeSize = Long.parseLong(res[4]);
+            return Integer.parseInt(res[0]);
+        } catch (NumberFormatException e) {
+            return -1;
+        }
+    }
+
+    public int moveFiles() {
+        return execute("movefiles");
+    }
+
+    public int linkNativeLibraryDirectory(String dataPath, String nativeLibPath) {
+        if (dataPath == null) {
+            Slog.e(TAG, "unlinkNativeLibraryDirectory dataPath is null");
+            return -1;
+        } else if (nativeLibPath == null) {
+            Slog.e(TAG, "unlinkNativeLibraryDirectory nativeLibPath is null");
+            return -1;
+        }
+
+        StringBuilder builder = new StringBuilder("linklib ");
+        builder.append(dataPath);
+        builder.append(' ');
+        builder.append(nativeLibPath);
+
+        return execute(builder.toString());
+    }
+
+    public int unlinkNativeLibraryDirectory(String dataPath) {
+        if (dataPath == null) {
+            Slog.e(TAG, "unlinkNativeLibraryDirectory dataPath is null");
+            return -1;
+        }
+
+        StringBuilder builder = new StringBuilder("unlinklib ");
+        builder.append(dataPath);
+
+        return execute(builder.toString());
+    }
+}
diff --git a/src/frameworks/base/services/java/com/android/server/pm/UserManager.java b/src/frameworks/base/services/java/com/android/server/pm/UserManager.java
new file mode 100644
index 0000000..4e9e666
--- /dev/null
+++ b/src/frameworks/base/services/java/com/android/server/pm/UserManager.java
@@ -0,0 +1,465 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.pm;
+
+import com.android.internal.util.ArrayUtils;
+import com.android.internal.util.FastXmlSerializer;
+
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.UserInfo;
+import android.os.Environment;
+import android.os.FileUtils;
+import android.os.SystemClock;
+import android.os.UserId;
+import android.util.Log;
+import android.util.Slog;
+import android.util.SparseArray;
+import android.util.Xml;
+
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlSerializer;
+
+public class UserManager {
+    private static final String TAG_NAME = "name";
+
+    private static final String ATTR_FLAGS = "flags";
+
+    private static final String ATTR_ID = "id";
+
+    private static final String TAG_USERS = "users";
+
+    private static final String TAG_USER = "user";
+
+    private static final String LOG_TAG = "UserManager";
+
+    private static final String USER_INFO_DIR = "system" + File.separator + "users";
+    private static final String USER_LIST_FILENAME = "userlist.xml";
+
+    private SparseArray<UserInfo> mUsers = new SparseArray<UserInfo>();
+
+    private final File mUsersDir;
+    private final File mUserListFile;
+    private int[] mUserIds;
+
+    private Installer mInstaller;
+    private File mBaseUserPath;
+
+    /**
+     * Available for testing purposes.
+     */
+    UserManager(File dataDir, File baseUserPath) {
+        mUsersDir = new File(dataDir, USER_INFO_DIR);
+        mUsersDir.mkdirs();
+        // Make zeroth user directory, for services to migrate their files to that location
+        File userZeroDir = new File(mUsersDir, "0");
+        userZeroDir.mkdirs();
+        mBaseUserPath = baseUserPath;
+        FileUtils.setPermissions(mUsersDir.toString(),
+                FileUtils.S_IRWXU|FileUtils.S_IRWXG
+                |FileUtils.S_IROTH|FileUtils.S_IXOTH,
+                -1, -1);
+        mUserListFile = new File(mUsersDir, USER_LIST_FILENAME);
+        readUserList();
+    }
+
+    public UserManager(Installer installer, File baseUserPath) {
+        this(Environment.getDataDirectory(), baseUserPath);
+        mInstaller = installer;
+    }
+
+    public List<UserInfo> getUsers() {
+        synchronized (mUsers) {
+            ArrayList<UserInfo> users = new ArrayList<UserInfo>(mUsers.size());
+            for (int i = 0; i < mUsers.size(); i++) {
+                users.add(mUsers.valueAt(i));
+            }
+            return users;
+        }
+    }
+
+    public UserInfo getUser(int userId) {
+        synchronized (mUsers) {
+            UserInfo info = mUsers.get(userId);
+            return info;
+        }
+    }
+
+    public boolean exists(int userId) {
+        synchronized (mUsers) {
+            return ArrayUtils.contains(mUserIds, userId);
+        }
+    }
+
+    public void updateUserName(int userId, String name) {
+        synchronized (mUsers) {
+            UserInfo info = mUsers.get(userId);
+            if (name != null && !name.equals(info.name)) {
+                info.name = name;
+                writeUserLocked(info);
+            }
+        }
+    }
+
+    /**
+     * Returns an array of user ids. This array is cached here for quick access, so do not modify or
+     * cache it elsewhere.
+     * @return the array of user ids.
+     */
+    int[] getUserIds() {
+        return mUserIds;
+    }
+
+    private void readUserList() {
+        synchronized (mUsers) {
+            readUserListLocked();
+        }
+    }
+
+    private void readUserListLocked() {
+        if (!mUserListFile.exists()) {
+            fallbackToSingleUserLocked();
+            return;
+        }
+        FileInputStream fis = null;
+        try {
+            fis = new FileInputStream(mUserListFile);
+            XmlPullParser parser = Xml.newPullParser();
+            parser.setInput(fis, null);
+            int type;
+            while ((type = parser.next()) != XmlPullParser.START_TAG
+                    && type != XmlPullParser.END_DOCUMENT) {
+                ;
+            }
+
+            if (type != XmlPullParser.START_TAG) {
+                Slog.e(LOG_TAG, "Unable to read user list");
+                fallbackToSingleUserLocked();
+                return;
+            }
+
+            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT) {
+                if (type == XmlPullParser.START_TAG && parser.getName().equals(TAG_USER)) {
+                    String id = parser.getAttributeValue(null, ATTR_ID);
+                    UserInfo user = readUser(Integer.parseInt(id));
+                    if (user != null) {
+                        mUsers.put(user.id, user);
+                    }
+                }
+            }
+            updateUserIdsLocked();
+        } catch (IOException ioe) {
+            fallbackToSingleUserLocked();
+        } catch (XmlPullParserException pe) {
+            fallbackToSingleUserLocked();
+        } finally {
+            if (fis != null) {
+                try {
+                    fis.close();
+                } catch (IOException e) {
+                }
+            }
+        }
+    }
+
+    private void fallbackToSingleUserLocked() {
+        // Create the primary user
+        UserInfo primary = new UserInfo(0, "Primary",
+                UserInfo.FLAG_ADMIN | UserInfo.FLAG_PRIMARY);
+        mUsers.put(0, primary);
+        updateUserIdsLocked();
+
+        writeUserListLocked();
+        writeUserLocked(primary);
+    }
+
+    /*
+     * Writes the user file in this format:
+     *
+     * <user flags="20039023" id="0">
+     *   <name>Primary</name>
+     * </user>
+     */
+    private void writeUserLocked(UserInfo userInfo) {
+        FileOutputStream fos = null;
+        try {
+            final File mUserFile = new File(mUsersDir, userInfo.id + ".xml");
+            fos = new FileOutputStream(mUserFile);
+            final BufferedOutputStream bos = new BufferedOutputStream(fos);
+
+            // XmlSerializer serializer = XmlUtils.serializerInstance();
+            final XmlSerializer serializer = new FastXmlSerializer();
+            serializer.setOutput(bos, "utf-8");
+            serializer.startDocument(null, true);
+            serializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", true);
+
+            serializer.startTag(null, TAG_USER);
+            serializer.attribute(null, ATTR_ID, Integer.toString(userInfo.id));
+            serializer.attribute(null, ATTR_FLAGS, Integer.toString(userInfo.flags));
+
+            serializer.startTag(null, TAG_NAME);
+            serializer.text(userInfo.name);
+            serializer.endTag(null, TAG_NAME);
+
+            serializer.endTag(null, TAG_USER);
+
+            serializer.endDocument();
+        } catch (IOException ioe) {
+            Slog.e(LOG_TAG, "Error writing user info " + userInfo.id + "\n" + ioe);
+        } finally {
+            if (fos != null) {
+                try {
+                    fos.close();
+                } catch (IOException ioe) {
+                }
+            }
+        }
+    }
+
+    /*
+     * Writes the user list file in this format:
+     *
+     * <users>
+     *   <user id="0"></user>
+     *   <user id="2"></user>
+     * </users>
+     */
+    private void writeUserListLocked() {
+        FileOutputStream fos = null;
+        try {
+            fos = new FileOutputStream(mUserListFile);
+            final BufferedOutputStream bos = new BufferedOutputStream(fos);
+
+            // XmlSerializer serializer = XmlUtils.serializerInstance();
+            final XmlSerializer serializer = new FastXmlSerializer();
+            serializer.setOutput(bos, "utf-8");
+            serializer.startDocument(null, true);
+            serializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", true);
+
+            serializer.startTag(null, TAG_USERS);
+
+            for (int i = 0; i < mUsers.size(); i++) {
+                UserInfo user = mUsers.valueAt(i);
+                serializer.startTag(null, TAG_USER);
+                serializer.attribute(null, ATTR_ID, Integer.toString(user.id));
+                serializer.endTag(null, TAG_USER);
+            }
+
+            serializer.endTag(null, TAG_USERS);
+
+            serializer.endDocument();
+        } catch (IOException ioe) {
+            Slog.e(LOG_TAG, "Error writing user list");
+        } finally {
+            if (fos != null) {
+                try {
+                    fos.close();
+                } catch (IOException ioe) {
+                }
+            }
+        }
+    }
+
+    private UserInfo readUser(int id) {
+        int flags = 0;
+        String name = null;
+
+        FileInputStream fis = null;
+        try {
+            File userFile = new File(mUsersDir, Integer.toString(id) + ".xml");
+            fis = new FileInputStream(userFile);
+            XmlPullParser parser = Xml.newPullParser();
+            parser.setInput(fis, null);
+            int type;
+            while ((type = parser.next()) != XmlPullParser.START_TAG
+                    && type != XmlPullParser.END_DOCUMENT) {
+                ;
+            }
+
+            if (type != XmlPullParser.START_TAG) {
+                Slog.e(LOG_TAG, "Unable to read user " + id);
+                return null;
+            }
+
+            if (type == XmlPullParser.START_TAG && parser.getName().equals(TAG_USER)) {
+                String storedId = parser.getAttributeValue(null, ATTR_ID);
+                if (Integer.parseInt(storedId) != id) {
+                    Slog.e(LOG_TAG, "User id does not match the file name");
+                    return null;
+                }
+                String flagString = parser.getAttributeValue(null, ATTR_FLAGS);
+                flags = Integer.parseInt(flagString);
+
+                while ((type = parser.next()) != XmlPullParser.START_TAG
+                        && type != XmlPullParser.END_DOCUMENT) {
+                }
+                if (type == XmlPullParser.START_TAG && parser.getName().equals(TAG_NAME)) {
+                    type = parser.next();
+                    if (type == XmlPullParser.TEXT) {
+                        name = parser.getText();
+                    }
+                }
+            }
+
+            UserInfo userInfo = new UserInfo(id, name, flags);
+            return userInfo;
+
+        } catch (IOException ioe) {
+        } catch (XmlPullParserException pe) {
+        } finally {
+            if (fis != null) {
+                try {
+                    fis.close();
+                } catch (IOException e) {
+                }
+            }
+        }
+        return null;
+    }
+
+    public UserInfo createUser(String name, int flags) {
+        int userId = getNextAvailableId();
+        UserInfo userInfo = new UserInfo(userId, name, flags);
+        File userPath = new File(mBaseUserPath, Integer.toString(userId));
+        if (!createPackageFolders(userId, userPath)) {
+            return null;
+        }
+        synchronized (mUsers) {
+            mUsers.put(userId, userInfo);
+            writeUserListLocked();
+            writeUserLocked(userInfo);
+            updateUserIdsLocked();
+        }
+        return userInfo;
+    }
+
+    /**
+     * Removes a user and all data directories created for that user. This method should be called
+     * after the user's processes have been terminated.
+     * @param id the user's id
+     */
+    public boolean removeUser(int id) {
+        synchronized (mUsers) {
+            return removeUserLocked(id);
+        }
+    }
+
+    private boolean removeUserLocked(int id) {
+        // Remove from the list
+        UserInfo userInfo = mUsers.get(id);
+        if (userInfo != null) {
+            // Remove this user from the list
+            mUsers.remove(id);
+            // Remove user file
+            File userFile = new File(mUsersDir, id + ".xml");
+            userFile.delete();
+            // Update the user list
+            writeUserListLocked();
+            updateUserIdsLocked();
+            return true;
+        }
+        return false;
+    }
+
+    public void installPackageForAllUsers(String packageName, int uid) {
+        for (int userId : mUserIds) {
+            // Don't do it for the primary user, it will become recursive.
+            if (userId == 0)
+                continue;
+            mInstaller.createUserData(packageName, UserId.getUid(userId, uid),
+                    userId);
+        }
+    }
+
+    public void clearUserDataForAllUsers(String packageName) {
+        for (int userId : mUserIds) {
+            // Don't do it for the primary user, it will become recursive.
+            if (userId == 0)
+                continue;
+            mInstaller.clearUserData(packageName, userId);
+        }
+    }
+
+    public void removePackageForAllUsers(String packageName) {
+        for (int userId : mUserIds) {
+            // Don't do it for the primary user, it will become recursive.
+            if (userId == 0)
+                continue;
+            mInstaller.remove(packageName, userId);
+        }
+    }
+
+    /**
+     * Caches the list of user ids in an array, adjusting the array size when necessary.
+     */
+    private void updateUserIdsLocked() {
+        if (mUserIds == null || mUserIds.length != mUsers.size()) {
+            mUserIds = new int[mUsers.size()];
+        }
+        for (int i = 0; i < mUsers.size(); i++) {
+            mUserIds[i] = mUsers.keyAt(i);
+        }
+    }
+
+    /**
+     * Returns the next available user id, filling in any holes in the ids.
+     * TODO: May not be a good idea to recycle ids, in case it results in confusion
+     * for data and battery stats collection, or unexpected cross-talk.
+     * @return
+     */
+    private int getNextAvailableId() {
+        int i = 0;
+        while (i < Integer.MAX_VALUE) {
+            if (mUsers.indexOfKey(i) < 0) {
+                break;
+            }
+            i++;
+        }
+        return i;
+    }
+
+    private boolean createPackageFolders(int id, File userPath) {
+        // mInstaller may not be available for unit-tests.
+        if (mInstaller == null) return true;
+
+        // Create the user path
+        userPath.mkdir();
+        FileUtils.setPermissions(userPath.toString(), FileUtils.S_IRWXU | FileUtils.S_IRWXG
+                | FileUtils.S_IXOTH, -1, -1);
+
+        mInstaller.cloneUserData(0, id, false);
+
+        return true;
+    }
+
+    boolean removePackageFolders(int id) {
+        // mInstaller may not be available for unit-tests.
+        if (mInstaller == null) return true;
+
+        mInstaller.removeUserDataDirs(id);
+        return true;
+    }
+}
diff --git a/src/frameworks/base/services/java/com/android/server/wm/WindowManagerService.java b/src/frameworks/base/services/java/com/android/server/wm/WindowManagerService.java
new file mode 100755
index 0000000..7011343
--- /dev/null
+++ b/src/frameworks/base/services/java/com/android/server/wm/WindowManagerService.java
@@ -0,0 +1,10154 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.wm;
+
+import static android.view.WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW;
+import static android.view.WindowManager.LayoutParams.FIRST_SUB_WINDOW;
+import static android.view.WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
+import static android.view.WindowManager.LayoutParams.FLAG_DIM_BEHIND;
+import static android.view.WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
+import static android.view.WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
+import static android.view.WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
+import static android.view.WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
+import static android.view.WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
+import static android.view.WindowManager.LayoutParams.LAST_SUB_WINDOW;
+import static android.view.WindowManager.LayoutParams.TYPE_APPLICATION_STARTING;
+import static android.view.WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
+import static android.view.WindowManager.LayoutParams.TYPE_DREAM;
+import static android.view.WindowManager.LayoutParams.TYPE_INPUT_METHOD;
+import static android.view.WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG;
+import static android.view.WindowManager.LayoutParams.TYPE_WALLPAPER;
+
+import com.android.internal.app.IBatteryStats;
+import com.android.internal.policy.PolicyManager;
+import com.android.internal.policy.impl.PhoneWindowManager;
+import com.android.internal.view.IInputContext;
+import com.android.internal.view.IInputMethodClient;
+import com.android.internal.view.IInputMethodManager;
+import com.android.internal.view.WindowManagerPolicyThread;
+import com.android.server.AttributeCache;
+import com.android.server.EventLogTags;
+import com.android.server.PowerManagerService;
+import com.android.server.Watchdog;
+import com.android.server.am.BatteryStatsService;
+import com.android.server.input.InputFilter;
+import com.android.server.input.InputManagerService;
+import com.android.server.pm.ShutdownThread;
+
+import android.Manifest;
+import android.app.ActivityManagerNative;
+import android.app.ActivityOptions;
+import android.app.IActivityManager;
+import android.app.StatusBarManager;
+import android.app.admin.DevicePolicyManager;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
+import android.content.res.CompatibilityInfo;
+import android.content.res.Configuration;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Matrix;
+import android.graphics.PixelFormat;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.graphics.Region;
+import android.os.BatteryStats;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Debug;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.IRemoteCallback;
+import android.os.LocalPowerManager;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Parcel;
+import android.os.ParcelFileDescriptor;
+import android.os.PowerManager;
+import android.os.Process;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.StrictMode;
+import android.os.SystemClock;
+import android.os.SystemProperties;
+import android.os.TokenWatcher;
+import android.os.Trace;
+import android.provider.Settings;
+import android.util.DisplayMetrics;
+import android.util.EventLog;
+import android.util.FloatMath;
+import android.util.Log;
+import android.util.LogPrinter;
+import android.util.Pair;
+import android.util.Slog;
+import android.util.SparseIntArray;
+import android.util.TypedValue;
+import android.view.Choreographer;
+import android.view.Display;
+import android.view.Gravity;
+import android.view.IApplicationToken;
+import android.view.IOnKeyguardExitResult;
+import android.view.IRotationWatcher;
+import android.view.IWindow;
+import android.view.IWindowManager;
+import android.view.IWindowSession;
+import android.view.InputChannel;
+import android.view.InputDevice;
+import android.view.InputEvent;
+import android.view.InputEventReceiver;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+import android.view.Surface;
+import android.view.SurfaceSession;
+import android.view.View;
+import android.view.WindowManager;
+import android.view.WindowManagerImpl;
+import android.view.WindowManagerPolicy;
+import android.view.WindowManager.LayoutParams;
+import android.view.WindowManagerPolicy.FakeWindow;
+import android.view.animation.AlphaAnimation;
+import android.view.animation.Animation;
+import android.view.animation.AnimationSet;
+import android.view.animation.AnimationUtils;
+import android.view.animation.DecelerateInterpolator;
+import android.view.animation.Interpolator;
+import android.view.animation.ScaleAnimation;
+
+import java.io.BufferedWriter;
+import java.io.DataInputStream;
+import java.io.File;
+import java.io.FileDescriptor;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.net.Socket;
+import java.text.DateFormat;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+
+/** {@hide} */
+public class WindowManagerService extends IWindowManager.Stub
+        implements Watchdog.Monitor, WindowManagerPolicy.WindowManagerFuncs {
+    static final String TAG = "WindowManager";
+    static final boolean DEBUG = false;
+    static final boolean DEBUG_ADD_REMOVE = false;
+    static final boolean DEBUG_FOCUS = false;
+    static final boolean DEBUG_ANIM = false;
+    static final boolean DEBUG_LAYOUT = false;
+    static final boolean DEBUG_RESIZE = false;
+    static final boolean DEBUG_LAYERS = false;
+    static final boolean DEBUG_INPUT = false;
+    static final boolean DEBUG_INPUT_METHOD = false;
+    static final boolean DEBUG_VISIBILITY = false;
+    static final boolean DEBUG_WINDOW_MOVEMENT = false;
+    static final boolean DEBUG_TOKEN_MOVEMENT = false;
+    static final boolean DEBUG_ORIENTATION = false;
+    static final boolean DEBUG_APP_ORIENTATION = false;
+    static final boolean DEBUG_CONFIGURATION = false;
+    static final boolean DEBUG_APP_TRANSITIONS = false;
+    static final boolean DEBUG_STARTING_WINDOW = false;
+    static final boolean DEBUG_REORDER = false;
+    static final boolean DEBUG_WALLPAPER = false;
+    static final boolean DEBUG_DRAG = false;
+    static final boolean DEBUG_SCREEN_ON = false;
+    static final boolean DEBUG_SCREENSHOT = false;
+    static final boolean DEBUG_BOOT = false;
+    static final boolean DEBUG_LAYOUT_REPEATS = true;
+    static final boolean DEBUG_SURFACE_TRACE = false;
+    static final boolean DEBUG_WINDOW_TRACE = false;
+    static final boolean SHOW_SURFACE_ALLOC = false;
+    static final boolean SHOW_TRANSACTIONS = false;
+    static final boolean SHOW_LIGHT_TRANSACTIONS = false || SHOW_TRANSACTIONS;
+    static final boolean HIDE_STACK_CRAWLS = true;
+    static final int LAYOUT_REPEAT_THRESHOLD = 4;
+
+    static final boolean PROFILE_ORIENTATION = false;
+    static final boolean localLOGV = DEBUG;
+
+    /** How much to multiply the policy's type layer, to reserve room
+     * for multiple windows of the same type and Z-ordering adjustment
+     * with TYPE_LAYER_OFFSET. */
+    static final int TYPE_LAYER_MULTIPLIER = 10000;
+
+    /** Offset from TYPE_LAYER_MULTIPLIER for moving a group of windows above
+     * or below others in the same layer. */
+    static final int TYPE_LAYER_OFFSET = 1000;
+
+    /** How much to increment the layer for each window, to reserve room
+     * for effect surfaces between them.
+     */
+    static final int WINDOW_LAYER_MULTIPLIER = 5;
+
+    /**
+     * Dim surface layer is immediately below target window.
+     */
+    static final int LAYER_OFFSET_DIM = 1;
+
+    /**
+     * Blur surface layer is immediately below dim layer.
+     */
+    static final int LAYER_OFFSET_BLUR = 2;
+
+    /**
+     * Animation thumbnail is as far as possible below the window above
+     * the thumbnail (or in other words as far as possible above the window
+     * below it).
+     */
+    static final int LAYER_OFFSET_THUMBNAIL = WINDOW_LAYER_MULTIPLIER-1;
+
+    /**
+     * Layer at which to put the rotation freeze snapshot.
+     */
+    static final int FREEZE_LAYER = (TYPE_LAYER_MULTIPLIER * 200) + 1;
+
+    /**
+     * Layer at which to put the mask for emulated screen sizes.
+     */
+    static final int MASK_LAYER = TYPE_LAYER_MULTIPLIER * 200;
+
+    /** The maximum length we will accept for a loaded animation duration:
+     * this is 10 seconds.
+     */
+    static final int MAX_ANIMATION_DURATION = 10*1000;
+
+    /** Amount of time (in milliseconds) to animate the dim surface from one
+     * value to another, when no window animation is driving it.
+     */
+    static final int DEFAULT_DIM_DURATION = 200;
+
+    /** Amount of time (in milliseconds) to animate the fade-in-out transition for
+     * compatible windows.
+     */
+    static final int DEFAULT_FADE_IN_OUT_DURATION = 400;
+
+    /**
+     * If true, the window manager will do its own custom freezing and general
+     * management of the screen during rotation.
+     */
+    static final boolean CUSTOM_SCREEN_ROTATION = true;
+
+    // Maximum number of milliseconds to wait for input devices to be enumerated before
+    // proceding with safe mode detection.
+    private static final int INPUT_DEVICES_READY_FOR_SAFE_MODE_DETECTION_TIMEOUT_MILLIS = 1000;
+
+    // Default input dispatching timeout in nanoseconds.
+    static final long DEFAULT_INPUT_DISPATCHING_TIMEOUT_NANOS = 5000 * 1000000L;
+
+    static final int UPDATE_FOCUS_NORMAL = 0;
+    static final int UPDATE_FOCUS_WILL_ASSIGN_LAYERS = 1;
+    static final int UPDATE_FOCUS_PLACING_SURFACES = 2;
+    static final int UPDATE_FOCUS_WILL_PLACE_SURFACES = 3;
+
+    private static final String SYSTEM_SECURE = "ro.secure";
+    private static final String SYSTEM_DEBUGGABLE = "ro.debuggable";
+    private static final String SYSTEM_HEADLESS = "ro.config.headless";
+
+    /**
+     * Condition waited on by {@link #reenableKeyguard} to know the call to
+     * the window policy has finished.
+     * This is set to true only if mKeyguardTokenWatcher.acquired() has
+     * actually disabled the keyguard.
+     */
+    private boolean mKeyguardDisabled = false;
+
+    private final boolean mHeadless;
+
+    private static final int ALLOW_DISABLE_YES = 1;
+    private static final int ALLOW_DISABLE_NO = 0;
+    private static final int ALLOW_DISABLE_UNKNOWN = -1; // check with DevicePolicyManager
+    private int mAllowDisableKeyguard = ALLOW_DISABLE_UNKNOWN; // sync'd by mKeyguardTokenWatcher
+
+    private static final float THUMBNAIL_ANIMATION_DECELERATE_FACTOR = 1.5f;
+
+    final TokenWatcher mKeyguardTokenWatcher = new TokenWatcher(
+            new Handler(), "WindowManagerService.mKeyguardTokenWatcher") {
+        @Override
+        public void acquired() {
+            if (shouldAllowDisableKeyguard()) {
+                mPolicy.enableKeyguard(false);
+                mKeyguardDisabled = true;
+            } else {
+                Log.v(TAG, "Not disabling keyguard since device policy is enforced");
+            }
+        }
+        @Override
+        public void released() {
+            mPolicy.enableKeyguard(true);
+            synchronized (mKeyguardTokenWatcher) {
+                mKeyguardDisabled = false;
+                mKeyguardTokenWatcher.notifyAll();
+            }
+        }
+    };
+
+    final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            mPolicy.enableKeyguard(true);
+            synchronized(mKeyguardTokenWatcher) {
+                // lazily evaluate this next time we're asked to disable keyguard
+                mAllowDisableKeyguard = ALLOW_DISABLE_UNKNOWN;
+                mKeyguardDisabled = false;
+            }
+        }
+    };
+
+    final Context mContext;
+
+    final boolean mHaveInputMethods;
+
+    final boolean mAllowBootMessages;
+
+    final boolean mLimitedAlphaCompositing;
+
+    final WindowManagerPolicy mPolicy = PolicyManager.makeNewWindowManager();
+
+    final IActivityManager mActivityManager;
+
+    final IBatteryStats mBatteryStats;
+
+    /**
+     * All currently active sessions with clients.
+     */
+    final HashSet<Session> mSessions = new HashSet<Session>();
+
+    /**
+     * Mapping from an IWindow IBinder to the server's Window object.
+     * This is also used as the lock for all of our state.
+     */
+    final HashMap<IBinder, WindowState> mWindowMap = new HashMap<IBinder, WindowState>();
+
+    /**
+     * Mapping from a token IBinder to a WindowToken object.
+     */
+    final HashMap<IBinder, WindowToken> mTokenMap =
+            new HashMap<IBinder, WindowToken>();
+
+    /**
+     * Window tokens that are in the process of exiting, but still
+     * on screen for animations.
+     */
+    final ArrayList<WindowToken> mExitingTokens = new ArrayList<WindowToken>();
+
+    /**
+     * List controlling the ordering of windows in different applications which must
+     * be kept in sync with ActivityManager.
+     */
+    final ArrayList<AppWindowToken> mAppTokens = new ArrayList<AppWindowToken>();
+
+    /**
+     * AppWindowTokens in the Z order they were in at the start of an animation. Between
+     * animations this list is maintained in the exact order of mAppTokens. If tokens
+     * are added to mAppTokens during an animation an attempt is made to insert them at the same
+     * logical location in this list. Note that this list is always in sync with mWindows.
+     */
+    ArrayList<AppWindowToken> mAnimatingAppTokens = new ArrayList<AppWindowToken>();
+
+    /**
+     * Application tokens that are in the process of exiting, but still
+     * on screen for animations.
+     */
+    final ArrayList<AppWindowToken> mExitingAppTokens = new ArrayList<AppWindowToken>();
+
+    /**
+     * List of window tokens that have finished starting their application,
+     * and now need to have the policy remove their windows.
+     */
+    final ArrayList<AppWindowToken> mFinishedStarting = new ArrayList<AppWindowToken>();
+
+    /**
+     * Z-ordered (bottom-most first) list of all Window objects.
+     */
+    final ArrayList<WindowState> mWindows = new ArrayList<WindowState>();
+
+    /**
+     * Fake windows added to the window manager.  Note: ordered from top to
+     * bottom, opposite of mWindows.
+     */
+    final ArrayList<FakeWindowImpl> mFakeWindows = new ArrayList<FakeWindowImpl>();
+
+    /**
+     * Windows that are being resized.  Used so we can tell the client about
+     * the resize after closing the transaction in which we resized the
+     * underlying surface.
+     */
+    final ArrayList<WindowState> mResizingWindows = new ArrayList<WindowState>();
+
+    /**
+     * Windows whose animations have ended and now must be removed.
+     */
+    final ArrayList<WindowState> mPendingRemove = new ArrayList<WindowState>();
+
+    /**
+     * Used when processing mPendingRemove to avoid working on the original array.
+     */
+    WindowState[] mPendingRemoveTmp = new WindowState[20];
+
+    /**
+     * Windows whose surface should be destroyed.
+     */
+    final ArrayList<WindowState> mDestroySurface = new ArrayList<WindowState>();
+
+    /**
+     * Windows that have lost input focus and are waiting for the new
+     * focus window to be displayed before they are told about this.
+     */
+    ArrayList<WindowState> mLosingFocus = new ArrayList<WindowState>();
+
+    /**
+     * This is set when we have run out of memory, and will either be an empty
+     * list or contain windows that need to be force removed.
+     */
+    ArrayList<WindowState> mForceRemoves;
+
+    /**
+     * Windows that clients are waiting to have drawn.
+     */
+    ArrayList<Pair<WindowState, IRemoteCallback>> mWaitingForDrawn
+            = new ArrayList<Pair<WindowState, IRemoteCallback>>();
+
+    /**
+     * Windows that have called relayout() while we were running animations,
+     * so we need to tell when the animation is done.
+     */
+    final ArrayList<WindowState> mRelayoutWhileAnimating = new ArrayList<WindowState>();
+
+    /**
+     * Used when rebuilding window list to keep track of windows that have
+     * been removed.
+     */
+    WindowState[] mRebuildTmp = new WindowState[20];
+
+    IInputMethodManager mInputMethodManager;
+
+    final SurfaceSession mFxSession;
+    Watermark mWatermark;
+    StrictModeFlash mStrictModeFlash;
+
+    BlackFrame mBlackFrame;
+
+    final float[] mTmpFloats = new float[9];
+
+    boolean mSafeMode;
+    boolean mDisplayEnabled = false;
+    boolean mSystemBooted = false;
+    boolean mForceDisplayEnabled = false;
+    boolean mShowingBootMessages = false;
+
+    String mLastANRState;
+
+    // This protects the following display size properties, so that
+    // getDisplaySize() doesn't need to acquire the global lock.  This is
+    // needed because the window manager sometimes needs to use ActivityThread
+    // while it has its global state locked (for example to load animation
+    // resources), but the ActivityThread also needs get the current display
+    // size sometimes when it has its package lock held.
+    //
+    // These will only be modified with both mWindowMap and mDisplaySizeLock
+    // held (in that order) so the window manager doesn't need to acquire this
+    // lock when needing these values in its normal operation.
+    final Object mDisplaySizeLock = new Object();
+    int mInitialDisplayWidth = 0;
+    int mInitialDisplayHeight = 0;
+    int mBaseDisplayWidth = 0;
+    int mBaseDisplayHeight = 0;
+    int mCurDisplayWidth = 0;
+    int mCurDisplayHeight = 0;
+    int mAppDisplayWidth = 0;
+    int mAppDisplayHeight = 0;
+    int mSmallestDisplayWidth = 0;
+    int mSmallestDisplayHeight = 0;
+    int mLargestDisplayWidth = 0;
+    int mLargestDisplayHeight = 0;
+
+    int mRotation = 0;
+    int mForcedAppOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
+    boolean mAltOrientation = false;
+    ArrayList<IRotationWatcher> mRotationWatchers
+            = new ArrayList<IRotationWatcher>();
+    int mDeferredRotationPauseCount;
+
+    final Rect mSystemDecorRect = new Rect();
+    int mSystemDecorLayer = 0;
+
+    int mPendingLayoutChanges = 0;
+    boolean mLayoutNeeded = true;
+    boolean mTraversalScheduled = false;
+    boolean mDisplayFrozen = false;
+    boolean mWaitingForConfig = false;
+    boolean mWindowsFreezingScreen = false;
+    int mAppsFreezingScreen = 0;
+    int mLastWindowForcedOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
+
+    int mLayoutSeq = 0;
+
+    int mLastStatusBarVisibility = 0;
+
+    // State while inside of layoutAndPlaceSurfacesLocked().
+    boolean mFocusMayChange;
+    
+    Configuration mCurConfiguration = new Configuration();
+    
+    // This is held as long as we have the screen frozen, to give us time to
+    // perform a rotation animation when turning off shows the lock screen which
+    // changes the orientation.
+    PowerManager.WakeLock mScreenFrozenLock;
+
+    // State management of app transitions.  When we are preparing for a
+    // transition, mNextAppTransition will be the kind of transition to
+    // perform or TRANSIT_NONE if we are not waiting.  If we are waiting,
+    // mOpeningApps and mClosingApps are the lists of tokens that will be
+    // made visible or hidden at the next transition.
+    int mNextAppTransition = WindowManagerPolicy.TRANSIT_UNSET;
+    int mNextAppTransitionType = ActivityOptions.ANIM_NONE;
+    String mNextAppTransitionPackage;
+    Bitmap mNextAppTransitionThumbnail;
+    boolean mNextAppTransitionDelayed;
+    IRemoteCallback mNextAppTransitionCallback;
+    int mNextAppTransitionEnter;
+    int mNextAppTransitionExit;
+    int mNextAppTransitionStartX;
+    int mNextAppTransitionStartY;
+    int mNextAppTransitionStartWidth;
+    int mNextAppTransitionStartHeight;
+    boolean mAppTransitionReady = false;
+    boolean mAppTransitionRunning = false;
+    boolean mAppTransitionTimeout = false;
+    boolean mStartingIconInTransition = false;
+    boolean mSkipAppTransitionAnimation = false;
+    final ArrayList<AppWindowToken> mOpeningApps = new ArrayList<AppWindowToken>();
+    final ArrayList<AppWindowToken> mClosingApps = new ArrayList<AppWindowToken>();
+
+    Display mDisplay;
+
+    boolean mIsTouchDevice;
+
+    final DisplayMetrics mDisplayMetrics = new DisplayMetrics();
+    final DisplayMetrics mRealDisplayMetrics = new DisplayMetrics();
+    final DisplayMetrics mTmpDisplayMetrics = new DisplayMetrics();
+    final DisplayMetrics mCompatDisplayMetrics = new DisplayMetrics();
+
+    final H mH = new H();
+
+    final Choreographer mChoreographer = Choreographer.getInstance();
+
+    WindowState mCurrentFocus = null;
+    WindowState mLastFocus = null;
+
+    /** This just indicates the window the input method is on top of, not
+     * necessarily the window its input is going to. */
+    WindowState mInputMethodTarget = null;
+
+    /** If true hold off on modifying the animation layer of mInputMethodTarget */
+    boolean mInputMethodTargetWaitingAnim;
+    int mInputMethodAnimLayerAdjustment;
+
+    WindowState mInputMethodWindow = null;
+    final ArrayList<WindowState> mInputMethodDialogs = new ArrayList<WindowState>();
+
+    boolean mHardKeyboardAvailable;
+    boolean mHardKeyboardEnabled;
+    OnHardKeyboardStatusChangeListener mHardKeyboardStatusChangeListener;
+
+    final ArrayList<WindowToken> mWallpaperTokens = new ArrayList<WindowToken>();
+
+    // If non-null, this is the currently visible window that is associated
+    // with the wallpaper.
+    WindowState mWallpaperTarget = null;
+    // If non-null, we are in the middle of animating from one wallpaper target
+    // to another, and this is the lower one in Z-order.
+    WindowState mLowerWallpaperTarget = null;
+    // If non-null, we are in the middle of animating from one wallpaper target
+    // to another, and this is the higher one in Z-order.
+    WindowState mUpperWallpaperTarget = null;
+    int mWallpaperAnimLayerAdjustment;
+    float mLastWallpaperX = -1;
+    float mLastWallpaperY = -1;
+    float mLastWallpaperXStep = -1;
+    float mLastWallpaperYStep = -1;
+    // This is set when we are waiting for a wallpaper to tell us it is done
+    // changing its scroll position.
+    WindowState mWaitingOnWallpaper;
+    // The last time we had a timeout when waiting for a wallpaper.
+    long mLastWallpaperTimeoutTime;
+    // We give a wallpaper up to 150ms to finish scrolling.
+    static final long WALLPAPER_TIMEOUT = 150;
+    // Time we wait after a timeout before trying to wait again.
+    static final long WALLPAPER_TIMEOUT_RECOVERY = 10000;
+
+    AppWindowToken mFocusedApp = null;
+
+    PowerManagerService mPowerManager;
+
+    float mWindowAnimationScale = 1.0f;
+    float mTransitionAnimationScale = 1.0f;
+    float mAnimatorDurationScale = 1.0f;
+
+    final InputManagerService mInputManager;
+
+    // Who is holding the screen on.
+    Session mHoldingScreenOn;
+    PowerManager.WakeLock mHoldingScreenWakeLock;
+
+    boolean mTurnOnScreen;
+
+    DragState mDragState = null;
+
+    /** Pulled out of performLayoutAndPlaceSurfacesLockedInner in order to refactor into multiple
+     * methods. */
+    class LayoutFields {
+        static final int SET_UPDATE_ROTATION                = 1 << 0;
+        static final int SET_WALLPAPER_MAY_CHANGE           = 1 << 1;
+        static final int SET_FORCE_HIDING_CHANGED           = 1 << 2;
+        static final int CLEAR_ORIENTATION_CHANGE_COMPLETE  = 1 << 3;
+        static final int SET_TURN_ON_SCREEN                 = 1 << 4;
+
+        boolean mWallpaperForceHidingChanged = false;
+        boolean mWallpaperMayChange = false;
+        boolean mOrientationChangeComplete = true;
+        int mAdjResult = 0;
+        private Session mHoldScreen = null;
+        private boolean mObscured = false;
+        boolean mDimming = false;
+        private boolean mSyswin = false;
+        private float mScreenBrightness = -1;
+        private float mButtonBrightness = -1;
+        private boolean mUpdateRotation = false;
+    }
+    LayoutFields mInnerFields = new LayoutFields();
+
+    /** Skip repeated AppWindowTokens initialization. Note that AppWindowsToken's version of this
+     * is a long initialized to Long.MIN_VALUE so that it doesn't match this value on startup. */
+    private int mTransactionSequence;
+
+    /** Only do a maximum of 6 repeated layouts. After that quit */
+    private int mLayoutRepeatCount;
+
+    private final class AnimationRunnable implements Runnable {
+        @Override
+        public void run() {
+            synchronized(mWindowMap) {
+                mAnimationScheduled = false;
+                // Update animations of all applications, including those
+                // associated with exiting/removed apps
+                synchronized (mAnimator) {
+                    Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, "wmAnimate");
+                    final ArrayList<WindowStateAnimator> winAnimators = mAnimator.mWinAnimators;
+                    winAnimators.clear();
+                    final int N = mWindows.size();
+                    for (int i = 0; i < N; i++) {
+                        final WindowStateAnimator winAnimator = mWindows.get(i).mWinAnimator;
+                        if (winAnimator.mSurface != null) {
+                            winAnimators.add(winAnimator);
+                        }
+                    }
+                    mAnimator.animate();
+                    Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);
+                }
+            }
+        }
+    }
+    final AnimationRunnable mAnimationRunnable = new AnimationRunnable();
+    boolean mAnimationScheduled;
+    
+    final WindowAnimator mAnimator;
+
+    final class DragInputEventReceiver extends InputEventReceiver {
+        public DragInputEventReceiver(InputChannel inputChannel, Looper looper) {
+            super(inputChannel, looper);
+        }
+
+        @Override
+        public void onInputEvent(InputEvent event) {
+            boolean handled = false;
+            try {
+                if (event instanceof MotionEvent
+                        && (event.getSource() & InputDevice.SOURCE_CLASS_POINTER) != 0
+                        && mDragState != null) {
+                    final MotionEvent motionEvent = (MotionEvent)event;
+                    boolean endDrag = false;
+                    final float newX = motionEvent.getRawX();
+                    final float newY = motionEvent.getRawY();
+
+                    switch (motionEvent.getAction()) {
+                    case MotionEvent.ACTION_DOWN: {
+                        if (DEBUG_DRAG) {
+                            Slog.w(TAG, "Unexpected ACTION_DOWN in drag layer");
+                        }
+                    } break;
+
+                    case MotionEvent.ACTION_MOVE: {
+                        synchronized (mWindowMap) {
+                            // move the surface and tell the involved window(s) where we are
+                            mDragState.notifyMoveLw(newX, newY);
+                        }
+                    } break;
+
+                    case MotionEvent.ACTION_UP: {
+                        if (DEBUG_DRAG) Slog.d(TAG, "Got UP on move channel; dropping at "
+                                + newX + "," + newY);
+                        synchronized (mWindowMap) {
+                            endDrag = mDragState.notifyDropLw(newX, newY);
+                        }
+                    } break;
+
+                    case MotionEvent.ACTION_CANCEL: {
+                        if (DEBUG_DRAG) Slog.d(TAG, "Drag cancelled!");
+                        endDrag = true;
+                    } break;
+                    }
+
+                    if (endDrag) {
+                        if (DEBUG_DRAG) Slog.d(TAG, "Drag ended; tearing down state");
+                        // tell all the windows that the drag has ended
+                        synchronized (mWindowMap) {
+                            mDragState.endDragLw();
+                        }
+                    }
+
+                    handled = true;
+                }
+            } catch (Exception e) {
+                Slog.e(TAG, "Exception caught by drag handleMotion", e);
+            } finally {
+                finishInputEvent(event, handled);
+            }
+        }
+    }
+
+    /**
+     * Whether the UI is currently running in touch mode (not showing
+     * navigational focus because the user is directly pressing the screen).
+     */
+    boolean mInTouchMode = true;
+
+    private ViewServer mViewServer;
+    private ArrayList<WindowChangeListener> mWindowChangeListeners =
+        new ArrayList<WindowChangeListener>();
+    private boolean mWindowsChanged = false;
+
+    public interface WindowChangeListener {
+        public void windowsChanged();
+        public void focusChanged();
+    }
+
+    final Configuration mTempConfiguration = new Configuration();
+
+    // The desired scaling factor for compatible apps.
+    float mCompatibleScreenScale;
+
+    // If true, only the core apps and services are being launched because the device
+    // is in a special boot mode, such as being encrypted or waiting for a decryption password.
+    // For example, when this flag is true, there will be no wallpaper service.
+    final boolean mOnlyCore;
+
+    public static WindowManagerService main(Context context,
+            PowerManagerService pm, boolean haveInputMethods, boolean allowBootMsgs,
+            boolean onlyCore) {
+        WMThread thr = new WMThread(context, pm, haveInputMethods, allowBootMsgs, onlyCore);
+        thr.start();
+
+        synchronized (thr) {
+            while (thr.mService == null) {
+                try {
+                    thr.wait();
+                } catch (InterruptedException e) {
+                }
+            }
+            return thr.mService;
+        }
+    }
+
+    static class WMThread extends Thread {
+        WindowManagerService mService;
+
+        private final Context mContext;
+        private final PowerManagerService mPM;
+        private final boolean mHaveInputMethods;
+        private final boolean mAllowBootMessages;
+        private final boolean mOnlyCore;
+
+        public WMThread(Context context, PowerManagerService pm,
+                boolean haveInputMethods, boolean allowBootMsgs, boolean onlyCore) {
+            super("WindowManager");
+            mContext = context;
+            mPM = pm;
+            mHaveInputMethods = haveInputMethods;
+            mAllowBootMessages = allowBootMsgs;
+            mOnlyCore = onlyCore;
+        }
+
+        @Override
+        public void run() {
+            Looper.prepare();
+            //Looper.myLooper().setMessageLogging(new LogPrinter(
+            //        android.util.Log.DEBUG, TAG, android.util.Log.LOG_ID_SYSTEM));
+            WindowManagerService s = new WindowManagerService(mContext, mPM,
+                    mHaveInputMethods, mAllowBootMessages, mOnlyCore);
+            android.os.Process.setThreadPriority(
+                    android.os.Process.THREAD_PRIORITY_DISPLAY);
+            android.os.Process.setCanSelfBackground(false);
+
+            synchronized (this) {
+                mService = s;
+                notifyAll();
+            }
+
+            // For debug builds, log event loop stalls to dropbox for analysis.
+            if (StrictMode.conditionallyEnableDebugLogging()) {
+                Slog.i(TAG, "Enabled StrictMode logging for WMThread's Looper");
+            }
+
+            Looper.loop();
+        }
+    }
+
+    static class PolicyThread extends Thread {
+        private final WindowManagerPolicy mPolicy;
+        private final WindowManagerService mService;
+        private final Context mContext;
+        private final PowerManagerService mPM;
+        boolean mRunning = false;
+
+        public PolicyThread(WindowManagerPolicy policy,
+                WindowManagerService service, Context context,
+                PowerManagerService pm) {
+            super("WindowManagerPolicy");
+            mPolicy = policy;
+            mService = service;
+            mContext = context;
+            mPM = pm;
+        }
+
+        @Override
+        public void run() {
+            Looper.prepare();
+            WindowManagerPolicyThread.set(this, Looper.myLooper());
+            
+            //Looper.myLooper().setMessageLogging(new LogPrinter(
+            //        Log.VERBOSE, "WindowManagerPolicy", Log.LOG_ID_SYSTEM));
+            android.os.Process.setThreadPriority(
+                    android.os.Process.THREAD_PRIORITY_FOREGROUND);
+            android.os.Process.setCanSelfBackground(false);
+            mPolicy.init(mContext, mService, mService, mPM);
+
+            synchronized (this) {
+                mRunning = true;
+                notifyAll();
+            }
+
+            // For debug builds, log event loop stalls to dropbox for analysis.
+            if (StrictMode.conditionallyEnableDebugLogging()) {
+                Slog.i(TAG, "Enabled StrictMode for PolicyThread's Looper");
+            }
+
+            Looper.loop();
+        }
+    }
+
+    private WindowManagerService(Context context, PowerManagerService pm,
+            boolean haveInputMethods, boolean showBootMsgs, boolean onlyCore) {
+        mContext = context;
+        mHaveInputMethods = haveInputMethods;
+        mAllowBootMessages = showBootMsgs;
+        mOnlyCore = onlyCore;
+        mLimitedAlphaCompositing = context.getResources().getBoolean(
+                com.android.internal.R.bool.config_sf_limitedAlpha);
+        mHeadless = "1".equals(SystemProperties.get(SYSTEM_HEADLESS, "0"));
+
+        mPowerManager = pm;
+        mPowerManager.setPolicy(mPolicy);
+        PowerManager pmc = (PowerManager)context.getSystemService(Context.POWER_SERVICE);
+        mScreenFrozenLock = pmc.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
+                "SCREEN_FROZEN");
+        mScreenFrozenLock.setReferenceCounted(false);
+
+        mActivityManager = ActivityManagerNative.getDefault();
+        mBatteryStats = BatteryStatsService.getService();
+
+        // Get persisted window scale setting
+        mWindowAnimationScale = Settings.System.getFloat(context.getContentResolver(),
+                Settings.System.WINDOW_ANIMATION_SCALE, mWindowAnimationScale);
+        mTransitionAnimationScale = Settings.System.getFloat(context.getContentResolver(),
+                Settings.System.TRANSITION_ANIMATION_SCALE, mTransitionAnimationScale);
+        mAnimatorDurationScale = Settings.System.getFloat(context.getContentResolver(),
+                Settings.System.ANIMATOR_DURATION_SCALE, mTransitionAnimationScale);
+
+        // Track changes to DevicePolicyManager state so we can enable/disable keyguard.
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(DevicePolicyManager.ACTION_DEVICE_POLICY_MANAGER_STATE_CHANGED);
+        mContext.registerReceiver(mBroadcastReceiver, filter);
+
+        mHoldingScreenWakeLock = pmc.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK
+                | PowerManager.ON_AFTER_RELEASE, "KEEP_SCREEN_ON_FLAG");
+        mHoldingScreenWakeLock.setReferenceCounted(false);
+
+        mInputManager = new InputManagerService(context, mInputMonitor);
+        mAnimator = new WindowAnimator(this, context, mPolicy);
+
+        PolicyThread thr = new PolicyThread(mPolicy, this, context, pm);
+        thr.start();
+
+        synchronized (thr) {
+            while (!thr.mRunning) {
+                try {
+                    thr.wait();
+                } catch (InterruptedException e) {
+                }
+            }
+        }
+
+        mInputManager.start();
+
+        // Add ourself to the Watchdog monitors.
+        Watchdog.getInstance().addMonitor(this);
+        mFxSession = new SurfaceSession();
+
+        Surface.openTransaction();
+        createWatermark();
+        Surface.closeTransaction();
+    }
+
+    public InputManagerService getInputManagerService() {
+        return mInputManager;
+    }
+
+    @Override
+    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)
+            throws RemoteException {
+        try {
+            return super.onTransact(code, data, reply, flags);
+        } catch (RuntimeException e) {
+            // The window manager only throws security exceptions, so let's
+            // log all others.
+            if (!(e instanceof SecurityException)) {
+                Log.wtf(TAG, "Window Manager Crash", e);
+            }
+            throw e;
+        }
+    }
+
+    private void placeWindowAfter(WindowState pos, WindowState window) {
+        final int i = mWindows.indexOf(pos);
+        if (DEBUG_FOCUS || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Slog.v(
+            TAG, "Adding window " + window + " at "
+            + (i+1) + " of " + mWindows.size() + " (after " + pos + ")");
+        mWindows.add(i+1, window);
+        mWindowsChanged = true;
+    }
+
+    private void placeWindowBefore(WindowState pos, WindowState window) {
+        final int i = mWindows.indexOf(pos);
+        if (DEBUG_FOCUS || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Slog.v(
+            TAG, "Adding window " + window + " at "
+            + i + " of " + mWindows.size() + " (before " + pos + ")");
+        mWindows.add(i, window);
+        mWindowsChanged = true;
+    }
+
+    //This method finds out the index of a window that has the same app token as
+    //win. used for z ordering the windows in mWindows
+    private int findIdxBasedOnAppTokens(WindowState win) {
+        //use a local variable to cache mWindows
+        ArrayList<WindowState> localmWindows = mWindows;
+        int jmax = localmWindows.size();
+        if(jmax == 0) {
+            return -1;
+        }
+        for(int j = (jmax-1); j >= 0; j--) {
+            WindowState wentry = localmWindows.get(j);
+            if(wentry.mAppToken == win.mAppToken) {
+                return j;
+            }
+        }
+        return -1;
+    }
+
+    private void addWindowToListInOrderLocked(WindowState win, boolean addToToken) {
+        final IWindow client = win.mClient;
+        final WindowToken token = win.mToken;
+        final ArrayList<WindowState> localmWindows = mWindows;
+
+        final int N = localmWindows.size();
+        final WindowState attached = win.mAttachedWindow;
+        int i;
+        if (attached == null) {
+            int tokenWindowsPos = token.windows.size();
+            if (token.appWindowToken != null) {
+                int index = tokenWindowsPos-1;
+                if (index >= 0) {
+                    // If this application has existing windows, we
+                    // simply place the new window on top of them... but
+                    // keep the starting window on top.
+                    if (win.mAttrs.type == TYPE_BASE_APPLICATION) {
+                        // Base windows go behind everything else.
+                        placeWindowBefore(token.windows.get(0), win);
+                        tokenWindowsPos = 0;
+                    } else {
+                        AppWindowToken atoken = win.mAppToken;
+                        if (atoken != null &&
+                                token.windows.get(index) == atoken.startingWindow) {
+                            placeWindowBefore(token.windows.get(index), win);
+                            tokenWindowsPos--;
+                        } else {
+                            int newIdx =  findIdxBasedOnAppTokens(win);
+                            if(newIdx != -1) {
+                                //there is a window above this one associated with the same
+                                //apptoken note that the window could be a floating window
+                                //that was created later or a window at the top of the list of
+                                //windows associated with this token.
+                                if (DEBUG_FOCUS || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) {
+                                    Slog.v(TAG, "Adding window " + win + " at "
+                                            + (newIdx+1) + " of " + N);
+                                }
+                                localmWindows.add(newIdx+1, win);
+                                mWindowsChanged = true;
+                            }
+                        }
+                    }
+                } else {
+                    if (localLOGV) Slog.v(
+                        TAG, "Figuring out where to add app window "
+                        + client.asBinder() + " (token=" + token + ")");
+                    // Figure out where the window should go, based on the
+                    // order of applications.
+                    final int NA = mAnimatingAppTokens.size();
+                    WindowState pos = null;
+                    for (i=NA-1; i>=0; i--) {
+                        AppWindowToken t = mAnimatingAppTokens.get(i);
+                        if (t == token) {
+                            i--;
+                            break;
+                        }
+
+                        // We haven't reached the token yet; if this token
+                        // is not going to the bottom and has windows, we can
+                        // use it as an anchor for when we do reach the token.
+                        if (!t.sendingToBottom && t.windows.size() > 0) {
+                            pos = t.windows.get(0);
+                        }
+                    }
+                    // We now know the index into the apps.  If we found
+                    // an app window above, that gives us the position; else
+                    // we need to look some more.
+                    if (pos != null) {
+                        // Move behind any windows attached to this one.
+                        WindowToken atoken = mTokenMap.get(pos.mClient.asBinder());
+                        if (atoken != null) {
+                            final int NC = atoken.windows.size();
+                            if (NC > 0) {
+                                WindowState bottom = atoken.windows.get(0);
+                                if (bottom.mSubLayer < 0) {
+                                    pos = bottom;
+                                }
+                            }
+                        }
+                        placeWindowBefore(pos, win);
+                    } else {
+                        // Continue looking down until we find the first
+                        // token that has windows.
+                        while (i >= 0) {
+                            AppWindowToken t = mAnimatingAppTokens.get(i);
+                            final int NW = t.windows.size();
+                            if (NW > 0) {
+                                pos = t.windows.get(NW-1);
+                                break;
+                            }
+                            i--;
+                        }
+                        if (pos != null) {
+                            // Move in front of any windows attached to this
+                            // one.
+                            WindowToken atoken = mTokenMap.get(pos.mClient.asBinder());
+                            if (atoken != null) {
+                                final int NC = atoken.windows.size();
+                                if (NC > 0) {
+                                    WindowState top = atoken.windows.get(NC-1);
+                                    if (top.mSubLayer >= 0) {
+                                        pos = top;
+                                    }
+                                }
+                            }
+                            placeWindowAfter(pos, win);
+                        } else {
+                            // Just search for the start of this layer.
+                            final int myLayer = win.mBaseLayer;
+                            for (i=0; i<N; i++) {
+                                WindowState w = localmWindows.get(i);
+                                if (w.mBaseLayer > myLayer) {
+                                    break;
+                                }
+                            }
+                            if (DEBUG_FOCUS || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) {
+                                Slog.v(TAG, "Adding window " + win + " at "
+                                        + i + " of " + N);
+                            }
+                            localmWindows.add(i, win);
+                            mWindowsChanged = true;
+                        }
+                    }
+                }
+            } else {
+                // Figure out where window should go, based on layer.
+                final int myLayer = win.mBaseLayer;
+                for (i=N-1; i>=0; i--) {
+                    if (localmWindows.get(i).mBaseLayer <= myLayer) {
+                        i++;
+                        break;
+                    }
+                }
+                if (i < 0) i = 0;
+                if (DEBUG_FOCUS || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Slog.v(
+                        TAG, "Adding window " + win + " at "
+                        + i + " of " + N);
+                localmWindows.add(i, win);
+                mWindowsChanged = true;
+            }
+            if (addToToken) {
+                if (DEBUG_ADD_REMOVE) Slog.v(TAG, "Adding " + win + " to " + token);
+                token.windows.add(tokenWindowsPos, win);
+            }
+
+        } else {
+            // Figure out this window's ordering relative to the window
+            // it is attached to.
+            final int NA = token.windows.size();
+            final int sublayer = win.mSubLayer;
+            int largestSublayer = Integer.MIN_VALUE;
+            WindowState windowWithLargestSublayer = null;
+            for (i=0; i<NA; i++) {
+                WindowState w = token.windows.get(i);
+                final int wSublayer = w.mSubLayer;
+                if (wSublayer >= largestSublayer) {
+                    largestSublayer = wSublayer;
+                    windowWithLargestSublayer = w;
+                }
+                if (sublayer < 0) {
+                    // For negative sublayers, we go below all windows
+                    // in the same sublayer.
+                    if (wSublayer >= sublayer) {
+                        if (addToToken) {
+                            if (DEBUG_ADD_REMOVE) Slog.v(TAG, "Adding " + win + " to " + token);
+                            token.windows.add(i, win);
+                        }
+                        placeWindowBefore(
+                            wSublayer >= 0 ? attached : w, win);
+                        break;
+                    }
+                } else {
+                    // For positive sublayers, we go above all windows
+                    // in the same sublayer.
+                    if (wSublayer > sublayer) {
+                        if (addToToken) {
+                            if (DEBUG_ADD_REMOVE) Slog.v(TAG, "Adding " + win + " to " + token);
+                            token.windows.add(i, win);
+                        }
+                        placeWindowBefore(w, win);
+                        break;
+                    }
+                }
+            }
+            if (i >= NA) {
+                if (addToToken) {
+                    if (DEBUG_ADD_REMOVE) Slog.v(TAG, "Adding " + win + " to " + token);
+                    token.windows.add(win);
+                }
+                if (sublayer < 0) {
+                    placeWindowBefore(attached, win);
+                } else {
+                    placeWindowAfter(largestSublayer >= 0
+                                     ? windowWithLargestSublayer
+                                     : attached,
+                                     win);
+                }
+            }
+        }
+
+        if (win.mAppToken != null && addToToken) {
+            win.mAppToken.allAppWindows.add(win);
+        }
+    }
+
+    /** TODO(cmautner): Is this the same as {@link WindowState#canReceiveKeys()} */
+    static boolean canBeImeTarget(WindowState w) {
+        final int fl = w.mAttrs.flags
+                & (FLAG_NOT_FOCUSABLE|FLAG_ALT_FOCUSABLE_IM);
+        if (fl == 0 || fl == (FLAG_NOT_FOCUSABLE|FLAG_ALT_FOCUSABLE_IM)
+                || w.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING) {
+            if (DEBUG_INPUT_METHOD) {
+                Slog.i(TAG, "isVisibleOrAdding " + w + ": " + w.isVisibleOrAdding());
+                if (!w.isVisibleOrAdding()) {
+                    Slog.i(TAG, "  mSurface=" + w.mWinAnimator.mSurface
+                            + " relayoutCalled=" + w.mRelayoutCalled + " viewVis=" + w.mViewVisibility
+                            + " policyVis=" + w.mPolicyVisibility
+                            + " policyVisAfterAnim=" + w.mPolicyVisibilityAfterAnim
+                            + " attachHid=" + w.mAttachedHidden
+                            + " exiting=" + w.mExiting + " destroying=" + w.mDestroying);
+                    if (w.mAppToken != null) {
+                        Slog.i(TAG, "  mAppToken.hiddenRequested=" + w.mAppToken.hiddenRequested);
+                    }
+                }
+            }
+            return w.isVisibleOrAdding();
+        }
+        return false;
+    }
+
+    /**
+     * Dig through the WindowStates and find the one that the Input Method will target.
+     * @param willMove
+     * @return The index+1 in mWindows of the discovered target.
+     */
+    int findDesiredInputMethodWindowIndexLocked(boolean willMove) {
+        final ArrayList<WindowState> localmWindows = mWindows;
+        final int N = localmWindows.size();
+        WindowState w = null;
+        int i = N;
+        while (i > 0) {
+            i--;
+            w = localmWindows.get(i);
+
+            if (DEBUG_INPUT_METHOD && willMove) Slog.i(TAG, "Checking window @" + i
+                    + " " + w + " fl=0x" + Integer.toHexString(w.mAttrs.flags));
+            if (canBeImeTarget(w)) {
+                //Slog.i(TAG, "Putting input method here!");
+
+                // Yet more tricksyness!  If this window is a "starting"
+                // window, we do actually want to be on top of it, but
+                // it is not -really- where input will go.  So if the caller
+                // is not actually looking to move the IME, look down below
+                // for a real window to target...
+                if (!willMove
+                        && w.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING
+                        && i > 0) {
+                    WindowState wb = localmWindows.get(i-1);
+                    if (wb.mAppToken == w.mAppToken && canBeImeTarget(wb)) {
+                        i--;
+                        w = wb;
+                    }
+                }
+                break;
+            }
+        }
+
+        // Now w is either mWindows[0] or an IME (or null if mWindows is empty).
+
+        if (DEBUG_INPUT_METHOD && willMove) Slog.v(TAG, "Proposed new IME target: " + w);
+
+        // Now, a special case -- if the last target's window is in the
+        // process of exiting, and is above the new target, keep on the
+        // last target to avoid flicker.  Consider for example a Dialog with
+        // the IME shown: when the Dialog is dismissed, we want to keep
+        // the IME above it until it is completely gone so it doesn't drop
+        // behind the dialog or its full-screen scrim.
+        if (mInputMethodTarget != null && w != null
+                && mInputMethodTarget.isDisplayedLw()
+                && mInputMethodTarget.mExiting) {
+            if (mInputMethodTarget.mWinAnimator.mAnimLayer > w.mWinAnimator.mAnimLayer) {
+                w = mInputMethodTarget;
+                i = localmWindows.indexOf(w);
+                if (DEBUG_INPUT_METHOD) Slog.v(TAG, "Current target higher, switching to: " + w);
+            }
+        }
+
+        if (DEBUG_INPUT_METHOD) Slog.v(TAG, "Desired input method target="
+                + w + " willMove=" + willMove);
+
+        if (willMove && w != null) {
+            final WindowState curTarget = mInputMethodTarget;
+            if (curTarget != null && curTarget.mAppToken != null) {
+
+                // Now some fun for dealing with window animations that
+                // modify the Z order.  We need to look at all windows below
+                // the current target that are in this app, finding the highest
+                // visible one in layering.
+                AppWindowToken token = curTarget.mAppToken;
+                WindowState highestTarget = null;
+                int highestPos = 0;
+                if (token.mAppAnimator.animating || token.mAppAnimator.animation != null) {
+                    int pos = localmWindows.indexOf(curTarget);
+                    while (pos >= 0) {
+                        WindowState win = localmWindows.get(pos);
+                        if (win.mAppToken != token) {
+                            break;
+                        }
+                        if (!win.mRemoved) {
+                            if (highestTarget == null || win.mWinAnimator.mAnimLayer >
+                                    highestTarget.mWinAnimator.mAnimLayer) {
+                                highestTarget = win;
+                                highestPos = pos;
+                            }
+                        }
+                        pos--;
+                    }
+                }
+
+                if (highestTarget != null) {
+                    if (DEBUG_INPUT_METHOD) Slog.v(TAG, "mNextAppTransition="
+                            + mNextAppTransition + " " + highestTarget
+                            + " animating=" + highestTarget.mWinAnimator.isAnimating()
+                            + " layer=" + highestTarget.mWinAnimator.mAnimLayer
+                            + " new layer=" + w.mWinAnimator.mAnimLayer);
+
+                    if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
+                        // If we are currently setting up for an animation,
+                        // hold everything until we can find out what will happen.
+                        mInputMethodTargetWaitingAnim = true;
+                        mInputMethodTarget = highestTarget;
+                        return highestPos + 1;
+                    } else if (highestTarget.mWinAnimator.isAnimating() &&
+                            highestTarget.mWinAnimator.mAnimLayer > w.mWinAnimator.mAnimLayer) {
+                        // If the window we are currently targeting is involved
+                        // with an animation, and it is on top of the next target
+                        // we will be over, then hold off on moving until
+                        // that is done.
+                        mInputMethodTargetWaitingAnim = true;
+                        mInputMethodTarget = highestTarget;
+                        return highestPos + 1;
+                    }
+                }
+            }
+        }
+
+        //Slog.i(TAG, "Placing input method @" + (i+1));
+        if (w != null) {
+            if (willMove) {
+                if (DEBUG_INPUT_METHOD) {
+                    RuntimeException e = null;
+                    if (!HIDE_STACK_CRAWLS) {
+                        e = new RuntimeException();
+                        e.fillInStackTrace();
+                    }
+                    Slog.w(TAG, "Moving IM target from "
+                            + mInputMethodTarget + " to " + w, e);
+                }
+                mInputMethodTarget = w;
+                mInputMethodTargetWaitingAnim = false;
+                if (w.mAppToken != null) {
+                    setInputMethodAnimLayerAdjustment(w.mAppToken.mAppAnimator.animLayerAdjustment);
+                } else {
+                    setInputMethodAnimLayerAdjustment(0);
+                }
+            }
+            return i+1;
+        }
+        if (willMove) {
+            if (DEBUG_INPUT_METHOD) {
+                RuntimeException e = null;
+                if (!HIDE_STACK_CRAWLS) {
+                    e = new RuntimeException();
+                    e.fillInStackTrace();
+                }
+                Slog.w(TAG, "Moving IM target from "
+                        + mInputMethodTarget + " to null", e);
+            }
+            mInputMethodTarget = null;
+            setInputMethodAnimLayerAdjustment(0);
+        }
+        return -1;
+    }
+
+    void addInputMethodWindowToListLocked(WindowState win) {
+        int pos = findDesiredInputMethodWindowIndexLocked(true);
+        if (pos >= 0) {
+            win.mTargetAppToken = mInputMethodTarget.mAppToken;
+            if (DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Slog.v(
+                    TAG, "Adding input method window " + win + " at " + pos);
+            mWindows.add(pos, win);
+            mWindowsChanged = true;
+            moveInputMethodDialogsLocked(pos+1);
+            return;
+        }
+        win.mTargetAppToken = null;
+        addWindowToListInOrderLocked(win, true);
+        moveInputMethodDialogsLocked(pos);
+    }
+
+    void setInputMethodAnimLayerAdjustment(int adj) {
+        if (DEBUG_LAYERS) Slog.v(TAG, "Setting im layer adj to " + adj);
+        mInputMethodAnimLayerAdjustment = adj;
+        WindowState imw = mInputMethodWindow;
+        if (imw != null) {
+            imw.mWinAnimator.mAnimLayer = imw.mLayer + adj;
+            if (DEBUG_LAYERS) Slog.v(TAG, "IM win " + imw
+                    + " anim layer: " + imw.mWinAnimator.mAnimLayer);
+            int wi = imw.mChildWindows.size();
+            while (wi > 0) {
+                wi--;
+                WindowState cw = imw.mChildWindows.get(wi);
+                cw.mWinAnimator.mAnimLayer = cw.mLayer + adj;
+                if (DEBUG_LAYERS) Slog.v(TAG, "IM win " + cw
+                        + " anim layer: " + cw.mWinAnimator.mAnimLayer);
+            }
+        }
+        int di = mInputMethodDialogs.size();
+        while (di > 0) {
+            di --;
+            imw = mInputMethodDialogs.get(di);
+            imw.mWinAnimator.mAnimLayer = imw.mLayer + adj;
+            if (DEBUG_LAYERS) Slog.v(TAG, "IM win " + imw
+                    + " anim layer: " + imw.mWinAnimator.mAnimLayer);
+        }
+    }
+
+    private int tmpRemoveWindowLocked(int interestingPos, WindowState win) {
+        int wpos = mWindows.indexOf(win);
+        if (wpos >= 0) {
+            if (wpos < interestingPos) interestingPos--;
+            if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Temp removing at " + wpos + ": " + win);
+            mWindows.remove(wpos);
+            mWindowsChanged = true;
+            int NC = win.mChildWindows.size();
+            while (NC > 0) {
+                NC--;
+                WindowState cw = win.mChildWindows.get(NC);
+                int cpos = mWindows.indexOf(cw);
+                if (cpos >= 0) {
+                    if (cpos < interestingPos) interestingPos--;
+                    if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Temp removing child at "
+                            + cpos + ": " + cw);
+                    mWindows.remove(cpos);
+                }
+            }
+        }
+        return interestingPos;
+    }
+
+    private void reAddWindowToListInOrderLocked(WindowState win) {
+        addWindowToListInOrderLocked(win, false);
+        // This is a hack to get all of the child windows added as well
+        // at the right position.  Child windows should be rare and
+        // this case should be rare, so it shouldn't be that big a deal.
+        int wpos = mWindows.indexOf(win);
+        if (wpos >= 0) {
+            if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "ReAdd removing from " + wpos
+                    + ": " + win);
+            mWindows.remove(wpos);
+            mWindowsChanged = true;
+            reAddWindowLocked(wpos, win);
+        }
+    }
+
+    void logWindowList(String prefix) {
+        int N = mWindows.size();
+        while (N > 0) {
+            N--;
+            Slog.v(TAG, prefix + "#" + N + ": " + mWindows.get(N));
+        }
+    }
+
+    void moveInputMethodDialogsLocked(int pos) {
+        ArrayList<WindowState> dialogs = mInputMethodDialogs;
+
+        final int N = dialogs.size();
+        if (DEBUG_INPUT_METHOD) Slog.v(TAG, "Removing " + N + " dialogs w/pos=" + pos);
+        for (int i=0; i<N; i++) {
+            pos = tmpRemoveWindowLocked(pos, dialogs.get(i));
+        }
+        if (DEBUG_INPUT_METHOD) {
+            Slog.v(TAG, "Window list w/pos=" + pos);
+            logWindowList("  ");
+        }
+
+        if (pos >= 0) {
+            final AppWindowToken targetAppToken = mInputMethodTarget.mAppToken;
+            if (pos < mWindows.size()) {
+                WindowState wp = mWindows.get(pos);
+                if (wp == mInputMethodWindow) {
+                    pos++;
+                }
+            }
+            if (DEBUG_INPUT_METHOD) Slog.v(TAG, "Adding " + N + " dialogs at pos=" + pos);
+            for (int i=0; i<N; i++) {
+                WindowState win = dialogs.get(i);
+                win.mTargetAppToken = targetAppToken;
+                pos = reAddWindowLocked(pos, win);
+            }
+            if (DEBUG_INPUT_METHOD) {
+                Slog.v(TAG, "Final window list:");
+                logWindowList("  ");
+            }
+            return;
+        }
+        for (int i=0; i<N; i++) {
+            WindowState win = dialogs.get(i);
+            win.mTargetAppToken = null;
+            reAddWindowToListInOrderLocked(win);
+            if (DEBUG_INPUT_METHOD) {
+                Slog.v(TAG, "No IM target, final list:");
+                logWindowList("  ");
+            }
+        }
+    }
+
+    boolean moveInputMethodWindowsIfNeededLocked(boolean needAssignLayers) {
+        final WindowState imWin = mInputMethodWindow;
+        final int DN = mInputMethodDialogs.size();
+        if (imWin == null && DN == 0) {
+            return false;
+        }
+
+        int imPos = findDesiredInputMethodWindowIndexLocked(true);
+        if (imPos >= 0) {
+            // In this case, the input method windows are to be placed
+            // immediately above the window they are targeting.
+
+            // First check to see if the input method windows are already
+            // located here, and contiguous.
+            final int N = mWindows.size();
+            WindowState firstImWin = imPos < N
+                    ? mWindows.get(imPos) : null;
+
+            // Figure out the actual input method window that should be
+            // at the bottom of their stack.
+            WindowState baseImWin = imWin != null
+                    ? imWin : mInputMethodDialogs.get(0);
+            if (baseImWin.mChildWindows.size() > 0) {
+                WindowState cw = baseImWin.mChildWindows.get(0);
+                if (cw.mSubLayer < 0) baseImWin = cw;
+            }
+
+            if (firstImWin == baseImWin) {
+                // The windows haven't moved...  but are they still contiguous?
+                // First find the top IM window.
+                int pos = imPos+1;
+                while (pos < N) {
+                    if (!(mWindows.get(pos)).mIsImWindow) {
+                        break;
+                    }
+                    pos++;
+                }
+                pos++;
+                // Now there should be no more input method windows above.
+                while (pos < N) {
+                    if ((mWindows.get(pos)).mIsImWindow) {
+                        break;
+                    }
+                    pos++;
+                }
+                if (pos >= N) {
+                    // All is good!
+                    return false;
+                }
+            }
+
+            if (imWin != null) {
+                if (DEBUG_INPUT_METHOD) {
+                    Slog.v(TAG, "Moving IM from " + imPos);
+                    logWindowList("  ");
+                }
+                imPos = tmpRemoveWindowLocked(imPos, imWin);
+                if (DEBUG_INPUT_METHOD) {
+                    Slog.v(TAG, "List after removing with new pos " + imPos + ":");
+                    logWindowList("  ");
+                }
+                imWin.mTargetAppToken = mInputMethodTarget.mAppToken;
+                reAddWindowLocked(imPos, imWin);
+                if (DEBUG_INPUT_METHOD) {
+                    Slog.v(TAG, "List after moving IM to " + imPos + ":");
+                    logWindowList("  ");
+                }
+                if (DN > 0) moveInputMethodDialogsLocked(imPos+1);
+            } else {
+                moveInputMethodDialogsLocked(imPos);
+            }
+
+        } else {
+            // In this case, the input method windows go in a fixed layer,
+            // because they aren't currently associated with a focus window.
+
+            if (imWin != null) {
+                if (DEBUG_INPUT_METHOD) Slog.v(TAG, "Moving IM from " + imPos);
+                tmpRemoveWindowLocked(0, imWin);
+                imWin.mTargetAppToken = null;
+                reAddWindowToListInOrderLocked(imWin);
+                if (DEBUG_INPUT_METHOD) {
+                    Slog.v(TAG, "List with no IM target:");
+                    logWindowList("  ");
+                }
+                if (DN > 0) moveInputMethodDialogsLocked(-1);;
+            } else {
+                moveInputMethodDialogsLocked(-1);;
+            }
+
+        }
+
+        if (needAssignLayers) {
+            assignLayersLocked();
+        }
+
+        return true;
+    }
+
+    void adjustInputMethodDialogsLocked() {
+        moveInputMethodDialogsLocked(findDesiredInputMethodWindowIndexLocked(true));
+    }
+
+    final boolean isWallpaperVisible(WindowState wallpaperTarget) {
+        if (DEBUG_WALLPAPER) Slog.v(TAG, "Wallpaper vis: target " + wallpaperTarget + ", obscured="
+                + (wallpaperTarget != null ? Boolean.toString(wallpaperTarget.mObscured) : "??")
+                + " anim=" + ((wallpaperTarget != null && wallpaperTarget.mAppToken != null)
+                        ? wallpaperTarget.mAppToken.mAppAnimator.animation : null)
+                + " upper=" + mUpperWallpaperTarget
+                + " lower=" + mLowerWallpaperTarget);
+        return (wallpaperTarget != null
+                        && (!wallpaperTarget.mObscured || (wallpaperTarget.mAppToken != null
+                                && wallpaperTarget.mAppToken.mAppAnimator.animation != null)))
+                || mUpperWallpaperTarget != null
+                || mLowerWallpaperTarget != null;
+    }
+
+    static final int ADJUST_WALLPAPER_LAYERS_CHANGED = 1<<1;
+    static final int ADJUST_WALLPAPER_VISIBILITY_CHANGED = 1<<2;
+
+    int adjustWallpaperWindowsLocked() {
+        mInnerFields.mWallpaperMayChange = false;
+        int changed = 0;
+
+        final int dw = mAppDisplayWidth;
+        final int dh = mAppDisplayHeight;
+
+        // First find top-most window that has asked to be on top of the
+        // wallpaper; all wallpapers go behind it.
+        final ArrayList<WindowState> localmWindows = mWindows;
+        int N = localmWindows.size();
+        WindowState w = null;
+        WindowState foundW = null;
+        int foundI = 0;
+        WindowState topCurW = null;
+        int topCurI = 0;
+        int windowDetachedI = -1;
+        int i = N;
+        while (i > 0) {
+            i--;
+            w = localmWindows.get(i);
+            if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {
+                if (topCurW == null) {
+                    topCurW = w;
+                    topCurI = i;
+                }
+                continue;
+            }
+            topCurW = null;
+            if (w != mAnimator.mWindowDetachedWallpaper && w.mAppToken != null) {
+                // If this window's app token is hidden and not animating,
+                // it is of no interest to us.
+                if (w.mAppToken.hidden && w.mAppToken.mAppAnimator.animation == null) {
+                    if (DEBUG_WALLPAPER) Slog.v(TAG,
+                            "Skipping hidden and not animating token: " + w);
+                    continue;
+                }
+            }
+            if (DEBUG_WALLPAPER) Slog.v(TAG, "Win #" + i + " " + w + ": readyfordisplay="
+                    + w.isReadyForDisplay() + " mDrawState=" + w.mWinAnimator.mDrawState);
+            if ((w.mAttrs.flags&FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay()
+                    && (mWallpaperTarget == w || w.isDrawnLw())) {
+                if (DEBUG_WALLPAPER) Slog.v(TAG,
+                        "Found wallpaper activity: #" + i + "=" + w);
+                foundW = w;
+                foundI = i;
+                if (w == mWallpaperTarget && w.mWinAnimator.isAnimating()) {
+                    // The current wallpaper target is animating, so we'll
+                    // look behind it for another possible target and figure
+                    // out what is going on below.
+                    if (DEBUG_WALLPAPER) Slog.v(TAG, "Win " + w
+                            + ": token animating, looking behind.");
+                    continue;
+                }
+                break;
+            } else if (w == mAnimator.mWindowDetachedWallpaper) {
+                windowDetachedI = i;
+            }
+        }
+
+        if (foundW == null && windowDetachedI >= 0) {
+            if (DEBUG_WALLPAPER) Slog.v(TAG,
+                    "Found animating detached wallpaper activity: #" + i + "=" + w);
+            foundW = w;
+            foundI = windowDetachedI;
+        }
+
+        if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
+            // If we are currently waiting for an app transition, and either
+            // the current target or the next target are involved with it,
+            // then hold off on doing anything with the wallpaper.
+            // Note that we are checking here for just whether the target
+            // is part of an app token...  which is potentially overly aggressive
+            // (the app token may not be involved in the transition), but good
+            // enough (we'll just wait until whatever transition is pending
+            // executes).
+            if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
+                if (DEBUG_WALLPAPER) Slog.v(TAG,
+                        "Wallpaper not changing: waiting for app anim in current target");
+                return 0;
+            }
+            if (foundW != null && foundW.mAppToken != null) {
+                if (DEBUG_WALLPAPER) Slog.v(TAG,
+                        "Wallpaper not changing: waiting for app anim in found target");
+                return 0;
+            }
+        }
+
+        if (mWallpaperTarget != foundW) {
+            if (DEBUG_WALLPAPER) {
+                Slog.v(TAG, "New wallpaper target: " + foundW
+                        + " oldTarget: " + mWallpaperTarget);
+            }
+
+            mLowerWallpaperTarget = null;
+            mUpperWallpaperTarget = null;
+
+            WindowState oldW = mWallpaperTarget;
+            mWallpaperTarget = foundW;
+
+            // Now what is happening...  if the current and new targets are
+            // animating, then we are in our super special mode!
+            if (foundW != null && oldW != null) {
+                boolean oldAnim = oldW.mWinAnimator.mAnimation != null
+                        || (oldW.mAppToken != null
+                            && oldW.mAppToken.mAppAnimator.animation != null);
+                boolean foundAnim = foundW.mWinAnimator.mAnimation != null
+                        || (foundW.mAppToken != null &&
+                            foundW.mAppToken.mAppAnimator.animation != null);
+                if (DEBUG_WALLPAPER) {
+                    Slog.v(TAG, "New animation: " + foundAnim
+                            + " old animation: " + oldAnim);
+                }
+                if (foundAnim && oldAnim) {
+                    int oldI = localmWindows.indexOf(oldW);
+                    if (DEBUG_WALLPAPER) {
+                        Slog.v(TAG, "New i: " + foundI + " old i: " + oldI);
+                    }
+                    if (oldI >= 0) {
+                        if (DEBUG_WALLPAPER) {
+                            Slog.v(TAG, "Animating wallpapers: old#" + oldI
+                                    + "=" + oldW + "; new#" + foundI
+                                    + "=" + foundW);
+                        }
+
+                        // Set the new target correctly.
+                        if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
+                            if (DEBUG_WALLPAPER) {
+                                Slog.v(TAG, "Old wallpaper still the target.");
+                            }
+                            mWallpaperTarget = oldW;
+                            foundW = oldW;
+                            foundI = oldI;
+                        } 
+                        // Now set the upper and lower wallpaper targets
+                        // correctly, and make sure that we are positioning
+                        // the wallpaper below the lower.
+                        else if (foundI > oldI) {
+                            // The new target is on top of the old one.
+                            if (DEBUG_WALLPAPER) {
+                                Slog.v(TAG, "Found target above old target.");
+                            }
+                            mUpperWallpaperTarget = foundW;
+                            mLowerWallpaperTarget = oldW;
+                            foundW = oldW;
+                            foundI = oldI;
+                        } else {
+                            // The new target is below the old one.
+                            if (DEBUG_WALLPAPER) {
+                                Slog.v(TAG, "Found target below old target.");
+                            }
+                            mUpperWallpaperTarget = oldW;
+                            mLowerWallpaperTarget = foundW;
+                        }
+                    }
+                }
+            }
+
+        } else if (mLowerWallpaperTarget != null) {
+            // Is it time to stop animating?
+            boolean lowerAnimating = mLowerWallpaperTarget.mWinAnimator.mAnimation != null
+                    || (mLowerWallpaperTarget.mAppToken != null
+                            && mLowerWallpaperTarget.mAppToken.mAppAnimator.animation != null);
+            boolean upperAnimating = mUpperWallpaperTarget.mWinAnimator.mAnimation != null
+                    || (mUpperWallpaperTarget.mAppToken != null
+                            && mUpperWallpaperTarget.mAppToken.mAppAnimator.animation != null);
+            if (!lowerAnimating || !upperAnimating) {
+                if (DEBUG_WALLPAPER) {
+                    Slog.v(TAG, "No longer animating wallpaper targets!");
+                }
+                mLowerWallpaperTarget = null;
+                mUpperWallpaperTarget = null;
+            }
+        }
+
+        boolean visible = foundW != null;
+        if (visible) {
+            // The window is visible to the compositor...  but is it visible
+            // to the user?  That is what the wallpaper cares about.
+            visible = isWallpaperVisible(foundW);
+            if (DEBUG_WALLPAPER) Slog.v(TAG, "Wallpaper visibility: " + visible);
+
+            // If the wallpaper target is animating, we may need to copy
+            // its layer adjustment.  Only do this if we are not transfering
+            // between two wallpaper targets.
+            mWallpaperAnimLayerAdjustment =
+                    (mLowerWallpaperTarget == null && foundW.mAppToken != null)
+                    ? foundW.mAppToken.mAppAnimator.animLayerAdjustment : 0;
+
+            final int maxLayer = mPolicy.getMaxWallpaperLayer()
+                    * TYPE_LAYER_MULTIPLIER
+                    + TYPE_LAYER_OFFSET;
+
+            // Now w is the window we are supposed to be behind...  but we
+            // need to be sure to also be behind any of its attached windows,
+            // AND any starting window associated with it, AND below the
+            // maximum layer the policy allows for wallpapers.
+            while (foundI > 0) {
+                WindowState wb = localmWindows.get(foundI-1);
+                if (wb.mBaseLayer < maxLayer &&
+                        wb.mAttachedWindow != foundW &&
+                        (foundW.mAttachedWindow == null ||
+                                wb.mAttachedWindow != foundW.mAttachedWindow) &&
+                        (wb.mAttrs.type != TYPE_APPLICATION_STARTING ||
+                                foundW.mToken == null || wb.mToken != foundW.mToken)) {
+                    // This window is not related to the previous one in any
+                    // interesting way, so stop here.
+                    break;
+                }
+                foundW = wb;
+                foundI--;
+            }
+        } else {
+            if (DEBUG_WALLPAPER) Slog.v(TAG, "No wallpaper target");
+        }
+
+        if (foundW == null && topCurW != null) {
+            // There is no wallpaper target, so it goes at the bottom.
+            // We will assume it is the same place as last time, if known.
+            foundW = topCurW;
+            foundI = topCurI+1;
+        } else {
+            // Okay i is the position immediately above the wallpaper.  Look at
+            // what is below it for later.
+            foundW = foundI > 0 ? localmWindows.get(foundI-1) : null;
+        }
+
+        if (visible) {
+            if (mWallpaperTarget.mWallpaperX >= 0) {
+                mLastWallpaperX = mWallpaperTarget.mWallpaperX;
+                mLastWallpaperXStep = mWallpaperTarget.mWallpaperXStep;
+            }
+            if (mWallpaperTarget.mWallpaperY >= 0) {
+                mLastWallpaperY = mWallpaperTarget.mWallpaperY;
+                mLastWallpaperYStep = mWallpaperTarget.mWallpaperYStep;
+            }
+        }
+
+        // Start stepping backwards from here, ensuring that our wallpaper windows
+        // are correctly placed.
+        int curTokenIndex = mWallpaperTokens.size();
+        while (curTokenIndex > 0) {
+            curTokenIndex--;
+            WindowToken token = mWallpaperTokens.get(curTokenIndex);
+            if (token.hidden == visible) {
+                changed |= ADJUST_WALLPAPER_VISIBILITY_CHANGED;
+                token.hidden = !visible;
+                // Need to do a layout to ensure the wallpaper now has the
+                // correct size.
+                mLayoutNeeded = true;
+            }
+
+            int curWallpaperIndex = token.windows.size();
+            while (curWallpaperIndex > 0) {
+                curWallpaperIndex--;
+                WindowState wallpaper = token.windows.get(curWallpaperIndex);
+
+                if (visible) {
+                    updateWallpaperOffsetLocked(wallpaper, dw, dh, false);
+                }
+
+                // First, make sure the client has the current visibility
+                // state.
+                dispatchWallpaperVisibility(wallpaper, visible);
+
+                wallpaper.mWinAnimator.mAnimLayer = wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
+                if (DEBUG_LAYERS || DEBUG_WALLPAPER) Slog.v(TAG, "adjustWallpaper win "
+                        + wallpaper + " anim layer: " + wallpaper.mWinAnimator.mAnimLayer);
+
+                // First, if this window is at the current index, then all
+                // is well.
+                if (wallpaper == foundW) {
+                    foundI--;
+                    foundW = foundI > 0
+                            ? localmWindows.get(foundI-1) : null;
+                    continue;
+                }
+
+                // The window didn't match...  the current wallpaper window,
+                // wherever it is, is in the wrong place, so make sure it is
+                // not in the list.
+                int oldIndex = localmWindows.indexOf(wallpaper);
+                if (oldIndex >= 0) {
+                    if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Wallpaper removing at "
+                            + oldIndex + ": " + wallpaper);
+                    localmWindows.remove(oldIndex);
+                    mWindowsChanged = true;
+                    if (oldIndex < foundI) {
+                        foundI--;
+                    }
+                }
+
+                // Now stick it in.
+                if (DEBUG_WALLPAPER || DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) {
+                    Slog.v(TAG, "Moving wallpaper " + wallpaper
+                            + " from " + oldIndex + " to " + foundI);
+                }
+
+                localmWindows.add(foundI, wallpaper);
+                mWindowsChanged = true;
+                changed |= ADJUST_WALLPAPER_LAYERS_CHANGED;
+            }
+        }
+
+        return changed;
+    }
+
+    void setWallpaperAnimLayerAdjustmentLocked(int adj) {
+        if (DEBUG_LAYERS || DEBUG_WALLPAPER) Slog.v(TAG,
+                "Setting wallpaper layer adj to " + adj);
+        mWallpaperAnimLayerAdjustment = adj;
+        int curTokenIndex = mWallpaperTokens.size();
+        while (curTokenIndex > 0) {
+            curTokenIndex--;
+            WindowToken token = mWallpaperTokens.get(curTokenIndex);
+            int curWallpaperIndex = token.windows.size();
+            while (curWallpaperIndex > 0) {
+                curWallpaperIndex--;
+                WindowState wallpaper = token.windows.get(curWallpaperIndex);
+                wallpaper.mWinAnimator.mAnimLayer = wallpaper.mLayer + adj;
+                if (DEBUG_LAYERS || DEBUG_WALLPAPER) Slog.v(TAG, "setWallpaper win "
+                        + wallpaper + " anim layer: " + wallpaper.mWinAnimator.mAnimLayer);
+            }
+        }
+    }
+
+    boolean updateWallpaperOffsetLocked(WindowState wallpaperWin, int dw, int dh,
+            boolean sync) {
+        boolean changed = false;
+        boolean rawChanged = false;
+        float wpx = mLastWallpaperX >= 0 ? mLastWallpaperX : 0.5f;
+        float wpxs = mLastWallpaperXStep >= 0 ? mLastWallpaperXStep : -1.0f;
+        int availw = wallpaperWin.mFrame.right-wallpaperWin.mFrame.left-dw;
+        int offset = availw > 0 ? -(int)(availw*wpx+.5f) : 0;
+        changed = wallpaperWin.mXOffset != offset;
+        if (changed) {
+            if (DEBUG_WALLPAPER) Slog.v(TAG, "Update wallpaper "
+                    + wallpaperWin + " x: " + offset);
+            wallpaperWin.mXOffset = offset;
+        }
+        if (wallpaperWin.mWallpaperX != wpx || wallpaperWin.mWallpaperXStep != wpxs) {
+            wallpaperWin.mWallpaperX = wpx;
+            wallpaperWin.mWallpaperXStep = wpxs;
+            rawChanged = true;
+        }
+
+        float wpy = mLastWallpaperY >= 0 ? mLastWallpaperY : 0.5f;
+        float wpys = mLastWallpaperYStep >= 0 ? mLastWallpaperYStep : -1.0f;
+        int availh = wallpaperWin.mFrame.bottom-wallpaperWin.mFrame.top-dh;
+        offset = availh > 0 ? -(int)(availh*wpy+.5f) : 0;
+        if (wallpaperWin.mYOffset != offset) {
+            if (DEBUG_WALLPAPER) Slog.v(TAG, "Update wallpaper "
+                    + wallpaperWin + " y: " + offset);
+            changed = true;
+            wallpaperWin.mYOffset = offset;
+        }
+        if (wallpaperWin.mWallpaperY != wpy || wallpaperWin.mWallpaperYStep != wpys) {
+            wallpaperWin.mWallpaperY = wpy;
+            wallpaperWin.mWallpaperYStep = wpys;
+            rawChanged = true;
+        }
+
+        if (rawChanged && (wallpaperWin.mAttrs.privateFlags &
+                    WindowManager.LayoutParams.PRIVATE_FLAG_WANTS_OFFSET_NOTIFICATIONS) != 0) {
+            try {
+                if (DEBUG_WALLPAPER) Slog.v(TAG, "Report new wp offset "
+                        + wallpaperWin + " x=" + wallpaperWin.mWallpaperX
+                        + " y=" + wallpaperWin.mWallpaperY);
+                if (sync) {
+                    mWaitingOnWallpaper = wallpaperWin;
+                }
+                wallpaperWin.mClient.dispatchWallpaperOffsets(
+                        wallpaperWin.mWallpaperX, wallpaperWin.mWallpaperY,
+                        wallpaperWin.mWallpaperXStep, wallpaperWin.mWallpaperYStep, sync);
+                if (sync) {
+                    if (mWaitingOnWallpaper != null) {
+                        long start = SystemClock.uptimeMillis();
+                        if ((mLastWallpaperTimeoutTime+WALLPAPER_TIMEOUT_RECOVERY)
+                                < start) {
+                            try {
+                                if (DEBUG_WALLPAPER) Slog.v(TAG,
+                                        "Waiting for offset complete...");
+                                mWindowMap.wait(WALLPAPER_TIMEOUT);
+                            } catch (InterruptedException e) {
+                            }
+                            if (DEBUG_WALLPAPER) Slog.v(TAG, "Offset complete!");
+                            if ((start+WALLPAPER_TIMEOUT)
+                                    < SystemClock.uptimeMillis()) {
+                                Slog.i(TAG, "Timeout waiting for wallpaper to offset: "
+                                        + wallpaperWin);
+                                mLastWallpaperTimeoutTime = start;
+                            }
+                        }
+                        mWaitingOnWallpaper = null;
+                    }
+                }
+            } catch (RemoteException e) {
+            }
+        }
+
+        return changed;
+    }
+
+    void wallpaperOffsetsComplete(IBinder window) {
+        synchronized (mWindowMap) {
+            if (mWaitingOnWallpaper != null &&
+                    mWaitingOnWallpaper.mClient.asBinder() == window) {
+                mWaitingOnWallpaper = null;
+                mWindowMap.notifyAll();
+            }
+        }
+    }
+
+    // TODO(cmautner):  Move to WindowAnimator.
+    void setWallpaperOffset(final WindowStateAnimator winAnimator, final int left, final int top) {
+        mH.sendMessage(mH.obtainMessage(H.SET_WALLPAPER_OFFSET, left, top, winAnimator));
+    }
+
+    void updateWallpaperOffsetLocked(WindowState changingTarget, boolean sync) {
+        final int dw = mAppDisplayWidth;
+        final int dh = mAppDisplayHeight;
+
+        WindowState target = mWallpaperTarget;
+        if (target != null) {
+            if (target.mWallpaperX >= 0) {
+                mLastWallpaperX = target.mWallpaperX;
+            } else if (changingTarget.mWallpaperX >= 0) {
+                mLastWallpaperX = changingTarget.mWallpaperX;
+            }
+            if (target.mWallpaperY >= 0) {
+                mLastWallpaperY = target.mWallpaperY;
+            } else if (changingTarget.mWallpaperY >= 0) {
+                mLastWallpaperY = changingTarget.mWallpaperY;
+            }
+        }
+
+        int curTokenIndex = mWallpaperTokens.size();
+        while (curTokenIndex > 0) {
+            curTokenIndex--;
+            WindowToken token = mWallpaperTokens.get(curTokenIndex);
+            int curWallpaperIndex = token.windows.size();
+            while (curWallpaperIndex > 0) {
+                curWallpaperIndex--;
+                WindowState wallpaper = token.windows.get(curWallpaperIndex);
+                if (updateWallpaperOffsetLocked(wallpaper, dw, dh, sync)) {
+                    WindowStateAnimator winAnimator = wallpaper.mWinAnimator;
+                    winAnimator.computeShownFrameLocked();
+                    // No need to lay out the windows - we can just set the wallpaper position
+                    // directly.
+                    // TODO(cmautner): Don't move this from here, just lock the WindowAnimator.
+                    if (winAnimator.mSurfaceX != wallpaper.mShownFrame.left
+                            || winAnimator.mSurfaceY != wallpaper.mShownFrame.top) {
+                        Surface.openTransaction();
+                        try {
+                            if (SHOW_TRANSACTIONS) logSurface(wallpaper,
+                                    "POS " + wallpaper.mShownFrame.left
+                                    + ", " + wallpaper.mShownFrame.top, null);
+                            setWallpaperOffset(winAnimator, (int) wallpaper.mShownFrame.left,
+                                (int) wallpaper.mShownFrame.top);
+                        } catch (RuntimeException e) {
+                            Slog.w(TAG, "Error positioning surface of " + wallpaper
+                                    + " pos=(" + wallpaper.mShownFrame.left
+                                    + "," + wallpaper.mShownFrame.top + ")", e);
+                        }
+                        Surface.closeTransaction();
+                    }
+                    // We only want to be synchronous with one wallpaper.
+                    sync = false;
+                }
+            }
+        }
+    }
+
+    /**
+     * Check wallpaper for visiblity change and notify window if so.
+     * @param wallpaper The wallpaper to test and notify.
+     * @param visible Current visibility.
+     */
+    void dispatchWallpaperVisibility(final WindowState wallpaper, final boolean visible) {
+        if (wallpaper.mWallpaperVisible != visible) {
+            wallpaper.mWallpaperVisible = visible;
+            try {
+                if (DEBUG_VISIBILITY || DEBUG_WALLPAPER) Slog.v(TAG,
+                        "Updating visibility of wallpaper " + wallpaper
+                        + ": " + visible + " Callers=" + Debug.getCallers(2));
+                wallpaper.mClient.dispatchAppVisibility(visible);
+            } catch (RemoteException e) {
+            }
+        }
+    }
+
+    void updateWallpaperVisibilityLocked() {
+        final boolean visible = isWallpaperVisible(mWallpaperTarget);
+        final int dw = mAppDisplayWidth;
+        final int dh = mAppDisplayHeight;
+
+        int curTokenIndex = mWallpaperTokens.size();
+        while (curTokenIndex > 0) {
+            curTokenIndex--;
+            WindowToken token = mWallpaperTokens.get(curTokenIndex);
+            if (token.hidden == visible) {
+                token.hidden = !visible;
+                // Need to do a layout to ensure the wallpaper now has the
+                // correct size.
+                mLayoutNeeded = true;
+            }
+
+            int curWallpaperIndex = token.windows.size();
+            while (curWallpaperIndex > 0) {
+                curWallpaperIndex--;
+                WindowState wallpaper = token.windows.get(curWallpaperIndex);
+                if (visible) {
+                    updateWallpaperOffsetLocked(wallpaper, dw, dh, false);
+                }
+
+                dispatchWallpaperVisibility(wallpaper, visible);
+            }
+        }
+    }
+    
+    public int addWindow(Session session, IWindow client, int seq,
+            WindowManager.LayoutParams attrs, int viewVisibility,
+            Rect outContentInsets, InputChannel outInputChannel) {
+        int res = mPolicy.checkAddPermission(attrs);
+        if (res != WindowManagerImpl.ADD_OKAY) {
+            return res;
+        }
+
+        boolean reportNewConfig = false;
+        WindowState attachedWindow = null;
+        WindowState win = null;
+        long origId;
+
+        synchronized(mWindowMap) {
+            if (mDisplay == null) {
+                throw new IllegalStateException("Display has not been initialialized");
+            }
+
+            if (mWindowMap.containsKey(client.asBinder())) {
+                Slog.w(TAG, "Window " + client + " is already added");
+                return WindowManagerImpl.ADD_DUPLICATE_ADD;
+            }
+
+            if (attrs.type >= FIRST_SUB_WINDOW && attrs.type <= LAST_SUB_WINDOW) {
+                attachedWindow = windowForClientLocked(null, attrs.token, false);
+                if (attachedWindow == null) {
+                    Slog.w(TAG, "Attempted to add window with token that is not a window: "
+                          + attrs.token + ".  Aborting.");
+                    return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
+                }
+                if (attachedWindow.mAttrs.type >= FIRST_SUB_WINDOW
+                        && attachedWindow.mAttrs.type <= LAST_SUB_WINDOW) {
+                    Slog.w(TAG, "Attempted to add window with token that is a sub-window: "
+                            + attrs.token + ".  Aborting.");
+                    return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
+                }
+            }
+
+            boolean addToken = false;
+            WindowToken token = mTokenMap.get(attrs.token);
+            if (token == null) {
+                if (attrs.type >= FIRST_APPLICATION_WINDOW
+                        && attrs.type <= LAST_APPLICATION_WINDOW) {
+                    Slog.w(TAG, "Attempted to add application window with unknown token "
+                          + attrs.token + ".  Aborting.");
+                    return WindowManagerImpl.ADD_BAD_APP_TOKEN;
+                }
+                if (attrs.type == TYPE_INPUT_METHOD) {
+                    Slog.w(TAG, "Attempted to add input method window with unknown token "
+                          + attrs.token + ".  Aborting.");
+                    return WindowManagerImpl.ADD_BAD_APP_TOKEN;
+                }
+                if (attrs.type == TYPE_WALLPAPER) {
+                    Slog.w(TAG, "Attempted to add wallpaper window with unknown token "
+                          + attrs.token + ".  Aborting.");
+                    return WindowManagerImpl.ADD_BAD_APP_TOKEN;
+                }
+                if (attrs.type == TYPE_DREAM) {
+                    Slog.w(TAG, "Attempted to add Dream window with unknown token "
+                          + attrs.token + ".  Aborting.");
+                    return WindowManagerImpl.ADD_BAD_APP_TOKEN;
+                }
+                token = new WindowToken(this, attrs.token, -1, false);
+                addToken = true;
+            } else if (attrs.type >= FIRST_APPLICATION_WINDOW
+                    && attrs.type <= LAST_APPLICATION_WINDOW) {
+                AppWindowToken atoken = token.appWindowToken;
+                if (atoken == null) {
+                    Slog.w(TAG, "Attempted to add window with non-application token "
+                          + token + ".  Aborting.");
+                    return WindowManagerImpl.ADD_NOT_APP_TOKEN;
+                } else if (atoken.removed) {
+                    Slog.w(TAG, "Attempted to add window with exiting application token "
+                          + token + ".  Aborting.");
+                    return WindowManagerImpl.ADD_APP_EXITING;
+                }
+                if (attrs.type == TYPE_APPLICATION_STARTING && atoken.firstWindowDrawn) {
+                    // No need for this guy!
+                    if (localLOGV) Slog.v(
+                            TAG, "**** NO NEED TO START: " + attrs.getTitle());
+                    return WindowManagerImpl.ADD_STARTING_NOT_NEEDED;
+                }
+            } else if (attrs.type == TYPE_INPUT_METHOD) {
+                if (token.windowType != TYPE_INPUT_METHOD) {
+                    Slog.w(TAG, "Attempted to add input method window with bad token "
+                            + attrs.token + ".  Aborting.");
+                      return WindowManagerImpl.ADD_BAD_APP_TOKEN;
+                }
+            } else if (attrs.type == TYPE_WALLPAPER) {
+                if (token.windowType != TYPE_WALLPAPER) {
+                    Slog.w(TAG, "Attempted to add wallpaper window with bad token "
+                            + attrs.token + ".  Aborting.");
+                      return WindowManagerImpl.ADD_BAD_APP_TOKEN;
+                }
+            } else if (attrs.type == TYPE_DREAM) {
+                if (token.windowType != TYPE_DREAM) {
+                    Slog.w(TAG, "Attempted to add Dream window with bad token "
+                            + attrs.token + ".  Aborting.");
+                      return WindowManagerImpl.ADD_BAD_APP_TOKEN;
+                }
+            }
+
+            win = new WindowState(this, session, client, token,
+                    attachedWindow, seq, attrs, viewVisibility);
+            if (win.mDeathRecipient == null) {
+                // Client has apparently died, so there is no reason to
+                // continue.
+                Slog.w(TAG, "Adding window client " + client.asBinder()
+                        + " that is dead, aborting.");
+                return WindowManagerImpl.ADD_APP_EXITING;
+            }
+
+            mPolicy.adjustWindowParamsLw(win.mAttrs);
+
+            res = mPolicy.prepareAddWindowLw(win, attrs);
+            if (res != WindowManagerImpl.ADD_OKAY) {
+                return res;
+            }
+            
+            if (outInputChannel != null && (attrs.inputFeatures
+                    & WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {
+                String name = win.makeInputChannelName();
+                InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);
+                win.setInputChannel(inputChannels[0]);
+                inputChannels[1].transferTo(outInputChannel);
+                
+                mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);
+            }
+
+            // From now on, no exceptions or errors allowed!
+
+            res = WindowManagerImpl.ADD_OKAY;
+
+            origId = Binder.clearCallingIdentity();
+
+            if (addToken) {
+                mTokenMap.put(attrs.token, token);
+            }
+            win.attach();
+            mWindowMap.put(client.asBinder(), win);
+
+            if (attrs.type == TYPE_APPLICATION_STARTING &&
+                    token.appWindowToken != null) {
+                token.appWindowToken.startingWindow = win;
+                if (DEBUG_STARTING_WINDOW) Slog.v (TAG, "addWindow: " + token.appWindowToken
+                        + " startingWindow=" + win);
+            }
+
+            boolean imMayMove = true;
+
+            if (attrs.type == TYPE_INPUT_METHOD) {
+                win.mGivenInsetsPending = true;
+                mInputMethodWindow = win;
+                addInputMethodWindowToListLocked(win);
+                imMayMove = false;
+            } else if (attrs.type == TYPE_INPUT_METHOD_DIALOG) {
+                mInputMethodDialogs.add(win);
+                addWindowToListInOrderLocked(win, true);
+                adjustInputMethodDialogsLocked();
+                imMayMove = false;
+            } else {
+                addWindowToListInOrderLocked(win, true);
+                if (attrs.type == TYPE_WALLPAPER) {
+                    mLastWallpaperTimeoutTime = 0;
+                    adjustWallpaperWindowsLocked();
+                } else if ((attrs.flags&FLAG_SHOW_WALLPAPER) != 0) {
+                    adjustWallpaperWindowsLocked();
+                }
+            }
+
+            win.mWinAnimator.mEnterAnimationPending = true;
+
+            mPolicy.getContentInsetHintLw(attrs, outContentInsets);
+
+            if (mInTouchMode) {
+                res |= WindowManagerImpl.ADD_FLAG_IN_TOUCH_MODE;
+            }
+            if (win.mAppToken == null || !win.mAppToken.clientHidden) {
+                res |= WindowManagerImpl.ADD_FLAG_APP_VISIBLE;
+            }
+
+            mInputMonitor.setUpdateInputWindowsNeededLw();
+
+            boolean focusChanged = false;
+            if (win.canReceiveKeys()) {
+                focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS,
+                        false /*updateInputWindows*/);
+                if (focusChanged) {
+                    imMayMove = false;
+                }
+            }
+
+            if (imMayMove) {
+                moveInputMethodWindowsIfNeededLocked(false);
+            }
+
+            assignLayersLocked();
+            // Don't do layout here, the window must call
+            // relayout to be displayed, so we'll do it there.
+
+            //dump();
+
+            if (focusChanged) {
+                finishUpdateFocusedWindowAfterAssignLayersLocked(false /*updateInputWindows*/);
+            }
+            mInputMonitor.updateInputWindowsLw(false /*force*/);
+
+            if (localLOGV) Slog.v(
+                TAG, "New client " + client.asBinder()
+                + ": window=" + win);
+            
+            if (win.isVisibleOrAdding() && updateOrientationFromAppTokensLocked(false)) {
+                reportNewConfig = true;
+            }
+        }
+
+        if (reportNewConfig) {
+            sendNewConfiguration();
+        }
+
+        Binder.restoreCallingIdentity(origId);
+
+        return res;
+    }
+
+    public void removeWindow(Session session, IWindow client) {
+        synchronized(mWindowMap) {
+            WindowState win = windowForClientLocked(session, client, false);
+            if (win == null) {
+                return;
+            }
+            removeWindowLocked(session, win);
+        }
+    }
+
+    public void removeWindowLocked(Session session, WindowState win) {
+
+        if (localLOGV || DEBUG_FOCUS) Slog.v(
+            TAG, "Remove " + win + " client="
+            + Integer.toHexString(System.identityHashCode(
+                win.mClient.asBinder()))
+            + ", surface=" + win.mWinAnimator.mSurface);
+
+        final long origId = Binder.clearCallingIdentity();
+
+        win.disposeInputChannel();
+
+        if (DEBUG_APP_TRANSITIONS) Slog.v(
+                TAG, "Remove " + win + ": mSurface=" + win.mWinAnimator.mSurface
+                + " mExiting=" + win.mExiting
+                + " isAnimating=" + win.mWinAnimator.isAnimating()
+                + " app-animation="
+                + (win.mAppToken != null ? win.mAppToken.mAppAnimator.animation : null)
+                + " inPendingTransaction="
+                + (win.mAppToken != null ? win.mAppToken.inPendingTransaction : false)
+                + " mDisplayFrozen=" + mDisplayFrozen);
+        // Visibility of the removed window. Will be used later to update orientation later on.
+        boolean wasVisible = false;
+        // First, see if we need to run an animation.  If we do, we have
+        // to hold off on removing the window until the animation is done.
+        // If the display is frozen, just remove immediately, since the
+        // animation wouldn't be seen.
+        if (win.mHasSurface && okToDisplay()) {
+            // If we are not currently running the exit animation, we
+            // need to see about starting one.
+            wasVisible = win.isWinVisibleLw();
+            if (wasVisible) {
+
+                int transit = WindowManagerPolicy.TRANSIT_EXIT;
+                if (win.mAttrs.type == TYPE_APPLICATION_STARTING) {
+                    transit = WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
+                }
+                // Try starting an animation.
+                if (win.mWinAnimator.applyAnimationLocked(transit, false)) {
+                    win.mExiting = true;
+                }
+            }
+            if (win.mExiting || win.mWinAnimator.isAnimating()) {
+                // The exit animation is running... wait for it!
+                //Slog.i(TAG, "*** Running exit animation...");
+                win.mExiting = true;
+                win.mRemoveOnExit = true;
+                mLayoutNeeded = true;
+                updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,
+                        false /*updateInputWindows*/);
+                performLayoutAndPlaceSurfacesLocked();
+                mInputMonitor.updateInputWindowsLw(false /*force*/);
+                if (win.mAppToken != null) {
+                    win.mAppToken.updateReportedVisibilityLocked();
+                }
+                //dump();
+                Binder.restoreCallingIdentity(origId);
+                return;
+            }
+        }
+
+        removeWindowInnerLocked(session, win);
+        // Removing a visible window will effect the computed orientation
+        // So just update orientation if needed.
+        if (wasVisible && computeForcedAppOrientationLocked()
+                != mForcedAppOrientation
+                && updateOrientationFromAppTokensLocked(false)) {
+            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
+        }
+        updateFocusedWindowLocked(UPDATE_FOCUS_NORMAL, true /*updateInputWindows*/);
+        Binder.restoreCallingIdentity(origId);
+    }
+
+    private void removeWindowInnerLocked(Session session, WindowState win) {
+        if (win.mRemoved) {
+            // Nothing to do.
+            return;
+        }
+
+        for (int i=win.mChildWindows.size()-1; i>=0; i--) {
+            WindowState cwin = win.mChildWindows.get(i);
+            Slog.w(TAG, "Force-removing child win " + cwin + " from container "
+                    + win);
+            removeWindowInnerLocked(cwin.mSession, cwin);
+        }
+
+        win.mRemoved = true;
+
+        if (mInputMethodTarget == win) {
+            moveInputMethodWindowsIfNeededLocked(false);
+        }
+
+        if (false) {
+            RuntimeException e = new RuntimeException("here");
+            e.fillInStackTrace();
+            Slog.w(TAG, "Removing window " + win, e);
+        }
+
+        mPolicy.removeWindowLw(win);
+        win.removeLocked();
+
+        if (DEBUG_ADD_REMOVE) Slog.v(TAG, "removeWindowInnerLocked: " + win);
+        mWindowMap.remove(win.mClient.asBinder());
+        mWindows.remove(win);
+        mPendingRemove.remove(win);
+        mWindowsChanged = true;
+        if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Final remove of window: " + win);
+
+        if (mInputMethodWindow == win) {
+            mInputMethodWindow = null;
+        } else if (win.mAttrs.type == TYPE_INPUT_METHOD_DIALOG) {
+            mInputMethodDialogs.remove(win);
+        }
+
+        final WindowToken token = win.mToken;
+        final AppWindowToken atoken = win.mAppToken;
+        if (DEBUG_ADD_REMOVE) Slog.v(TAG, "Removing " + win + " from " + token);
+        token.windows.remove(win);
+        if (atoken != null) {
+            atoken.allAppWindows.remove(win);
+        }
+        if (localLOGV) Slog.v(
+                TAG, "**** Removing window " + win + ": count="
+                + token.windows.size());
+        if (token.windows.size() == 0) {
+            if (!token.explicit) {
+                mTokenMap.remove(token.token);
+            } else if (atoken != null) {
+                atoken.firstWindowDrawn = false;
+            }
+        }
+
+        if (atoken != null) {
+            if (atoken.startingWindow == win) {
+                if (DEBUG_STARTING_WINDOW) Slog.v(TAG, "Nulling startingWindow " + win);
+                atoken.startingWindow = null;
+            } else if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {
+                // If this is the last window and we had requested a starting
+                // transition window, well there is no point now.
+                if (DEBUG_STARTING_WINDOW) Slog.v(TAG, "Nulling last startingWindow");
+                atoken.startingData = null;
+            } else if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {
+                // If this is the last window except for a starting transition
+                // window, we need to get rid of the starting transition.
+                if (DEBUG_STARTING_WINDOW) {
+                    Slog.v(TAG, "Schedule remove starting " + token
+                            + ": no more real windows");
+                }
+                Message m = mH.obtainMessage(H.REMOVE_STARTING, atoken);
+                mH.sendMessage(m);
+            }
+        }
+
+        if (win.mAttrs.type == TYPE_WALLPAPER) {
+            mLastWallpaperTimeoutTime = 0;
+            adjustWallpaperWindowsLocked();
+        } else if ((win.mAttrs.flags&FLAG_SHOW_WALLPAPER) != 0) {
+            adjustWallpaperWindowsLocked();
+        }
+
+        if (!mInLayout) {
+            assignLayersLocked();
+            mLayoutNeeded = true;
+            performLayoutAndPlaceSurfacesLocked();
+            if (win.mAppToken != null) {
+                win.mAppToken.updateReportedVisibilityLocked();
+            }
+        }
+        
+        mInputMonitor.updateInputWindowsLw(true /*force*/);
+    }
+
+    static void logSurface(WindowState w, String msg, RuntimeException where) {
+        String str = "  SURFACE " + msg + ": " + w;
+        if (where != null) {
+            Slog.i(TAG, str, where);
+        } else {
+            Slog.i(TAG, str);
+        }
+    }
+
+    static void logSurface(Surface s, String title, String msg, RuntimeException where) {
+        String str = "  SURFACE " + s + ": " + msg + " / " + title;
+        if (where != null) {
+            Slog.i(TAG, str, where);
+        } else {
+            Slog.i(TAG, str);
+        }
+    }
+
+    // TODO(cmautner): Move to WindowStateAnimator.
+    void setTransparentRegionHint(final WindowStateAnimator winAnimator, final Region region) {
+        mH.sendMessage(mH.obtainMessage(H.SET_TRANSPARENT_REGION,
+                new Pair<WindowStateAnimator, Region>(winAnimator, region)));
+    }
+
+    void setTransparentRegionWindow(Session session, IWindow client, Region region) {
+        long origId = Binder.clearCallingIdentity();
+        try {
+            synchronized (mWindowMap) {
+                WindowState w = windowForClientLocked(session, client, false);
+                if ((w != null) && w.mHasSurface) {
+                    setTransparentRegionHint(w.mWinAnimator, region);
+                }
+            }
+        } finally {
+            Binder.restoreCallingIdentity(origId);
+        }
+    }
+
+    void setInsetsWindow(Session session, IWindow client,
+            int touchableInsets, Rect contentInsets,
+            Rect visibleInsets, Region touchableRegion) {
+        long origId = Binder.clearCallingIdentity();
+        try {
+            synchronized (mWindowMap) {
+                WindowState w = windowForClientLocked(session, client, false);
+                if (w != null) {
+                    w.mGivenInsetsPending = false;
+                    w.mGivenContentInsets.set(contentInsets);
+                    w.mGivenVisibleInsets.set(visibleInsets);
+                    w.mGivenTouchableRegion.set(touchableRegion);
+                    w.mTouchableInsets = touchableInsets;
+                    if (w.mGlobalScale != 1) {
+                        w.mGivenContentInsets.scale(w.mGlobalScale);
+                        w.mGivenVisibleInsets.scale(w.mGlobalScale);
+                        w.mGivenTouchableRegion.scale(w.mGlobalScale);
+                    }
+                    mLayoutNeeded = true;
+                    performLayoutAndPlaceSurfacesLocked();
+                }
+            }
+        } finally {
+            Binder.restoreCallingIdentity(origId);
+        }
+    }
+
+    public void getWindowDisplayFrame(Session session, IWindow client,
+            Rect outDisplayFrame) {
+        synchronized(mWindowMap) {
+            WindowState win = windowForClientLocked(session, client, false);
+            if (win == null) {
+                outDisplayFrame.setEmpty();
+                return;
+            }
+            outDisplayFrame.set(win.mDisplayFrame);
+        }
+    }
+
+    public void setWindowWallpaperPositionLocked(WindowState window, float x, float y,
+            float xStep, float yStep) {
+        if (window.mWallpaperX != x || window.mWallpaperY != y)  {
+            window.mWallpaperX = x;
+            window.mWallpaperY = y;
+            window.mWallpaperXStep = xStep;
+            window.mWallpaperYStep = yStep;
+            updateWallpaperOffsetLocked(window, true);
+        }
+    }
+
+    void wallpaperCommandComplete(IBinder window, Bundle result) {
+        synchronized (mWindowMap) {
+            if (mWaitingOnWallpaper != null &&
+                    mWaitingOnWallpaper.mClient.asBinder() == window) {
+                mWaitingOnWallpaper = null;
+                mWindowMap.notifyAll();
+            }
+        }
+    }
+
+    public Bundle sendWindowWallpaperCommandLocked(WindowState window,
+            String action, int x, int y, int z, Bundle extras, boolean sync) {
+        if (window == mWallpaperTarget || window == mLowerWallpaperTarget
+                || window == mUpperWallpaperTarget) {
+            boolean doWait = sync;
+            int curTokenIndex = mWallpaperTokens.size();
+            while (curTokenIndex > 0) {
+                curTokenIndex--;
+                WindowToken token = mWallpaperTokens.get(curTokenIndex);
+                int curWallpaperIndex = token.windows.size();
+                while (curWallpaperIndex > 0) {
+                    curWallpaperIndex--;
+                    WindowState wallpaper = token.windows.get(curWallpaperIndex);
+                    try {
+                        wallpaper.mClient.dispatchWallpaperCommand(action,
+                                x, y, z, extras, sync);
+                        // We only want to be synchronous with one wallpaper.
+                        sync = false;
+                    } catch (RemoteException e) {
+                    }
+                }
+            }
+
+            if (doWait) {
+                // XXX Need to wait for result.
+            }
+        }
+
+        return null;
+    }
+
+    public int relayoutWindow(Session session, IWindow client, int seq,
+            WindowManager.LayoutParams attrs, int requestedWidth,
+            int requestedHeight, int viewVisibility, int flags,
+            Rect outFrame, Rect outContentInsets,
+            Rect outVisibleInsets, Configuration outConfig, Surface outSurface) {
+        boolean toBeDisplayed = false;
+        boolean inTouchMode;
+        boolean configChanged;
+        boolean surfaceChanged = false;
+        boolean animating;
+
+        // if they don't have this permission, mask out the status bar bits
+        int systemUiVisibility = 0;
+        if (attrs != null) {
+            systemUiVisibility = (attrs.systemUiVisibility|attrs.subtreeSystemUiVisibility);
+            if ((systemUiVisibility & StatusBarManager.DISABLE_MASK) != 0) {
+                if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR)
+                        != PackageManager.PERMISSION_GRANTED) {
+                    systemUiVisibility &= ~StatusBarManager.DISABLE_MASK;
+                }
+            }
+        }
+        long origId = Binder.clearCallingIdentity();
+
+        synchronized(mWindowMap) {
+            // TODO(cmautner): synchronize on mAnimator or win.mWinAnimator.
+            WindowState win = windowForClientLocked(session, client, false);
+            if (win == null) {
+                return 0;
+            }
+            WindowStateAnimator winAnimator = win.mWinAnimator;
+            if (win.mRequestedWidth != requestedWidth
+                    || win.mRequestedHeight != requestedHeight) {
+                win.mLayoutNeeded = true;
+                win.mRequestedWidth = requestedWidth;
+                win.mRequestedHeight = requestedHeight;
+            }
+            if (attrs != null && seq == win.mSeq) {
+                win.mSystemUiVisibility = systemUiVisibility;
+            }
+
+            if (attrs != null) {
+                mPolicy.adjustWindowParamsLw(attrs);
+            }
+
+            winAnimator.mSurfaceDestroyDeferred =
+                    (flags&WindowManagerImpl.RELAYOUT_DEFER_SURFACE_DESTROY) != 0;
+
+            int attrChanges = 0;
+            int flagChanges = 0;
+            if (attrs != null) {
+                if (win.mAttrs.type != attrs.type) {
+                    throw new IllegalArgumentException(
+                            "Window type can not be changed after the window is added.");
+                }
+                flagChanges = win.mAttrs.flags ^= attrs.flags;
+                attrChanges = win.mAttrs.copyFrom(attrs);
+                if ((attrChanges & (WindowManager.LayoutParams.LAYOUT_CHANGED
+                        | WindowManager.LayoutParams.SYSTEM_UI_VISIBILITY_CHANGED)) != 0) {
+                    win.mLayoutNeeded = true;
+                }
+            }
+
+            if (DEBUG_LAYOUT) Slog.v(TAG, "Relayout " + win + ": " + win.mAttrs);
+
+            win.mEnforceSizeCompat = (win.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0;
+
+            if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
+                winAnimator.mAlpha = attrs.alpha;
+            }
+
+            final boolean scaledWindow =
+                ((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
+
+            if (scaledWindow) {
+                // requested{Width|Height} Surface's physical size
+                // attrs.{width|height} Size on screen
+                win.mHScale = (attrs.width  != requestedWidth)  ?
+                        (attrs.width  / (float)requestedWidth) : 1.0f;
+                win.mVScale = (attrs.height != requestedHeight) ?
+                        (attrs.height / (float)requestedHeight) : 1.0f;
+            } else {
+                win.mHScale = win.mVScale = 1;
+            }
+
+            boolean imMayMove = (flagChanges&(
+                    WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM |
+                    WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
+
+            boolean focusMayChange = win.mViewVisibility != viewVisibility
+                    || ((flagChanges&WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0)
+                    || (!win.mRelayoutCalled);
+
+            boolean wallpaperMayMove = win.mViewVisibility != viewVisibility
+                    && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
+            wallpaperMayMove |= (flagChanges & FLAG_SHOW_WALLPAPER) != 0;
+
+            win.mRelayoutCalled = true;
+            final int oldVisibility = win.mViewVisibility;
+            win.mViewVisibility = viewVisibility;
+            if (DEBUG_SCREEN_ON) {
+                RuntimeException stack = new RuntimeException();
+                stack.fillInStackTrace();
+                Slog.i(TAG, "Relayout " + win + ": oldVis=" + oldVisibility
+                        + " newVis=" + viewVisibility, stack);
+            }
+            if (viewVisibility == View.VISIBLE &&
+                    (win.mAppToken == null || !win.mAppToken.clientHidden)) {
+                toBeDisplayed = !win.isVisibleLw();
+                if (win.mExiting) {
+                    winAnimator.cancelExitAnimationForNextAnimationLocked();
+                    win.mExiting = false;
+                }
+                if (win.mDestroying) {
+                    win.mDestroying = false;
+                    mDestroySurface.remove(win);
+                }
+                if (oldVisibility == View.GONE) {
+                    winAnimator.mEnterAnimationPending = true;
+                }
+                if (toBeDisplayed) {
+                    if (win.isDrawnLw() && okToDisplay()) {
+                        winAnimator.applyEnterAnimationLocked();
+                    }
+                    if ((win.mAttrs.flags
+                            & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
+                        if (DEBUG_VISIBILITY) Slog.v(TAG,
+                                "Relayout window turning screen on: " + win);
+                        win.mTurnOnScreen = true;
+                    }
+                    int diff = 0;
+                    if (win.mConfiguration != mCurConfiguration
+                            && (win.mConfiguration == null
+                                    || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0)) {
+                        win.mConfiguration = mCurConfiguration;
+                        if (DEBUG_CONFIGURATION) {
+                            Slog.i(TAG, "Window " + win + " visible with new config: "
+                                    + win.mConfiguration + " / 0x"
+                                    + Integer.toHexString(diff));
+                        }
+                        outConfig.setTo(mCurConfiguration);
+                    }
+                }
+                if ((attrChanges&WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
+                    // To change the format, we need to re-build the surface.
+                    winAnimator.destroySurfaceLocked();
+                    toBeDisplayed = true;
+                    surfaceChanged = true;
+                }
+                try {
+                    if (!win.mHasSurface) {
+                        surfaceChanged = true;
+                    }
+                    Surface surface = winAnimator.createSurfaceLocked();
+                    if (surface != null) {
+                        outSurface.copyFrom(surface);
+                        if (SHOW_TRANSACTIONS) Slog.i(TAG,
+                                "  OUT SURFACE " + outSurface + ": copied");
+                    } else {
+                        // For some reason there isn't a surface.  Clear the
+                        // caller's object so they see the same state.
+                        outSurface.release();
+                    }
+                } catch (Exception e) {
+                    mInputMonitor.updateInputWindowsLw(true /*force*/);
+                    
+                    Slog.w(TAG, "Exception thrown when creating surface for client "
+                             + client + " (" + win.mAttrs.getTitle() + ")",
+                             e);
+                    Binder.restoreCallingIdentity(origId);
+                    return 0;
+                }
+                if (toBeDisplayed) {
+                    focusMayChange = true;
+                }
+                if (win.mAttrs.type == TYPE_INPUT_METHOD
+                        && mInputMethodWindow == null) {
+                    mInputMethodWindow = win;
+                    imMayMove = true;
+                }
+                if (win.mAttrs.type == TYPE_BASE_APPLICATION
+                        && win.mAppToken != null
+                        && win.mAppToken.startingWindow != null) {
+                    // Special handling of starting window over the base
+                    // window of the app: propagate lock screen flags to it,
+                    // to provide the correct semantics while starting.
+                    final int mask =
+                        WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED
+                        | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD
+                        | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON;
+                    WindowManager.LayoutParams sa = win.mAppToken.startingWindow.mAttrs;
+                    sa.flags = (sa.flags&~mask) | (win.mAttrs.flags&mask);
+                }
+            } else {
+                winAnimator.mEnterAnimationPending = false;
+                if (winAnimator.mSurface != null) {
+                    if (DEBUG_VISIBILITY) Slog.i(TAG, "Relayout invis " + win
+                            + ": mExiting=" + win.mExiting);
+                    // If we are not currently running the exit animation, we
+                    // need to see about starting one.
+                    if (!win.mExiting) {
+                        surfaceChanged = true;
+                        // Try starting an animation; if there isn't one, we
+                        // can destroy the surface right away.
+                        int transit = WindowManagerPolicy.TRANSIT_EXIT;
+                        if (win.mAttrs.type == TYPE_APPLICATION_STARTING) {
+                            transit = WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
+                        }
+                        if (win.isWinVisibleLw() &&
+                                winAnimator.applyAnimationLocked(transit, false)) {
+                            focusMayChange = true;
+                            win.mExiting = true;
+                        } else if (win.mWinAnimator.isAnimating()) {
+                            // Currently in a hide animation... turn this into
+                            // an exit.
+                            win.mExiting = true;
+                        } else if (win == mWallpaperTarget) {
+                            // If the wallpaper is currently behind this
+                            // window, we need to change both of them inside
+                            // of a transaction to avoid artifacts.
+                            win.mExiting = true;
+                            win.mWinAnimator.mAnimating = true;
+                        } else {
+                            if (mInputMethodWindow == win) {
+                                mInputMethodWindow = null;
+                            }
+                            winAnimator.destroySurfaceLocked();
+                        }
+                    }
+                }
+
+                outSurface.release();
+                if (DEBUG_VISIBILITY) Slog.i(TAG, "Releasing surface in: " + win);
+            }
+
+            if (focusMayChange) {
+                //System.out.println("Focus may change: " + win.mAttrs.getTitle());
+                if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,
+                        false /*updateInputWindows*/)) {
+                    imMayMove = false;
+                }
+                //System.out.println("Relayout " + win + ": focus=" + mCurrentFocus);
+            }
+
+            // updateFocusedWindowLocked() already assigned layers so we only need to
+            // reassign them at this point if the IM window state gets shuffled
+            boolean assignLayers = false;
+
+            if (imMayMove) {
+                if (moveInputMethodWindowsIfNeededLocked(false) || toBeDisplayed) {
+                    // Little hack here -- we -should- be able to rely on the
+                    // function to return true if the IME has moved and needs
+                    // its layer recomputed.  However, if the IME was hidden
+                    // and isn't actually moved in the list, its layer may be
+                    // out of data so we make sure to recompute it.
+                    assignLayers = true;
+                }
+            }
+            if (wallpaperMayMove) {
+                if ((adjustWallpaperWindowsLocked()&ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
+                    assignLayers = true;
+                }
+            }
+
+            mLayoutNeeded = true;
+            win.mGivenInsetsPending = (flags&WindowManagerImpl.RELAYOUT_INSETS_PENDING) != 0;
+            if (assignLayers) {
+                assignLayersLocked();
+            }
+            configChanged = updateOrientationFromAppTokensLocked(false);
+            performLayoutAndPlaceSurfacesLocked();
+            if (toBeDisplayed && win.mIsWallpaper) {
+                updateWallpaperOffsetLocked(win, mAppDisplayWidth, mAppDisplayHeight, false);
+            }
+            if (win.mAppToken != null) {
+                win.mAppToken.updateReportedVisibilityLocked();
+            }
+            outFrame.set(win.mCompatFrame);
+            outContentInsets.set(win.mContentInsets);
+            outVisibleInsets.set(win.mVisibleInsets);
+            if (localLOGV) Slog.v(
+                TAG, "Relayout given client " + client.asBinder()
+                + ", requestedWidth=" + requestedWidth
+                + ", requestedHeight=" + requestedHeight
+                + ", viewVisibility=" + viewVisibility
+                + "\nRelayout returning frame=" + outFrame
+                + ", surface=" + outSurface);
+
+            if (localLOGV || DEBUG_FOCUS) Slog.v(
+                TAG, "Relayout of " + win + ": focusMayChange=" + focusMayChange);
+
+            inTouchMode = mInTouchMode;
+            animating = mAnimator.mAnimating;
+            if (animating && !mRelayoutWhileAnimating.contains(win)) {
+                mRelayoutWhileAnimating.add(win);
+            }
+
+            mInputMonitor.updateInputWindowsLw(true /*force*/);
+        }
+
+        if (configChanged) {
+            sendNewConfiguration();
+        }
+
+        Binder.restoreCallingIdentity(origId);
+
+        return (inTouchMode ? WindowManagerImpl.RELAYOUT_RES_IN_TOUCH_MODE : 0)
+                | (toBeDisplayed ? WindowManagerImpl.RELAYOUT_RES_FIRST_TIME : 0)
+                | (surfaceChanged ? WindowManagerImpl.RELAYOUT_RES_SURFACE_CHANGED : 0)
+                | (animating ? WindowManagerImpl.RELAYOUT_RES_ANIMATING : 0);
+    }
+
+    public void performDeferredDestroyWindow(Session session, IWindow client) {
+        long origId = Binder.clearCallingIdentity();
+
+        try {
+            synchronized(mWindowMap) {
+                WindowState win = windowForClientLocked(session, client, false);
+                if (win == null) {
+                    return;
+                }
+                win.mWinAnimator.destroyDeferredSurfaceLocked();
+            }
+        } finally {
+            Binder.restoreCallingIdentity(origId);
+        }
+    }
+
+    public boolean outOfMemoryWindow(Session session, IWindow client) {
+        long origId = Binder.clearCallingIdentity();
+
+        try {
+            synchronized(mWindowMap) {
+                WindowState win = windowForClientLocked(session, client, false);
+                if (win == null) {
+                    return false;
+                }
+                return reclaimSomeSurfaceMemoryLocked(win.mWinAnimator, "from-client", false);
+            }
+        } finally {
+            Binder.restoreCallingIdentity(origId);
+        }
+    }
+
+    public void finishDrawingWindow(Session session, IWindow client) {
+        final long origId = Binder.clearCallingIdentity();
+        synchronized(mWindowMap) {
+            WindowState win = windowForClientLocked(session, client, false);
+            if (win != null && win.mWinAnimator.finishDrawingLocked()) {
+                if ((win.mAttrs.flags&FLAG_SHOW_WALLPAPER) != 0) {
+                    adjustWallpaperWindowsLocked();
+                }
+                mLayoutNeeded = true;
+                performLayoutAndPlaceSurfacesLocked();
+            }
+        }
+        Binder.restoreCallingIdentity(origId);
+    }
+
+    public float getWindowCompatibilityScale(IBinder windowToken) {
+        synchronized (mWindowMap) {
+            WindowState windowState = mWindowMap.get(windowToken);
+            return (windowState != null) ? windowState.mGlobalScale : 1.0f;
+        }
+    }
+
+    private AttributeCache.Entry getCachedAnimations(WindowManager.LayoutParams lp) {
+        if (DEBUG_ANIM) Slog.v(TAG, "Loading animations: layout params pkg="
+                + (lp != null ? lp.packageName : null)
+                + " resId=0x" + (lp != null ? Integer.toHexString(lp.windowAnimations) : null));
+        if (lp != null && lp.windowAnimations != 0) {
+            // If this is a system resource, don't try to load it from the
+            // application resources.  It is nice to avoid loading application
+            // resources if we can.
+            String packageName = lp.packageName != null ? lp.packageName : "android";
+            int resId = lp.windowAnimations;
+            if ((resId&0xFF000000) == 0x01000000) {
+                packageName = "android";
+            }
+            if (DEBUG_ANIM) Slog.v(TAG, "Loading animations: picked package="
+                    + packageName);
+            return AttributeCache.instance().get(packageName, resId,
+                    com.android.internal.R.styleable.WindowAnimation);
+        }
+        return null;
+    }
+
+    private AttributeCache.Entry getCachedAnimations(String packageName, int resId) {
+        if (DEBUG_ANIM) Slog.v(TAG, "Loading animations: package="
+                + packageName + " resId=0x" + Integer.toHexString(resId));
+        if (packageName != null) {
+            if ((resId&0xFF000000) == 0x01000000) {
+                packageName = "android";
+            }
+            if (DEBUG_ANIM) Slog.v(TAG, "Loading animations: picked package="
+                    + packageName);
+            return AttributeCache.instance().get(packageName, resId,
+                    com.android.internal.R.styleable.WindowAnimation);
+        }
+        return null;
+    }
+
+    Animation loadAnimation(WindowManager.LayoutParams lp, int animAttr) {
+        int anim = 0;
+        Context context = mContext;
+        if (animAttr >= 0) {
+            AttributeCache.Entry ent = getCachedAnimations(lp);
+            if (ent != null) {
+                context = ent.context;
+                anim = ent.array.getResourceId(animAttr, 0);
+            }
+        }
+        if (anim != 0) {
+            return AnimationUtils.loadAnimation(context, anim);
+        }
+        return null;
+    }
+
+    private Animation loadAnimation(String packageName, int resId) {
+        int anim = 0;
+        Context context = mContext;
+        if (resId >= 0) {
+            AttributeCache.Entry ent = getCachedAnimations(packageName, resId);
+            if (ent != null) {
+                context = ent.context;
+                anim = resId;
+            }
+        }
+        if (anim != 0) {
+            return AnimationUtils.loadAnimation(context, anim);
+        }
+        return null;
+    }
+
+    private Animation createExitAnimationLocked(int transit, int duration) {
+        if (transit == WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN ||
+                transit == WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE) {
+            // If we are on top of the wallpaper, we need an animation that
+            // correctly handles the wallpaper staying static behind all of
+            // the animated elements.  To do this, will just have the existing
+            // element fade out.
+            Animation a = new AlphaAnimation(1, 0);
+            a.setDetachWallpaper(true);
+            a.setDuration(duration);
+            return a;
+        } else {
+            // For normal animations, the exiting element just holds in place.
+            Animation a = new AlphaAnimation(1, 1);
+            a.setDuration(duration);
+            return a;
+        }
+    }
+
+    /**
+     * Compute the pivot point for an animation that is scaling from a small
+     * rect on screen to a larger rect.  The pivot point varies depending on
+     * the distance between the inner and outer edges on both sides.  This
+     * function computes the pivot point for one dimension.
+     * @param startPos  Offset from left/top edge of outer rectangle to
+     * left/top edge of inner rectangle.
+     * @param finalScale The scaling factor between the size of the outer
+     * and inner rectangles.
+     */
+    private static float computePivot(int startPos, float finalScale) {
+        final float denom = finalScale-1;
+        if (Math.abs(denom) < .0001f) {
+            return startPos;
+        }
+        return -startPos / denom;
+    }
+
+    private Animation createScaleUpAnimationLocked(int transit, boolean enter) {
+        Animation a;
+        // Pick the desired duration.  If this is an inter-activity transition,
+        // it  is the standard duration for that.  Otherwise we use the longer
+        // task transition duration.
+        int duration;
+        switch (transit) {
+            case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
+            case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
+                duration = mContext.getResources().getInteger(
+                        com.android.internal.R.integer.config_shortAnimTime);
+                break;
+            default:
+                duration = 300;
+                break;
+        }
+        if (enter) {
+            // Entering app zooms out from the center of the initial rect.
+            float scaleW = mNextAppTransitionStartWidth / (float) mAppDisplayWidth;
+            float scaleH = mNextAppTransitionStartHeight / (float) mAppDisplayHeight;
+            Animation scale = new ScaleAnimation(scaleW, 1, scaleH, 1,
+                    computePivot(mNextAppTransitionStartX, scaleW),
+                    computePivot(mNextAppTransitionStartY, scaleH));
+            scale.setDuration(duration);
+            AnimationSet set = new AnimationSet(true);
+            Animation alpha = new AlphaAnimation(0, 1);
+            scale.setDuration(duration);
+            set.addAnimation(scale);
+            alpha.setDuration(duration);
+            set.addAnimation(alpha);
+            set.setDetachWallpaper(true);
+            a = set;
+        } else {
+            a = createExitAnimationLocked(transit, duration);
+        }
+        a.setFillAfter(true);
+        final Interpolator interpolator = AnimationUtils.loadInterpolator(mContext,
+                com.android.internal.R.interpolator.decelerate_cubic);
+        a.setInterpolator(interpolator);
+        a.initialize(mAppDisplayWidth, mAppDisplayHeight,
+                mAppDisplayWidth, mAppDisplayHeight);
+        return a;
+    }
+
+    private Animation createThumbnailAnimationLocked(int transit,
+            boolean enter, boolean thumb, boolean delayed) {
+        Animation a;
+        final int thumbWidthI = mNextAppTransitionThumbnail.getWidth();
+        final float thumbWidth = thumbWidthI > 0 ? thumbWidthI : 1;
+        final int thumbHeightI = mNextAppTransitionThumbnail.getHeight();
+        final float thumbHeight = thumbHeightI > 0 ? thumbHeightI : 1;
+        // Pick the desired duration.  If this is an inter-activity transition,
+        // it  is the standard duration for that.  Otherwise we use the longer
+        // task transition duration.
+        int duration;
+        int delayDuration = delayed ? 270 : 0;
+        switch (transit) {
+            case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
+            case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
+                duration = mContext.getResources().getInteger(
+                        com.android.internal.R.integer.config_shortAnimTime);
+                break;
+            default:
+                duration = delayed ? 250 : 300;
+                break;
+        }
+        if (thumb) {
+            // Animation for zooming thumbnail from its initial size to
+            // filling the screen.
+            float scaleW = mAppDisplayWidth/thumbWidth;
+            float scaleH = mAppDisplayHeight/thumbHeight;
+
+            Animation scale = new ScaleAnimation(1, scaleW, 1, scaleH,
+                    computePivot(mNextAppTransitionStartX, 1/scaleW),
+                    computePivot(mNextAppTransitionStartY, 1/scaleH));
+            AnimationSet set = new AnimationSet(true);
+            Animation alpha = new AlphaAnimation(1, 0);
+            scale.setDuration(duration);
+            scale.setInterpolator(
+                    new DecelerateInterpolator(THUMBNAIL_ANIMATION_DECELERATE_FACTOR));
+            set.addAnimation(scale);
+            alpha.setDuration(duration);
+            set.addAnimation(alpha);
+            set.setFillBefore(true);
+            if (delayDuration > 0) {
+                set.setStartOffset(delayDuration);
+            }
+            a = set;
+        } else if (enter) {
+            // Entering app zooms out from the center of the thumbnail.
+            float scaleW = thumbWidth / mAppDisplayWidth;
+            float scaleH = thumbHeight / mAppDisplayHeight;
+            Animation scale = new ScaleAnimation(scaleW, 1, scaleH, 1,
+                    computePivot(mNextAppTransitionStartX, scaleW),
+                    computePivot(mNextAppTransitionStartY, scaleH));
+            scale.setDuration(duration);
+            scale.setInterpolator(
+                    new DecelerateInterpolator(THUMBNAIL_ANIMATION_DECELERATE_FACTOR));
+            scale.setFillBefore(true);
+            if (delayDuration > 0) {
+                scale.setStartOffset(delayDuration);
+            }
+            a = scale;
+        } else {
+            if (delayed) {
+                a = new AlphaAnimation(1, 0);
+                a.setStartOffset(0);
+                a.setDuration(delayDuration - 120);
+                a.setBackgroundColor(0xFF000000);
+            } else {
+                a = createExitAnimationLocked(transit, duration);
+            }
+        }
+        a.setFillAfter(true);
+        final Interpolator interpolator = AnimationUtils.loadInterpolator(mContext,
+                com.android.internal.R.interpolator.decelerate_quad);
+        a.setInterpolator(interpolator);
+        a.initialize(mAppDisplayWidth, mAppDisplayHeight,
+                mAppDisplayWidth, mAppDisplayHeight);
+        return a;
+    }
+
+    private boolean applyAnimationLocked(AppWindowToken wtoken,
+            WindowManager.LayoutParams lp, int transit, boolean enter) {
+        // Only apply an animation if the display isn't frozen.  If it is
+        // frozen, there is no reason to animate and it can cause strange
+        // artifacts when we unfreeze the display if some different animation
+        // is running.
+        if (okToDisplay()) {
+            Animation a;
+            boolean initialized = false;
+            if (mNextAppTransitionType == ActivityOptions.ANIM_CUSTOM) {
+                a = loadAnimation(mNextAppTransitionPackage, enter ?
+                        mNextAppTransitionEnter : mNextAppTransitionExit);
+                if (DEBUG_APP_TRANSITIONS || DEBUG_ANIM) Slog.v(TAG,
+                        "applyAnimation: wtoken=" + wtoken
+                        + " anim=" + a + " nextAppTransition=ANIM_CUSTOM"
+                        + " transit=" + transit + " Callers " + Debug.getCallers(3));
+            } else if (mNextAppTransitionType == ActivityOptions.ANIM_SCALE_UP) {
+                a = createScaleUpAnimationLocked(transit, enter);
+                initialized = true;
+                if (DEBUG_APP_TRANSITIONS || DEBUG_ANIM) Slog.v(TAG,
+                        "applyAnimation: wtoken=" + wtoken
+                        + " anim=" + a + " nextAppTransition=ANIM_SCALE_UP"
+                        + " transit=" + transit + " Callers " + Debug.getCallers(3));
+            } else if (mNextAppTransitionType == ActivityOptions.ANIM_THUMBNAIL ||
+                    mNextAppTransitionType == ActivityOptions.ANIM_THUMBNAIL_DELAYED) {
+                boolean delayed = (mNextAppTransitionType == ActivityOptions.ANIM_THUMBNAIL_DELAYED);
+                a = createThumbnailAnimationLocked(transit, enter, false, delayed);
+                initialized = true;
+
+                if (DEBUG_APP_TRANSITIONS || DEBUG_ANIM) {
+                    String animName = delayed ? "ANIM_THUMBNAIL_DELAYED" : "ANIM_THUMBNAIL";
+                    Slog.v(TAG, "applyAnimation: wtoken=" + wtoken
+                            + " anim=" + a + " nextAppTransition=" + animName
+                            + " transit=" + transit + " Callers " + Debug.getCallers(3));
+                }
+            } else {
+                int animAttr = 0;
+                switch (transit) {
+                    case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
+                        animAttr = enter
+                                ? com.android.internal.R.styleable.WindowAnimation_activityOpenEnterAnimation
+                                : com.android.internal.R.styleable.WindowAnimation_activityOpenExitAnimation;
+                        break;
+                    case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
+                        animAttr = enter
+                                ? com.android.internal.R.styleable.WindowAnimation_activityCloseEnterAnimation
+                                : com.android.internal.R.styleable.WindowAnimation_activityCloseExitAnimation;
+                        break;
+                    case WindowManagerPolicy.TRANSIT_TASK_OPEN:
+                        animAttr = enter
+                                ? com.android.internal.R.styleable.WindowAnimation_taskOpenEnterAnimation
+                                : com.android.internal.R.styleable.WindowAnimation_taskOpenExitAnimation;
+                        break;
+                    case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
+                        animAttr = enter
+                                ? com.android.internal.R.styleable.WindowAnimation_taskCloseEnterAnimation
+                                : com.android.internal.R.styleable.WindowAnimation_taskCloseExitAnimation;
+                        break;
+                    case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
+                        animAttr = enter
+                                ? com.android.internal.R.styleable.WindowAnimation_taskToFrontEnterAnimation
+                                : com.android.internal.R.styleable.WindowAnimation_taskToFrontExitAnimation;
+                        break;
+                    case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
+                        animAttr = enter
+                                ? com.android.internal.R.styleable.WindowAnimation_taskToBackEnterAnimation
+                                : com.android.internal.R.styleable.WindowAnimation_taskToBackExitAnimation;
+                        break;
+                    case WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN:
+                        animAttr = enter
+                                ? com.android.internal.R.styleable.WindowAnimation_wallpaperOpenEnterAnimation
+                                : com.android.internal.R.styleable.WindowAnimation_wallpaperOpenExitAnimation;
+                        break;
+                    case WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE:
+                        animAttr = enter
+                                ? com.android.internal.R.styleable.WindowAnimation_wallpaperCloseEnterAnimation
+                                : com.android.internal.R.styleable.WindowAnimation_wallpaperCloseExitAnimation;
+                        break;
+                    case WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN:
+                        animAttr = enter
+                                ? com.android.internal.R.styleable.WindowAnimation_wallpaperIntraOpenEnterAnimation
+                                : com.android.internal.R.styleable.WindowAnimation_wallpaperIntraOpenExitAnimation;
+                        break;
+                    case WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE:
+                        animAttr = enter
+                                ? com.android.internal.R.styleable.WindowAnimation_wallpaperIntraCloseEnterAnimation
+                                : com.android.internal.R.styleable.WindowAnimation_wallpaperIntraCloseExitAnimation;
+                        break;
+                }
+                a = animAttr != 0 ? loadAnimation(lp, animAttr) : null;
+                if (DEBUG_APP_TRANSITIONS || DEBUG_ANIM) Slog.v(TAG,
+                        "applyAnimation: wtoken=" + wtoken
+                        + " anim=" + a
+                        + " animAttr=0x" + Integer.toHexString(animAttr)
+                        + " transit=" + transit + " Callers " + Debug.getCallers(3));
+            }
+            if (a != null) {
+                if (DEBUG_ANIM) {
+                    RuntimeException e = null;
+                    if (!HIDE_STACK_CRAWLS) {
+                        e = new RuntimeException();
+                        e.fillInStackTrace();
+                    }
+                    Slog.v(TAG, "Loaded animation " + a + " for " + wtoken, e);
+                }
+                wtoken.mAppAnimator.setAnimation(a, initialized);
+            }
+        } else {
+            wtoken.mAppAnimator.clearAnimation();
+        }
+
+        return wtoken.mAppAnimator.animation != null;
+    }
+
+    // -------------------------------------------------------------
+    // Application Window Tokens
+    // -------------------------------------------------------------
+
+    public void validateAppTokens(List<IBinder> tokens) {
+        int v = tokens.size()-1;
+        int m = mAppTokens.size()-1;
+        while (v >= 0 && m >= 0) {
+            AppWindowToken wtoken = mAppTokens.get(m);
+            if (wtoken.removed) {
+                m--;
+                continue;
+            }
+            if (tokens.get(v) != wtoken.token) {
+                Slog.w(TAG, "Tokens out of sync: external is " + tokens.get(v)
+                      + " @ " + v + ", internal is " + wtoken.token + " @ " + m);
+            }
+            v--;
+            m--;
+        }
+        while (v >= 0) {
+            Slog.w(TAG, "External token not found: " + tokens.get(v) + " @ " + v);
+            v--;
+        }
+        while (m >= 0) {
+            AppWindowToken wtoken = mAppTokens.get(m);
+            if (!wtoken.removed) {
+                Slog.w(TAG, "Invalid internal token: " + wtoken.token + " @ " + m);
+            }
+            m--;
+        }
+    }
+
+    boolean checkCallingPermission(String permission, String func) {
+        // Quick check: if the calling permission is me, it's all okay.
+        if (Binder.getCallingPid() == Process.myPid()) {
+            return true;
+        }
+
+        if (mContext.checkCallingPermission(permission)
+                == PackageManager.PERMISSION_GRANTED) {
+            return true;
+        }
+        String msg = "Permission Denial: " + func + " from pid="
+                + Binder.getCallingPid()
+                + ", uid=" + Binder.getCallingUid()
+                + " requires " + permission;
+        Slog.w(TAG, msg);
+        return false;
+    }
+    
+    boolean okToDisplay() {
+        return !mDisplayFrozen && mDisplayEnabled && mPolicy.isScreenOnFully();
+    }
+
+    AppWindowToken findAppWindowToken(IBinder token) {
+        WindowToken wtoken = mTokenMap.get(token);
+        if (wtoken == null) {
+            return null;
+        }
+        return wtoken.appWindowToken;
+    }
+
+    @Override
+    public void addWindowToken(IBinder token, int type) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "addWindowToken()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        synchronized(mWindowMap) {
+            WindowToken wtoken = mTokenMap.get(token);
+            if (wtoken != null) {
+                Slog.w(TAG, "Attempted to add existing input method token: " + token);
+                return;
+            }
+            wtoken = new WindowToken(this, token, type, true);
+            mTokenMap.put(token, wtoken);
+            if (type == TYPE_WALLPAPER) {
+                mWallpaperTokens.add(wtoken);
+            }
+        }
+    }
+
+    public void removeWindowToken(IBinder token) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "removeWindowToken()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        final long origId = Binder.clearCallingIdentity();
+        synchronized(mWindowMap) {
+            WindowToken wtoken = mTokenMap.remove(token);
+            if (wtoken != null) {
+                boolean delayed = false;
+                if (!wtoken.hidden) {
+                    wtoken.hidden = true;
+
+                    final int N = wtoken.windows.size();
+                    boolean changed = false;
+
+                    for (int i=0; i<N; i++) {
+                        WindowState win = wtoken.windows.get(i);
+
+                        if (win.mWinAnimator.isAnimating()) {
+                            delayed = true;
+                        }
+
+                        if (win.isVisibleNow()) {
+                            win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_EXIT, false);
+                            changed = true;
+                        }
+                    }
+
+                    if (changed) {
+                        mLayoutNeeded = true;
+                        performLayoutAndPlaceSurfacesLocked();
+                        updateFocusedWindowLocked(UPDATE_FOCUS_NORMAL,
+                                false /*updateInputWindows*/);
+                    }
+
+                    if (delayed) {
+                        mExitingTokens.add(wtoken);
+                    } else if (wtoken.windowType == TYPE_WALLPAPER) {
+                        mWallpaperTokens.remove(wtoken);
+                    }
+                }
+
+                mInputMonitor.updateInputWindowsLw(true /*force*/);
+            } else {
+                Slog.w(TAG, "Attempted to remove non-existing token: " + token);
+            }
+        }
+        Binder.restoreCallingIdentity(origId);
+    }
+
+    /**
+     *  Find the location to insert a new AppWindowToken into the window-ordered app token list.
+     *  Note that mAppTokens.size() == mAnimatingAppTokens.size() + 1.
+     * @param addPos The location the token was inserted into in mAppTokens.
+     * @param wtoken The token to insert.
+     */
+    private void addAppTokenToAnimating(final int addPos, final AppWindowToken wtoken) {
+        if (addPos == 0 || addPos == mAnimatingAppTokens.size()) {
+            // It was inserted into the beginning or end of mAppTokens. Honor that.
+            mAnimatingAppTokens.add(addPos, wtoken);
+            return;
+        }
+        // Find the item immediately above the mAppTokens insertion point and put the token
+        // immediately below that one in mAnimatingAppTokens.
+        final AppWindowToken aboveAnchor = mAppTokens.get(addPos + 1);
+        mAnimatingAppTokens.add(mAnimatingAppTokens.indexOf(aboveAnchor), wtoken);
+    }
+
+    @Override
+    public void addAppToken(int addPos, IApplicationToken token,
+            int groupId, int requestedOrientation, boolean fullscreen) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "addAppToken()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        // Get the dispatching timeout here while we are not holding any locks so that it
+        // can be cached by the AppWindowToken.  The timeout value is used later by the
+        // input dispatcher in code that does hold locks.  If we did not cache the value
+        // here we would run the chance of introducing a deadlock between the window manager
+        // (which holds locks while updating the input dispatcher state) and the activity manager
+        // (which holds locks while querying the application token).
+        long inputDispatchingTimeoutNanos;
+        try {
+            inputDispatchingTimeoutNanos = token.getKeyDispatchingTimeout() * 1000000L;
+        } catch (RemoteException ex) {
+            Slog.w(TAG, "Could not get dispatching timeout.", ex);
+            inputDispatchingTimeoutNanos = DEFAULT_INPUT_DISPATCHING_TIMEOUT_NANOS;
+        }
+
+        synchronized(mWindowMap) {
+            AppWindowToken wtoken = findAppWindowToken(token.asBinder());
+            if (wtoken != null) {
+                Slog.w(TAG, "Attempted to add existing app token: " + token);
+                return;
+            }
+            wtoken = new AppWindowToken(this, token);
+            wtoken.inputDispatchingTimeoutNanos = inputDispatchingTimeoutNanos;
+            wtoken.groupId = groupId;
+            wtoken.appFullscreen = fullscreen;
+            wtoken.requestedOrientation = requestedOrientation;
+            if (DEBUG_TOKEN_MOVEMENT || DEBUG_ADD_REMOVE) Slog.v(TAG, "addAppToken: " + wtoken
+                    + " at " + addPos);
+            mAppTokens.add(addPos, wtoken);
+            addAppTokenToAnimating(addPos, wtoken);
+            mTokenMap.put(token.asBinder(), wtoken);
+
+            // Application tokens start out hidden.
+            wtoken.hidden = true;
+            wtoken.hiddenRequested = true;
+
+            //dump();
+        }
+    }
+
+    public void setAppGroupId(IBinder token, int groupId) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "setAppGroupId()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        synchronized(mWindowMap) {
+            AppWindowToken wtoken = findAppWindowToken(token);
+            if (wtoken == null) {
+                Slog.w(TAG, "Attempted to set group id of non-existing app token: " + token);
+                return;
+            }
+            wtoken.groupId = groupId;
+        }
+    }
+
+    public int getOrientationFromWindowsLocked() {
+        if (mDisplayFrozen || mOpeningApps.size() > 0 || mClosingApps.size() > 0) {
+            // If the display is frozen, some activities may be in the middle
+            // of restarting, and thus have removed their old window.  If the
+            // window has the flag to hide the lock screen, then the lock screen
+            // can re-appear and inflict its own orientation on us.  Keep the
+            // orientation stable until this all settles down.
+            return mLastWindowForcedOrientation;
+        }
+
+        int pos = mWindows.size() - 1;
+        while (pos >= 0) {
+            WindowState wtoken = mWindows.get(pos);
+            pos--;
+            if (wtoken.mAppToken != null) {
+                // We hit an application window. so the orientation will be determined by the
+                // app window. No point in continuing further.
+                return (mLastWindowForcedOrientation=ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
+            }
+            if (!wtoken.isVisibleLw() || !wtoken.mPolicyVisibilityAfterAnim) {
+                continue;
+            }
+            int req = wtoken.mAttrs.screenOrientation;
+            if((req == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) ||
+                    (req == ActivityInfo.SCREEN_ORIENTATION_BEHIND)){
+                continue;
+            } else {
+                return (mLastWindowForcedOrientation=req);
+            }
+        }
+        return (mLastWindowForcedOrientation=ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
+    }
+
+    public int getOrientationFromAppTokensLocked() {
+        int curGroup = 0;
+        int lastOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
+        boolean findingBehind = false;
+        boolean haveGroup = false;
+        boolean lastFullscreen = false;
+        for (int pos = mAppTokens.size() - 1; pos >= 0; pos--) {
+            AppWindowToken wtoken = mAppTokens.get(pos);
+
+            if (DEBUG_APP_ORIENTATION) Slog.v(TAG, "Checking app orientation: " + wtoken);
+
+            // if we're about to tear down this window and not seek for
+            // the behind activity, don't use it for orientation
+            if (!findingBehind
+                    && (!wtoken.hidden && wtoken.hiddenRequested)) {
+                if (DEBUG_ORIENTATION) Slog.v(TAG, "Skipping " + wtoken
+                        + " -- going to hide");
+                continue;
+            }
+
+            if (haveGroup == true && curGroup != wtoken.groupId) {
+                // If we have hit a new application group, and the bottom
+                // of the previous group didn't explicitly say to use
+                // the orientation behind it, and the last app was
+                // full screen, then we'll stick with the
+                // user's orientation.
+                if (lastOrientation != ActivityInfo.SCREEN_ORIENTATION_BEHIND
+                        && lastFullscreen) {
+                    if (DEBUG_ORIENTATION) Slog.v(TAG, "Done at " + wtoken
+                            + " -- end of group, return " + lastOrientation);
+                    return lastOrientation;
+                }
+            }
+
+            // We ignore any hidden applications on the top.
+            if (wtoken.hiddenRequested || wtoken.willBeHidden) {
+                if (DEBUG_ORIENTATION) Slog.v(TAG, "Skipping " + wtoken
+                        + " -- hidden on top");
+                continue;
+            }
+
+            if (!haveGroup) {
+                haveGroup = true;
+                curGroup = wtoken.groupId;
+                lastOrientation = wtoken.requestedOrientation;
+            } 
+
+            int or = wtoken.requestedOrientation;
+            // If this application is fullscreen, and didn't explicitly say
+            // to use the orientation behind it, then just take whatever
+            // orientation it has and ignores whatever is under it.
+            lastFullscreen = wtoken.appFullscreen;
+            if (lastFullscreen
+                    && or != ActivityInfo.SCREEN_ORIENTATION_BEHIND) {
+                if (DEBUG_ORIENTATION) Slog.v(TAG, "Done at " + wtoken
+                        + " -- full screen, return " + or);
+                return or;
+            }
+            // If this application has requested an explicit orientation,
+            // then use it.
+            if (or != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED
+                    && or != ActivityInfo.SCREEN_ORIENTATION_BEHIND) {
+                if (DEBUG_ORIENTATION) Slog.v(TAG, "Done at " + wtoken
+                        + " -- explicitly set, return " + or);
+                return or;
+            }
+            findingBehind |= (or == ActivityInfo.SCREEN_ORIENTATION_BEHIND);
+        }
+        if (DEBUG_ORIENTATION) Slog.v(TAG, "No app is requesting an orientation");
+        return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
+    }
+
+    public Configuration updateOrientationFromAppTokens(
+            Configuration currentConfig, IBinder freezeThisOneIfNeeded) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "updateOrientationFromAppTokens()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        Configuration config = null;
+        long ident = Binder.clearCallingIdentity();
+        
+        synchronized(mWindowMap) {
+            config = updateOrientationFromAppTokensLocked(currentConfig,
+                    freezeThisOneIfNeeded);
+        }
+
+        Binder.restoreCallingIdentity(ident);
+        return config;
+    }
+
+    private Configuration updateOrientationFromAppTokensLocked(
+            Configuration currentConfig, IBinder freezeThisOneIfNeeded) {
+        Configuration config = null;
+
+        if (updateOrientationFromAppTokensLocked(false)) {
+            if (freezeThisOneIfNeeded != null) {
+                AppWindowToken wtoken = findAppWindowToken(
+                        freezeThisOneIfNeeded);
+                if (wtoken != null) {
+                    startAppFreezingScreenLocked(wtoken,
+                            ActivityInfo.CONFIG_ORIENTATION);
+                }
+            }
+            config = computeNewConfigurationLocked();
+
+        } else if (currentConfig != null) {
+            // No obvious action we need to take, but if our current
+            // state mismatches the activity manager's, update it,
+            // disregarding font scale, which should remain set to
+            // the value of the previous configuration.
+            mTempConfiguration.setToDefaults();
+            mTempConfiguration.fontScale = currentConfig.fontScale;
+            if (computeScreenConfigurationLocked(mTempConfiguration)) {
+                if (currentConfig.diff(mTempConfiguration) != 0) {
+                    mWaitingForConfig = true;
+                    mLayoutNeeded = true;
+                    startFreezingDisplayLocked(false);
+                    config = new Configuration(mTempConfiguration);
+                }
+            }
+        }
+        
+        return config;
+    }
+
+    /*
+     * Determine the new desired orientation of the display, returning
+     * a non-null new Configuration if it has changed from the current
+     * orientation.  IF TRUE IS RETURNED SOMEONE MUST CALL
+     * setNewConfiguration() TO TELL THE WINDOW MANAGER IT CAN UNFREEZE THE
+     * SCREEN.  This will typically be done for you if you call
+     * sendNewConfiguration().
+     * 
+     * The orientation is computed from non-application windows first. If none of
+     * the non-application windows specify orientation, the orientation is computed from
+     * application tokens.
+     * @see android.view.IWindowManager#updateOrientationFromAppTokens(
+     * android.os.IBinder)
+     */
+    boolean updateOrientationFromAppTokensLocked(boolean inTransaction) {
+        long ident = Binder.clearCallingIdentity();
+        try {
+            int req = computeForcedAppOrientationLocked();
+
+            if (req != mForcedAppOrientation) {
+                mForcedAppOrientation = req;
+                //send a message to Policy indicating orientation change to take
+                //action like disabling/enabling sensors etc.,
+                mPolicy.setCurrentOrientationLw(req);
+                if (updateRotationUncheckedLocked(inTransaction)) {
+                    // changed
+                    return true;
+                }
+            }
+
+            return false;
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    int computeForcedAppOrientationLocked() {
+        int req = getOrientationFromWindowsLocked();
+        if (req == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
+            req = getOrientationFromAppTokensLocked();
+        }
+        return req;
+    }
+
+    public void setNewConfiguration(Configuration config) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "setNewConfiguration()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        synchronized(mWindowMap) {
+            mCurConfiguration = new Configuration(config);
+            mWaitingForConfig = false;
+            performLayoutAndPlaceSurfacesLocked();
+        }
+    }
+    
+    public void setAppOrientation(IApplicationToken token, int requestedOrientation) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "setAppOrientation()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        synchronized(mWindowMap) {
+            AppWindowToken wtoken = findAppWindowToken(token.asBinder());
+            if (wtoken == null) {
+                Slog.w(TAG, "Attempted to set orientation of non-existing app token: " + token);
+                return;
+            }
+
+            wtoken.requestedOrientation = requestedOrientation;
+        }
+    }
+
+    public int getAppOrientation(IApplicationToken token) {
+        synchronized(mWindowMap) {
+            AppWindowToken wtoken = findAppWindowToken(token.asBinder());
+            if (wtoken == null) {
+                return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
+            }
+
+            return wtoken.requestedOrientation;
+        }
+    }
+
+    public void setFocusedApp(IBinder token, boolean moveFocusNow) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "setFocusedApp()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        synchronized(mWindowMap) {
+            boolean changed = false;
+            if (token == null) {
+                if (DEBUG_FOCUS) Slog.v(TAG, "Clearing focused app, was " + mFocusedApp);
+                changed = mFocusedApp != null;
+                mFocusedApp = null;
+                if (changed) {
+                    mInputMonitor.setFocusedAppLw(null);
+                }
+            } else {
+                AppWindowToken newFocus = findAppWindowToken(token);
+                if (newFocus == null) {
+                    Slog.w(TAG, "Attempted to set focus to non-existing app token: " + token);
+                    return;
+                }
+                changed = mFocusedApp != newFocus;
+                mFocusedApp = newFocus;
+                if (DEBUG_FOCUS) Slog.v(TAG, "Set focused app to: " + mFocusedApp);
+                if (changed) {
+                    mInputMonitor.setFocusedAppLw(newFocus);
+                }
+            }
+
+            if (moveFocusNow && changed) {
+                final long origId = Binder.clearCallingIdentity();
+                updateFocusedWindowLocked(UPDATE_FOCUS_NORMAL, true /*updateInputWindows*/);
+                Binder.restoreCallingIdentity(origId);
+            }
+        }
+    }
+
+    public void prepareAppTransition(int transit, boolean alwaysKeepCurrent) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "prepareAppTransition()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        synchronized(mWindowMap) {
+            if (DEBUG_APP_TRANSITIONS) Slog.v(
+                    TAG, "Prepare app transition: transit=" + transit
+                    + " mNextAppTransition=" + mNextAppTransition
+                    + " alwaysKeepCurrent=" + alwaysKeepCurrent
+                    + " Callers=" + Debug.getCallers(3));
+            if (okToDisplay()) {
+                if (mNextAppTransition == WindowManagerPolicy.TRANSIT_UNSET
+                        || mNextAppTransition == WindowManagerPolicy.TRANSIT_NONE) {
+                    mNextAppTransition = transit;
+                } else if (!alwaysKeepCurrent) {
+                    if (transit == WindowManagerPolicy.TRANSIT_TASK_OPEN
+                            && mNextAppTransition == WindowManagerPolicy.TRANSIT_TASK_CLOSE) {
+                        // Opening a new task always supersedes a close for the anim.
+                        mNextAppTransition = transit;
+                    } else if (transit == WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN
+                            && mNextAppTransition == WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE) {
+                        // Opening a new activity always supersedes a close for the anim.
+                        mNextAppTransition = transit;
+                    }
+                }
+                mAppTransitionReady = false;
+                mAppTransitionTimeout = false;
+                mStartingIconInTransition = false;
+                mSkipAppTransitionAnimation = false;
+                mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
+                mH.sendMessageDelayed(mH.obtainMessage(H.APP_TRANSITION_TIMEOUT),
+                        5000);
+            }
+        }
+    }
+
+    public int getPendingAppTransition() {
+        return mNextAppTransition;
+    }
+
+    private void scheduleAnimationCallback(IRemoteCallback cb) {
+        if (cb != null) {
+            mH.sendMessage(mH.obtainMessage(H.DO_ANIMATION_CALLBACK, cb));
+        }
+    }
+
+    public void overridePendingAppTransition(String packageName,
+            int enterAnim, int exitAnim, IRemoteCallback startedCallback) {
+        synchronized(mWindowMap) {
+            if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
+                mNextAppTransitionType = ActivityOptions.ANIM_CUSTOM;
+                mNextAppTransitionPackage = packageName;
+                mNextAppTransitionThumbnail = null;
+                mNextAppTransitionEnter = enterAnim;
+                mNextAppTransitionExit = exitAnim;
+                scheduleAnimationCallback(mNextAppTransitionCallback);
+                mNextAppTransitionCallback = startedCallback;
+            } else {
+                scheduleAnimationCallback(startedCallback);
+            }
+        }
+    }
+
+    public void overridePendingAppTransitionScaleUp(int startX, int startY, int startWidth,
+            int startHeight) {
+        synchronized(mWindowMap) {
+            if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
+                mNextAppTransitionType = ActivityOptions.ANIM_SCALE_UP;
+                mNextAppTransitionPackage = null;
+                mNextAppTransitionThumbnail = null;
+                mNextAppTransitionStartX = startX;
+                mNextAppTransitionStartY = startY;
+                mNextAppTransitionStartWidth = startWidth;
+                mNextAppTransitionStartHeight = startHeight;
+                scheduleAnimationCallback(mNextAppTransitionCallback);
+                mNextAppTransitionCallback = null;
+            }
+        }
+    }
+
+    public void overridePendingAppTransitionThumb(Bitmap srcThumb, int startX,
+            int startY, IRemoteCallback startedCallback, boolean delayed) {
+        synchronized(mWindowMap) {
+            if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
+                mNextAppTransitionType = delayed
+                        ? ActivityOptions.ANIM_THUMBNAIL_DELAYED : ActivityOptions.ANIM_THUMBNAIL;
+                mNextAppTransitionPackage = null;
+                mNextAppTransitionThumbnail = srcThumb;
+                mNextAppTransitionDelayed = delayed;
+                mNextAppTransitionStartX = startX;
+                mNextAppTransitionStartY = startY;
+                scheduleAnimationCallback(mNextAppTransitionCallback);
+                mNextAppTransitionCallback = startedCallback;
+            } else {
+                scheduleAnimationCallback(startedCallback);
+            }
+        }
+    }
+
+    public void executeAppTransition() {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "executeAppTransition()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        synchronized(mWindowMap) {
+            if (DEBUG_APP_TRANSITIONS) {
+                RuntimeException e = new RuntimeException("here");
+                e.fillInStackTrace();
+                Slog.w(TAG, "Execute app transition: mNextAppTransition="
+                        + mNextAppTransition, e);
+            }
+            if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
+                mAppTransitionReady = true;
+                final long origId = Binder.clearCallingIdentity();
+                performLayoutAndPlaceSurfacesLocked();
+                Binder.restoreCallingIdentity(origId);
+            }
+        }
+    }
+
+    public void setAppStartingWindow(IBinder token, String pkg,
+            int theme, CompatibilityInfo compatInfo,
+            CharSequence nonLocalizedLabel, int labelRes, int icon,
+            int windowFlags, IBinder transferFrom, boolean createIfNeeded) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "setAppStartingWindow()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        synchronized(mWindowMap) {
+            if (DEBUG_STARTING_WINDOW) Slog.v(
+                    TAG, "setAppStartingIcon: token=" + token + " pkg=" + pkg
+                    + " transferFrom=" + transferFrom);
+
+            AppWindowToken wtoken = findAppWindowToken(token);
+            if (wtoken == null) {
+                Slog.w(TAG, "Attempted to set icon of non-existing app token: " + token);
+                return;
+            }
+
+            // If the display is frozen, we won't do anything until the
+            // actual window is displayed so there is no reason to put in
+            // the starting window.
+            if (!okToDisplay()) {
+                return;
+            }
+
+            if (wtoken.startingData != null) {
+                return;
+            }
+
+            if (transferFrom != null) {
+                AppWindowToken ttoken = findAppWindowToken(transferFrom);
+                if (ttoken != null) {
+                    WindowState startingWindow = ttoken.startingWindow;
+                    if (startingWindow != null) {
+                        if (mStartingIconInTransition) {
+                            // In this case, the starting icon has already
+                            // been displayed, so start letting windows get
+                            // shown immediately without any more transitions.
+                            mSkipAppTransitionAnimation = true;
+                        }
+                        if (DEBUG_STARTING_WINDOW) Slog.v(TAG,
+                                "Moving existing starting from " + ttoken
+                                + " to " + wtoken);
+                        final long origId = Binder.clearCallingIdentity();
+
+                        // Transfer the starting window over to the new
+                        // token.
+                        wtoken.startingData = ttoken.startingData;
+                        wtoken.startingView = ttoken.startingView;
+                        wtoken.startingDisplayed = ttoken.startingDisplayed;
+                        wtoken.startingWindow = startingWindow;
+                        wtoken.reportedVisible = ttoken.reportedVisible;
+                        ttoken.startingData = null;
+                        ttoken.startingView = null;
+                        ttoken.startingWindow = null;
+                        ttoken.startingMoved = true;
+                        startingWindow.mToken = wtoken;
+                        startingWindow.mRootToken = wtoken;
+                        startingWindow.mAppToken = wtoken;
+                        if (DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE || DEBUG_STARTING_WINDOW) {
+                            Slog.v(TAG, "Removing starting window: " + startingWindow);
+                        }
+                        mWindows.remove(startingWindow);
+                        mWindowsChanged = true;
+                        if (DEBUG_ADD_REMOVE) Slog.v(TAG,
+                                "Removing starting " + startingWindow + " from " + ttoken);
+                        ttoken.windows.remove(startingWindow);
+                        ttoken.allAppWindows.remove(startingWindow);
+                        addWindowToListInOrderLocked(startingWindow, true);
+
+                        // Propagate other interesting state between the
+                        // tokens.  If the old token is displayed, we should
+                        // immediately force the new one to be displayed.  If
+                        // it is animating, we need to move that animation to
+                        // the new one.
+                        if (ttoken.allDrawn) {
+                            wtoken.allDrawn = true;
+                        }
+                        if (ttoken.firstWindowDrawn) {
+                            wtoken.firstWindowDrawn = true;
+                        }
+                        if (!ttoken.hidden) {
+                            wtoken.hidden = false;
+                            wtoken.hiddenRequested = false;
+                            wtoken.willBeHidden = false;
+                        }
+                        if (wtoken.clientHidden != ttoken.clientHidden) {
+                            wtoken.clientHidden = ttoken.clientHidden;
+                            wtoken.sendAppVisibilityToClients();
+                        }
+                        final AppWindowAnimator tAppAnimator = ttoken.mAppAnimator;
+                        final AppWindowAnimator wAppAnimator = wtoken.mAppAnimator;
+                        if (tAppAnimator.animation != null) {
+                            wAppAnimator.animation = tAppAnimator.animation;
+                            wAppAnimator.animating = tAppAnimator.animating;
+                            wAppAnimator.animLayerAdjustment = tAppAnimator.animLayerAdjustment;
+                            tAppAnimator.animation = null;
+                            tAppAnimator.animLayerAdjustment = 0;
+                            wAppAnimator.updateLayers();
+                            tAppAnimator.updateLayers();
+                        }
+
+                        updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,
+                                true /*updateInputWindows*/);
+                        mLayoutNeeded = true;
+                        performLayoutAndPlaceSurfacesLocked();
+                        Binder.restoreCallingIdentity(origId);
+                        return;
+                    } else if (ttoken.startingData != null) {
+                        // The previous app was getting ready to show a
+                        // starting window, but hasn't yet done so.  Steal it!
+                        if (DEBUG_STARTING_WINDOW) Slog.v(TAG,
+                                "Moving pending starting from " + ttoken
+                                + " to " + wtoken);
+                        wtoken.startingData = ttoken.startingData;
+                        ttoken.startingData = null;
+                        ttoken.startingMoved = true;
+                        Message m = mH.obtainMessage(H.ADD_STARTING, wtoken);
+                        // Note: we really want to do sendMessageAtFrontOfQueue() because we
+                        // want to process the message ASAP, before any other queued
+                        // messages.
+                        mH.sendMessageAtFrontOfQueue(m);
+                        return;
+                    }
+                    final AppWindowAnimator tAppAnimator = ttoken.mAppAnimator;
+                    final AppWindowAnimator wAppAnimator = wtoken.mAppAnimator;
+                    if (tAppAnimator.thumbnail != null) {
+                        // The old token is animating with a thumbnail, transfer
+                        // that to the new token.
+                        if (wAppAnimator.thumbnail != null) {
+                            wAppAnimator.thumbnail.destroy();
+                        }
+                        wAppAnimator.thumbnail = tAppAnimator.thumbnail;
+                        wAppAnimator.thumbnailX = tAppAnimator.thumbnailX;
+                        wAppAnimator.thumbnailY = tAppAnimator.thumbnailY;
+                        wAppAnimator.thumbnailLayer = tAppAnimator.thumbnailLayer;
+                        wAppAnimator.thumbnailAnimation = tAppAnimator.thumbnailAnimation;
+                        tAppAnimator.thumbnail = null;
+                    }
+                }
+            }
+
+            // There is no existing starting window, and the caller doesn't
+            // want us to create one, so that's it!
+            if (!createIfNeeded) {
+                return;
+            }
+
+            // If this is a translucent window, then don't
+            // show a starting window -- the current effect (a full-screen
+            // opaque starting window that fades away to the real contents
+            // when it is ready) does not work for this.
+            if (DEBUG_STARTING_WINDOW) Slog.v(TAG, "Checking theme of starting window: 0x"
+                    + Integer.toHexString(theme));
+            if (theme != 0) {
+                AttributeCache.Entry ent = AttributeCache.instance().get(pkg, theme,
+                        com.android.internal.R.styleable.Window);
+                if (ent == null) {
+                    // Whoops!  App doesn't exist.  Um.  Okay.  We'll just
+                    // pretend like we didn't see that.
+                    return;
+                }
+                if (DEBUG_STARTING_WINDOW) Slog.v(TAG, "Translucent="
+                        + ent.array.getBoolean(
+                                com.android.internal.R.styleable.Window_windowIsTranslucent, false)
+                        + " Floating="
+                        + ent.array.getBoolean(
+                                com.android.internal.R.styleable.Window_windowIsFloating, false)
+                        + " ShowWallpaper="
+                        + ent.array.getBoolean(
+                                com.android.internal.R.styleable.Window_windowShowWallpaper, false));
+                if (ent.array.getBoolean(
+                        com.android.internal.R.styleable.Window_windowIsTranslucent, false)) {
+                    return;
+                }
+                if (ent.array.getBoolean(
+                        com.android.internal.R.styleable.Window_windowIsFloating, false)) {
+                    return;
+                }
+                if (ent.array.getBoolean(
+                        com.android.internal.R.styleable.Window_windowShowWallpaper, false)) {
+                    if (mWallpaperTarget == null) {
+                        // If this theme is requesting a wallpaper, and the wallpaper
+                        // is not curently visible, then this effectively serves as
+                        // an opaque window and our starting window transition animation
+                        // can still work.  We just need to make sure the starting window
+                        // is also showing the wallpaper.
+                        windowFlags |= WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
+                    } else {
+                        return;
+                    }
+                }
+            }
+
+            if (DEBUG_STARTING_WINDOW) Slog.v(TAG, "Creating StartingData");
+            mStartingIconInTransition = true;
+            wtoken.startingData = new StartingData(pkg, theme, compatInfo, nonLocalizedLabel,
+                    labelRes, icon, windowFlags);
+            Message m = mH.obtainMessage(H.ADD_STARTING, wtoken);
+            // Note: we really want to do sendMessageAtFrontOfQueue() because we
+            // want to process the message ASAP, before any other queued
+            // messages.
+            if (DEBUG_STARTING_WINDOW) Slog.v(TAG, "Enqueueing ADD_STARTING");
+            mH.sendMessageAtFrontOfQueue(m);
+        }
+    }
+
+    public void setAppWillBeHidden(IBinder token) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "setAppWillBeHidden()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        AppWindowToken wtoken;
+
+        synchronized(mWindowMap) {
+            wtoken = findAppWindowToken(token);
+            if (wtoken == null) {
+                Slog.w(TAG, "Attempted to set will be hidden of non-existing app token: " + token);
+                return;
+            }
+            wtoken.willBeHidden = true;
+        }
+    }
+
+    boolean setTokenVisibilityLocked(AppWindowToken wtoken, WindowManager.LayoutParams lp,
+            boolean visible, int transit, boolean performLayout) {
+        boolean delayed = false;
+
+        if (wtoken.clientHidden == visible) {
+            wtoken.clientHidden = !visible;
+            wtoken.sendAppVisibilityToClients();
+        }
+
+        wtoken.willBeHidden = false;
+        if (wtoken.hidden == visible) {
+            boolean changed = false;
+            if (DEBUG_APP_TRANSITIONS) Slog.v(
+                TAG, "Changing app " + wtoken + " hidden=" + wtoken.hidden
+                + " performLayout=" + performLayout);
+
+            boolean runningAppAnimation = false;
+
+            if (transit != WindowManagerPolicy.TRANSIT_UNSET) {
+                if (wtoken.mAppAnimator.animation == AppWindowAnimator.sDummyAnimation) {
+                    wtoken.mAppAnimator.animation = null;
+                }
+                if (applyAnimationLocked(wtoken, lp, transit, visible)) {
+                    delayed = runningAppAnimation = true;
+                }
+                changed = true;
+            }
+
+            final int N = wtoken.allAppWindows.size();
+            for (int i=0; i<N; i++) {
+                WindowState win = wtoken.allAppWindows.get(i);
+                if (win == wtoken.startingWindow) {
+                    continue;
+                }
+
+                //Slog.i(TAG, "Window " + win + ": vis=" + win.isVisible());
+                //win.dump("  ");
+                if (visible) {
+                    if (!win.isVisibleNow()) {
+                        if (!runningAppAnimation) {
+                            win.mWinAnimator.applyAnimationLocked(
+                                    WindowManagerPolicy.TRANSIT_ENTER, true);
+                        }
+                        changed = true;
+                    }
+                } else if (win.isVisibleNow()) {
+                    if (!runningAppAnimation) {
+                        win.mWinAnimator.applyAnimationLocked(
+                                WindowManagerPolicy.TRANSIT_EXIT, false);
+                    }
+                    changed = true;
+                }
+            }
+
+            wtoken.hidden = wtoken.hiddenRequested = !visible;
+            if (!visible) {
+                unsetAppFreezingScreenLocked(wtoken, true, true);
+            } else {
+                // If we are being set visible, and the starting window is
+                // not yet displayed, then make sure it doesn't get displayed.
+                WindowState swin = wtoken.startingWindow;
+                if (swin != null && !swin.isDrawnLw()) {
+                    swin.mPolicyVisibility = false;
+                    swin.mPolicyVisibilityAfterAnim = false;
+                 }
+            }
+
+            if (DEBUG_APP_TRANSITIONS) Slog.v(TAG, "setTokenVisibilityLocked: " + wtoken
+                      + ": hidden=" + wtoken.hidden + " hiddenRequested="
+                      + wtoken.hiddenRequested);
+
+            if (changed) {
+                mLayoutNeeded = true;
+                mInputMonitor.setUpdateInputWindowsNeededLw();
+                if (performLayout) {
+                    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,
+                            false /*updateInputWindows*/);
+                    performLayoutAndPlaceSurfacesLocked();
+                }
+                mInputMonitor.updateInputWindowsLw(false /*force*/);
+            }
+        }
+
+        if (wtoken.mAppAnimator.animation != null) {
+            delayed = true;
+        }
+
+        for (int i = wtoken.allAppWindows.size() - 1; i >= 0 && !delayed; i--) {
+            if (wtoken.allAppWindows.get(i).mWinAnimator.isWindowAnimating()) {
+                delayed = true;
+            }
+        }
+
+        return delayed;
+    }
+
+    public void setAppVisibility(IBinder token, boolean visible) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "setAppVisibility()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        AppWindowToken wtoken;
+
+        synchronized(mWindowMap) {
+            wtoken = findAppWindowToken(token);
+            if (wtoken == null) {
+                Slog.w(TAG, "Attempted to set visibility of non-existing app token: " + token);
+                return;
+            }
+
+            if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION) {
+                RuntimeException e = null;
+                if (!HIDE_STACK_CRAWLS) {
+                    e = new RuntimeException();
+                    e.fillInStackTrace();
+                }
+                Slog.v(TAG, "setAppVisibility(" + token + ", visible=" + visible
+                        + "): mNextAppTransition=" + mNextAppTransition
+                        + " hidden=" + wtoken.hidden
+                        + " hiddenRequested=" + wtoken.hiddenRequested, e);
+            }
+
+            // If we are preparing an app transition, then delay changing
+            // the visibility of this token until we execute that transition.
+            if (okToDisplay() && mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
+                // Already in requested state, don't do anything more.
+                if (wtoken.hiddenRequested != visible) {
+                    return;
+                }
+                wtoken.hiddenRequested = !visible;
+
+                if (DEBUG_APP_TRANSITIONS) Slog.v(
+                        TAG, "Setting dummy animation on: " + wtoken);
+                if (!wtoken.startingDisplayed) {
+                    wtoken.mAppAnimator.setDummyAnimation();
+                }
+                mOpeningApps.remove(wtoken);
+                mClosingApps.remove(wtoken);
+                wtoken.waitingToShow = wtoken.waitingToHide = false;
+                wtoken.inPendingTransaction = true;
+                if (visible) {
+                    mOpeningApps.add(wtoken);
+                    wtoken.startingMoved = false;
+
+                    // If the token is currently hidden (should be the
+                    // common case), then we need to set up to wait for
+                    // its windows to be ready.
+                    if (wtoken.hidden) {
+                        wtoken.allDrawn = false;
+                        wtoken.waitingToShow = true;
+
+                        if (wtoken.clientHidden) {
+                            // In the case where we are making an app visible
+                            // but holding off for a transition, we still need
+                            // to tell the client to make its windows visible so
+                            // they get drawn.  Otherwise, we will wait on
+                            // performing the transition until all windows have
+                            // been drawn, they never will be, and we are sad.
+                            wtoken.clientHidden = false;
+                            wtoken.sendAppVisibilityToClients();
+                        }
+                    }
+                } else {
+                    mClosingApps.add(wtoken);
+
+                    // If the token is currently visible (should be the
+                    // common case), then set up to wait for it to be hidden.
+                    if (!wtoken.hidden) {
+                        wtoken.waitingToHide = true;
+                    }
+                }
+                return;
+            }
+
+            final long origId = Binder.clearCallingIdentity();
+            setTokenVisibilityLocked(wtoken, null, visible, WindowManagerPolicy.TRANSIT_UNSET,
+                    true);
+            wtoken.updateReportedVisibilityLocked();
+            Binder.restoreCallingIdentity(origId);
+        }
+    }
+
+    void unsetAppFreezingScreenLocked(AppWindowToken wtoken,
+            boolean unfreezeSurfaceNow, boolean force) {
+        if (wtoken.mAppAnimator.freezingScreen) {
+            if (DEBUG_ORIENTATION) Slog.v(TAG, "Clear freezing of " + wtoken
+                    + " force=" + force);
+            final int N = wtoken.allAppWindows.size();
+            boolean unfrozeWindows = false;
+            for (int i=0; i<N; i++) {
+                WindowState w = wtoken.allAppWindows.get(i);
+                if (w.mAppFreezing) {
+                    w.mAppFreezing = false;
+                    if (w.mHasSurface && !w.mOrientationChanging) {
+                        if (DEBUG_ORIENTATION) Slog.v(TAG, "set mOrientationChanging of " + w);
+                        w.mOrientationChanging = true;
+                        mInnerFields.mOrientationChangeComplete = false;
+                    }
+                    unfrozeWindows = true;
+                }
+            }
+            if (force || unfrozeWindows) {
+                if (DEBUG_ORIENTATION) Slog.v(TAG, "No longer freezing: " + wtoken);
+                wtoken.mAppAnimator.freezingScreen = false;
+                mAppsFreezingScreen--;
+            }
+            if (unfreezeSurfaceNow) {
+                if (unfrozeWindows) {
+                    mLayoutNeeded = true;
+                    performLayoutAndPlaceSurfacesLocked();
+                }
+                stopFreezingDisplayLocked();
+            }
+        }
+    }
+
+    public void startAppFreezingScreenLocked(AppWindowToken wtoken,
+            int configChanges) {
+        if (DEBUG_ORIENTATION) {
+            RuntimeException e = null;
+            if (!HIDE_STACK_CRAWLS) {
+                e = new RuntimeException();
+                e.fillInStackTrace();
+            }
+            Slog.i(TAG, "Set freezing of " + wtoken.appToken
+                    + ": hidden=" + wtoken.hidden + " freezing="
+                    + wtoken.mAppAnimator.freezingScreen, e);
+        }
+        if (!wtoken.hiddenRequested) {
+            if (!wtoken.mAppAnimator.freezingScreen) {
+                wtoken.mAppAnimator.freezingScreen = true;
+                mAppsFreezingScreen++;
+                if (mAppsFreezingScreen == 1) {
+                    startFreezingDisplayLocked(false);
+                    mH.removeMessages(H.APP_FREEZE_TIMEOUT);
+                    mH.sendMessageDelayed(mH.obtainMessage(H.APP_FREEZE_TIMEOUT),
+                            5000);
+                }
+            }
+            final int N = wtoken.allAppWindows.size();
+            for (int i=0; i<N; i++) {
+                WindowState w = wtoken.allAppWindows.get(i);
+                w.mAppFreezing = true;
+            }
+        }
+    }
+
+    public void startAppFreezingScreen(IBinder token, int configChanges) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "setAppFreezingScreen()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        synchronized(mWindowMap) {
+            if (configChanges == 0 && okToDisplay()) {
+                if (DEBUG_ORIENTATION) Slog.v(TAG, "Skipping set freeze of " + token);
+                return;
+            }
+
+            AppWindowToken wtoken = findAppWindowToken(token);
+            if (wtoken == null || wtoken.appToken == null) {
+                Slog.w(TAG, "Attempted to freeze screen with non-existing app token: " + wtoken);
+                return;
+            }
+            final long origId = Binder.clearCallingIdentity();
+            startAppFreezingScreenLocked(wtoken, configChanges);
+            Binder.restoreCallingIdentity(origId);
+        }
+    }
+
+    public void stopAppFreezingScreen(IBinder token, boolean force) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "setAppFreezingScreen()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        synchronized(mWindowMap) {
+            AppWindowToken wtoken = findAppWindowToken(token);
+            if (wtoken == null || wtoken.appToken == null) {
+                return;
+            }
+            final long origId = Binder.clearCallingIdentity();
+            if (DEBUG_ORIENTATION) Slog.v(TAG, "Clear freezing of " + token
+                    + ": hidden=" + wtoken.hidden + " freezing=" + wtoken.mAppAnimator.freezingScreen);
+            unsetAppFreezingScreenLocked(wtoken, true, force);
+            Binder.restoreCallingIdentity(origId);
+        }
+    }
+
+    public void removeAppToken(IBinder token) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "removeAppToken()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        AppWindowToken wtoken = null;
+        AppWindowToken startingToken = null;
+        boolean delayed = false;
+
+        final long origId = Binder.clearCallingIdentity();
+        synchronized(mWindowMap) {
+            WindowToken basewtoken = mTokenMap.remove(token);
+            if (basewtoken != null && (wtoken=basewtoken.appWindowToken) != null) {
+                if (DEBUG_APP_TRANSITIONS) Slog.v(TAG, "Removing app token: " + wtoken);
+                delayed = setTokenVisibilityLocked(wtoken, null, false,
+                        WindowManagerPolicy.TRANSIT_UNSET, true);
+                wtoken.inPendingTransaction = false;
+                mOpeningApps.remove(wtoken);
+                wtoken.waitingToShow = false;
+                if (mClosingApps.contains(wtoken)) {
+                    delayed = true;
+                } else if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
+                    mClosingApps.add(wtoken);
+                    wtoken.waitingToHide = true;
+                    delayed = true;
+                }
+                if (DEBUG_APP_TRANSITIONS) Slog.v(
+                        TAG, "Removing app " + wtoken + " delayed=" + delayed
+                        + " animation=" + wtoken.mAppAnimator.animation
+                        + " animating=" + wtoken.mAppAnimator.animating);
+                if (delayed) {
+                    // set the token aside because it has an active animation to be finished
+                    if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT) Slog.v(TAG,
+                            "removeAppToken make exiting: " + wtoken);
+                    mExitingAppTokens.add(wtoken);
+                } else {
+                    // Make sure there is no animation running on this token,
+                    // so any windows associated with it will be removed as
+                    // soon as their animations are complete
+                    wtoken.mAppAnimator.clearAnimation();
+                    wtoken.mAppAnimator.animating = false;
+                }
+                if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT) Slog.v(TAG,
+                        "removeAppToken: " + wtoken);
+                mAppTokens.remove(wtoken);
+                mAnimatingAppTokens.remove(wtoken);
+                wtoken.removed = true;
+                if (wtoken.startingData != null) {
+                    startingToken = wtoken;
+                }
+                unsetAppFreezingScreenLocked(wtoken, true, true);
+                if (mFocusedApp == wtoken) {
+                    if (DEBUG_FOCUS) Slog.v(TAG, "Removing focused app token:" + wtoken);
+                    mFocusedApp = null;
+                    updateFocusedWindowLocked(UPDATE_FOCUS_NORMAL, true /*updateInputWindows*/);
+                    mInputMonitor.setFocusedAppLw(null);
+                }
+            } else {
+                Slog.w(TAG, "Attempted to remove non-existing app token: " + token);
+            }
+
+            if (!delayed && wtoken != null) {
+                wtoken.updateReportedVisibilityLocked();
+            }
+        }
+        Binder.restoreCallingIdentity(origId);
+
+        if (startingToken != null) {
+            if (DEBUG_STARTING_WINDOW) Slog.v(TAG, "Schedule remove starting "
+                    + startingToken + ": app token removed");
+            Message m = mH.obtainMessage(H.REMOVE_STARTING, startingToken);
+            mH.sendMessage(m);
+        }
+    }
+
+    private boolean tmpRemoveAppWindowsLocked(WindowToken token) {
+        final int NW = token.windows.size();
+        if (NW > 0) {
+            mWindowsChanged = true;
+        }
+        for (int i=0; i<NW; i++) {
+            WindowState win = token.windows.get(i);
+            if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Tmp removing app window " + win);
+            mWindows.remove(win);
+            int j = win.mChildWindows.size();
+            while (j > 0) {
+                j--;
+                WindowState cwin = win.mChildWindows.get(j);
+                if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG,
+                        "Tmp removing child window " + cwin);
+                mWindows.remove(cwin);
+            }
+        }
+        return NW > 0;
+    }
+
+    void dumpAppTokensLocked() {
+        for (int i=mAppTokens.size()-1; i>=0; i--) {
+            Slog.v(TAG, "  #" + i + ": " + mAppTokens.get(i).token);
+        }
+    }
+
+    void dumpAnimatingAppTokensLocked() {
+        for (int i=mAnimatingAppTokens.size()-1; i>=0; i--) {
+            Slog.v(TAG, "  #" + i + ": " + mAnimatingAppTokens.get(i).token);
+        }
+    }
+
+    void dumpWindowsLocked() {
+        for (int i=mWindows.size()-1; i>=0; i--) {
+            Slog.v(TAG, "  #" + i + ": " + mWindows.get(i));
+        }
+    }
+
+    private int findWindowOffsetLocked(int tokenPos) {
+        final int NW = mWindows.size();
+
+        if (tokenPos >= mAnimatingAppTokens.size()) {
+            int i = NW;
+            while (i > 0) {
+                i--;
+                WindowState win = mWindows.get(i);
+                if (win.getAppToken() != null) {
+                    return i+1;
+                }
+            }
+        }
+
+        while (tokenPos > 0) {
+            // Find the first app token below the new position that has
+            // a window displayed.
+            final AppWindowToken wtoken = mAnimatingAppTokens.get(tokenPos-1);
+            if (DEBUG_REORDER) Slog.v(TAG, "Looking for lower windows @ "
+                    + tokenPos + " -- " + wtoken.token);
+            if (wtoken.sendingToBottom) {
+                if (DEBUG_REORDER) Slog.v(TAG,
+                        "Skipping token -- currently sending to bottom");
+                tokenPos--;
+                continue;
+            }
+            int i = wtoken.windows.size();
+            while (i > 0) {
+                i--;
+                WindowState win = wtoken.windows.get(i);
+                int j = win.mChildWindows.size();
+                while (j > 0) {
+                    j--;
+                    WindowState cwin = win.mChildWindows.get(j);
+                    if (cwin.mSubLayer >= 0) {
+                        for (int pos=NW-1; pos>=0; pos--) {
+                            if (mWindows.get(pos) == cwin) {
+                                if (DEBUG_REORDER) Slog.v(TAG,
+                                        "Found child win @" + (pos+1));
+                                return pos+1;
+                            }
+                        }
+                    }
+                }
+                for (int pos=NW-1; pos>=0; pos--) {
+                    if (mWindows.get(pos) == win) {
+                        if (DEBUG_REORDER) Slog.v(TAG, "Found win @" + (pos+1));
+                        return pos+1;
+                    }
+                }
+            }
+            tokenPos--;
+        }
+
+        return 0;
+    }
+
+    private final int reAddWindowLocked(int index, WindowState win) {
+        final int NCW = win.mChildWindows.size();
+        boolean added = false;
+        for (int j=0; j<NCW; j++) {
+            WindowState cwin = win.mChildWindows.get(j);
+            if (!added && cwin.mSubLayer >= 0) {
+                if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Re-adding child window at "
+                        + index + ": " + cwin);
+                win.mRebuilding = false;
+                mWindows.add(index, win);
+                index++;
+                added = true;
+            }
+            if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Re-adding window at "
+                    + index + ": " + cwin);
+            cwin.mRebuilding = false;
+            mWindows.add(index, cwin);
+            index++;
+        }
+        if (!added) {
+            if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG, "Re-adding window at "
+                    + index + ": " + win);
+            win.mRebuilding = false;
+            mWindows.add(index, win);
+            index++;
+        }
+        mWindowsChanged = true;
+        return index;
+    }
+
+    private final int reAddAppWindowsLocked(int index, WindowToken token) {
+        final int NW = token.windows.size();
+        for (int i=0; i<NW; i++) {
+            index = reAddWindowLocked(index, token.windows.get(i));
+        }
+        return index;
+    }
+
+    public void moveAppToken(int index, IBinder token) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "moveAppToken()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        synchronized(mWindowMap) {
+            if (DEBUG_REORDER) Slog.v(TAG, "Initial app tokens:");
+            if (DEBUG_REORDER) dumpAppTokensLocked();
+            final AppWindowToken wtoken = findAppWindowToken(token);
+            final int oldIndex = mAppTokens.indexOf(wtoken);
+            if (DEBUG_TOKEN_MOVEMENT || DEBUG_REORDER) Slog.v(TAG,
+                    "Start moving token " + wtoken + " initially at "
+                    + oldIndex);
+            if (oldIndex > index && mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET
+                        && !mAppTransitionRunning) {
+                // animation towards back has not started, copy old list for duration of animation.
+                mAnimatingAppTokens.clear();
+                mAnimatingAppTokens.addAll(mAppTokens);
+            }
+            if (wtoken == null || !mAppTokens.remove(wtoken)) {
+                Slog.w(TAG, "Attempting to reorder token that doesn't exist: "
+                      + token + " (" + wtoken + ")");
+                return;
+            }
+            mAppTokens.add(index, wtoken);
+            if (DEBUG_REORDER) Slog.v(TAG, "Moved " + token + " to " + index + ":");
+            else if (DEBUG_TOKEN_MOVEMENT) Slog.v(TAG, "Moved " + token + " to " + index);
+            if (DEBUG_REORDER) dumpAppTokensLocked();
+            if (mNextAppTransition == WindowManagerPolicy.TRANSIT_UNSET && !mAppTransitionRunning) {
+                // Not animating, bring animating app list in line with mAppTokens.
+                mAnimatingAppTokens.clear();
+                mAnimatingAppTokens.addAll(mAppTokens);
+
+                // Bring window ordering, window focus and input window in line with new app token
+                final long origId = Binder.clearCallingIdentity();
+                if (DEBUG_REORDER) Slog.v(TAG, "Removing windows in " + token + ":");
+                if (DEBUG_REORDER) dumpWindowsLocked();
+                if (tmpRemoveAppWindowsLocked(wtoken)) {
+                    if (DEBUG_REORDER) Slog.v(TAG, "Adding windows back in:");
+                    if (DEBUG_REORDER) dumpWindowsLocked();
+                    reAddAppWindowsLocked(findWindowOffsetLocked(index), wtoken);
+                    if (DEBUG_REORDER) Slog.v(TAG, "Final window list:");
+                    if (DEBUG_REORDER) dumpWindowsLocked();
+                    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,
+                            false /*updateInputWindows*/);
+                    mLayoutNeeded = true;
+                    mInputMonitor.setUpdateInputWindowsNeededLw();
+                    performLayoutAndPlaceSurfacesLocked();
+                    mInputMonitor.updateInputWindowsLw(false /*force*/);
+                }
+                Binder.restoreCallingIdentity(origId);
+            }
+        }
+    }
+
+    private void removeAppTokensLocked(List<IBinder> tokens) {
+        // XXX This should be done more efficiently!
+        // (take advantage of the fact that both lists should be
+        // ordered in the same way.)
+        int N = tokens.size();
+        for (int i=0; i<N; i++) {
+            IBinder token = tokens.get(i);
+            final AppWindowToken wtoken = findAppWindowToken(token);
+            if (DEBUG_REORDER || DEBUG_TOKEN_MOVEMENT) Slog.v(TAG,
+                    "Temporarily removing " + wtoken + " from " + mAppTokens.indexOf(wtoken));
+            if (!mAppTokens.remove(wtoken)) {
+                Slog.w(TAG, "Attempting to reorder token that doesn't exist: "
+                      + token + " (" + wtoken + ")");
+                i--;
+                N--;
+            }
+        }
+    }
+
+    private void moveAppWindowsLocked(AppWindowToken wtoken, int tokenPos,
+            boolean updateFocusAndLayout) {
+        // First remove all of the windows from the list.
+        tmpRemoveAppWindowsLocked(wtoken);
+
+        // Where to start adding?
+        int pos = findWindowOffsetLocked(tokenPos);
+
+        // And now add them back at the correct place.
+        pos = reAddAppWindowsLocked(pos, wtoken);
+
+        if (updateFocusAndLayout) {
+            mInputMonitor.setUpdateInputWindowsNeededLw();
+            if (!updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,
+                    false /*updateInputWindows*/)) {
+                assignLayersLocked();
+            }
+            mLayoutNeeded = true;
+            if (!mInLayout) {
+                performLayoutAndPlaceSurfacesLocked();
+            }
+            mInputMonitor.updateInputWindowsLw(false /*force*/);
+        }
+    }
+
+    private void moveAppWindowsLocked(List<IBinder> tokens, int tokenPos) {
+        // First remove all of the windows from the list.
+        final int N = tokens.size();
+        int i;
+        for (i=0; i<N; i++) {
+            WindowToken token = mTokenMap.get(tokens.get(i));
+            if (token != null) {
+                tmpRemoveAppWindowsLocked(token);
+            }
+        }
+
+        // Where to start adding?
+        int pos = findWindowOffsetLocked(tokenPos);
+
+        // And now add them back at the correct place.
+        for (i=0; i<N; i++) {
+            WindowToken token = mTokenMap.get(tokens.get(i));
+            if (token != null) {
+                pos = reAddAppWindowsLocked(pos, token);
+            }
+        }
+
+        mInputMonitor.setUpdateInputWindowsNeededLw();
+        if (!updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,
+                false /*updateInputWindows*/)) {
+            assignLayersLocked();
+        }
+        mLayoutNeeded = true;
+        performLayoutAndPlaceSurfacesLocked();
+        mInputMonitor.updateInputWindowsLw(false /*force*/);
+
+        //dump();
+    }
+
+    public void moveAppTokensToTop(List<IBinder> tokens) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "moveAppTokensToTop()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        final long origId = Binder.clearCallingIdentity();
+        synchronized(mWindowMap) {
+            removeAppTokensLocked(tokens);
+            final int N = tokens.size();
+            for (int i=0; i<N; i++) {
+                AppWindowToken wt = findAppWindowToken(tokens.get(i));
+                if (wt != null) {
+                    if (DEBUG_TOKEN_MOVEMENT || DEBUG_REORDER) Slog.v(TAG,
+                            "Adding next to top: " + wt);
+                    mAppTokens.add(wt);
+                    if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
+                        wt.sendingToBottom = false;
+                    }
+                }
+            }
+
+            if (!mAppTransitionRunning) {
+                mAnimatingAppTokens.clear();
+                mAnimatingAppTokens.addAll(mAppTokens);
+                moveAppWindowsLocked(tokens, mAppTokens.size());
+            }
+        }
+        Binder.restoreCallingIdentity(origId);
+    }
+
+    @Override
+    public void moveAppTokensToBottom(List<IBinder> tokens) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "moveAppTokensToBottom()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        final long origId = Binder.clearCallingIdentity();
+        synchronized(mWindowMap) {
+            final int N = tokens.size();
+            if (N > 0 && !mAppTransitionRunning) {
+                // animating towards back, hang onto old list for duration of animation.
+                mAnimatingAppTokens.clear();
+                mAnimatingAppTokens.addAll(mAppTokens);
+            }
+            removeAppTokensLocked(tokens);
+            int pos = 0;
+            for (int i=0; i<N; i++) {
+                AppWindowToken wt = findAppWindowToken(tokens.get(i));
+                if (wt != null) {
+                    if (DEBUG_TOKEN_MOVEMENT) Slog.v(TAG,
+                            "Adding next to bottom: " + wt + " at " + pos);
+                    mAppTokens.add(pos, wt);
+                    if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
+                        wt.sendingToBottom = true;
+                    }
+                    pos++;
+                }
+            }
+
+            if (!mAppTransitionRunning) {
+                mAnimatingAppTokens.clear();
+                mAnimatingAppTokens.addAll(mAppTokens);
+                moveAppWindowsLocked(tokens, 0);
+            }
+        }
+        Binder.restoreCallingIdentity(origId);
+    }
+
+    // -------------------------------------------------------------
+    // Misc IWindowSession methods
+    // -------------------------------------------------------------
+
+    private boolean shouldAllowDisableKeyguard()
+    {
+        // We fail safe and prevent disabling keyguard in the unlikely event this gets 
+        // called before DevicePolicyManagerService has started.
+        if (mAllowDisableKeyguard == ALLOW_DISABLE_UNKNOWN) {
+            DevicePolicyManager dpm = (DevicePolicyManager) mContext.getSystemService(
+                    Context.DEVICE_POLICY_SERVICE);
+            if (dpm != null) {
+                mAllowDisableKeyguard = dpm.getPasswordQuality(null)
+                        == DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED ?
+                                ALLOW_DISABLE_YES : ALLOW_DISABLE_NO;
+            }
+        }
+        return mAllowDisableKeyguard == ALLOW_DISABLE_YES;
+    }
+
+    public void disableKeyguard(IBinder token, String tag) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DISABLE_KEYGUARD)
+            != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires DISABLE_KEYGUARD permission");
+        }
+
+        synchronized (mKeyguardTokenWatcher) {
+            mKeyguardTokenWatcher.acquire(token, tag);
+        }
+    }
+
+    public void reenableKeyguard(IBinder token) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DISABLE_KEYGUARD)
+            != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires DISABLE_KEYGUARD permission");
+        }
+
+        synchronized (mKeyguardTokenWatcher) {
+            mKeyguardTokenWatcher.release(token);
+
+            if (!mKeyguardTokenWatcher.isAcquired()) {
+                // If we are the last one to reenable the keyguard wait until
+                // we have actually finished reenabling until returning.
+                // It is possible that reenableKeyguard() can be called before
+                // the previous disableKeyguard() is handled, in which case
+                // neither mKeyguardTokenWatcher.acquired() or released() would
+                // be called. In that case mKeyguardDisabled will be false here
+                // and we have nothing to wait for.
+                while (mKeyguardDisabled) {
+                    try {
+                        mKeyguardTokenWatcher.wait();
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * @see android.app.KeyguardManager#exitKeyguardSecurely
+     */
+    public void exitKeyguardSecurely(final IOnKeyguardExitResult callback) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DISABLE_KEYGUARD)
+            != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires DISABLE_KEYGUARD permission");
+        }
+        mPolicy.exitKeyguardSecurely(new WindowManagerPolicy.OnKeyguardExitResult() {
+            public void onKeyguardExitResult(boolean success) {
+                try {
+                    callback.onKeyguardExitResult(success);
+                } catch (RemoteException e) {
+                    // Client has died, we don't care.
+                }
+            }
+        });
+    }
+
+    public boolean inKeyguardRestrictedInputMode() {
+        return mPolicy.inKeyguardRestrictedKeyInputMode();
+    }
+
+    public boolean isKeyguardLocked() {
+        return mPolicy.isKeyguardLocked();
+    }
+
+    public boolean isKeyguardSecure() {
+        return mPolicy.isKeyguardSecure();
+    }
+
+    public void dismissKeyguard() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DISABLE_KEYGUARD)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires DISABLE_KEYGUARD permission");
+        }
+        synchronized(mWindowMap) {
+            mPolicy.dismissKeyguardLw();
+        }
+    }
+
+    public void closeSystemDialogs(String reason) {
+        synchronized(mWindowMap) {
+            for (int i=mWindows.size()-1; i>=0; i--) {
+                WindowState w = mWindows.get(i);
+                if (w.mHasSurface) {
+                    try {
+                        w.mClient.closeSystemDialogs(reason);
+                    } catch (RemoteException e) {
+                    }
+                }
+            }
+        }
+    }
+
+    static float fixScale(float scale) {
+        if (scale < 0) scale = 0;
+        else if (scale > 20) scale = 20;
+        return Math.abs(scale);
+    }
+
+    public void setAnimationScale(int which, float scale) {
+        if (!checkCallingPermission(android.Manifest.permission.SET_ANIMATION_SCALE,
+                "setAnimationScale()")) {
+            throw new SecurityException("Requires SET_ANIMATION_SCALE permission");
+        }
+
+        if (scale < 0) scale = 0;
+        else if (scale > 20) scale = 20;
+        scale = Math.abs(scale);
+        switch (which) {
+            case 0: mWindowAnimationScale = fixScale(scale); break;
+            case 1: mTransitionAnimationScale = fixScale(scale); break;
+            case 2: mAnimatorDurationScale = fixScale(scale); break;
+        }
+
+        // Persist setting
+        mH.obtainMessage(H.PERSIST_ANIMATION_SCALE).sendToTarget();
+    }
+
+    public void setAnimationScales(float[] scales) {
+        if (!checkCallingPermission(android.Manifest.permission.SET_ANIMATION_SCALE,
+                "setAnimationScale()")) {
+            throw new SecurityException("Requires SET_ANIMATION_SCALE permission");
+        }
+
+        if (scales != null) {
+            if (scales.length >= 1) {
+                mWindowAnimationScale = fixScale(scales[0]);
+            }
+            if (scales.length >= 2) {
+                mTransitionAnimationScale = fixScale(scales[1]);
+            }
+            if (scales.length >= 3) {
+                mAnimatorDurationScale = fixScale(scales[2]);
+            }
+        }
+
+        // Persist setting
+        mH.obtainMessage(H.PERSIST_ANIMATION_SCALE).sendToTarget();
+    }
+
+    public float getAnimationScale(int which) {
+        switch (which) {
+            case 0: return mWindowAnimationScale;
+            case 1: return mTransitionAnimationScale;
+            case 2: return mAnimatorDurationScale;
+        }
+        return 0;
+    }
+
+    public float[] getAnimationScales() {
+        return new float[] { mWindowAnimationScale, mTransitionAnimationScale,
+                mAnimatorDurationScale };
+    }
+
+    // Called by window manager policy. Not exposed externally.
+    @Override
+    public int getLidState() {
+        int sw = mInputManager.getSwitchState(-1, InputDevice.SOURCE_ANY,
+                InputManagerService.SW_LID);
+        if (sw > 0) {
+            // Switch state: AKEY_STATE_DOWN or AKEY_STATE_VIRTUAL.
+            return LID_CLOSED;
+        } else if (sw == 0) {
+            // Switch state: AKEY_STATE_UP.
+            return LID_OPEN;
+        } else {
+            // Switch state: AKEY_STATE_UNKNOWN.
+            return LID_ABSENT;
+        }
+    }
+
+    // Called by window manager policy.  Not exposed externally.
+    @Override
+    public InputChannel monitorInput(String inputChannelName) {
+        return mInputManager.monitorInput(inputChannelName);
+    }
+
+    // Called by window manager policy.  Not exposed externally.
+    @Override
+    public void switchKeyboardLayout(int deviceId, int direction) {
+        mInputManager.switchKeyboardLayout(deviceId, direction);
+    }
+
+    // Called by window manager policy.  Not exposed externally.
+    @Override
+    public void shutdown() {
+        ShutdownThread.shutdown(mContext, true);
+    }
+
+    // Called by window manager policy.  Not exposed externally.
+    @Override
+    public void rebootSafeMode() {
+        ShutdownThread.rebootSafeMode(mContext, true);
+    }
+
+    public void setInputFilter(InputFilter filter) {
+        mInputManager.setInputFilter(filter);
+    }
+
+    public void enableScreenAfterBoot() {
+        synchronized(mWindowMap) {
+            if (DEBUG_BOOT) {
+                RuntimeException here = new RuntimeException("here");
+                here.fillInStackTrace();
+                Slog.i(TAG, "enableScreenAfterBoot: mDisplayEnabled=" + mDisplayEnabled
+                        + " mForceDisplayEnabled=" + mForceDisplayEnabled
+                        + " mShowingBootMessages=" + mShowingBootMessages
+                        + " mSystemBooted=" + mSystemBooted, here);
+            }
+            if (mSystemBooted) {
+                return;
+            }
+            mSystemBooted = true;
+            hideBootMessagesLocked();
+            // If the screen still doesn't come up after 30 seconds, give
+            // up and turn it on.
+            Message msg = mH.obtainMessage(H.BOOT_TIMEOUT);
+            mH.sendMessageDelayed(msg, 30*1000);
+        }
+
+        mPolicy.systemBooted();
+
+        performEnableScreen();
+    }
+
+    void enableScreenIfNeededLocked() {
+        if (DEBUG_BOOT) {
+            RuntimeException here = new RuntimeException("here");
+            here.fillInStackTrace();
+            Slog.i(TAG, "enableScreenIfNeededLocked: mDisplayEnabled=" + mDisplayEnabled
+                    + " mForceDisplayEnabled=" + mForceDisplayEnabled
+                    + " mShowingBootMessages=" + mShowingBootMessages
+                    + " mSystemBooted=" + mSystemBooted, here);
+        }
+        if (mDisplayEnabled) {
+            return;
+        }
+        if (!mSystemBooted && !mShowingBootMessages) {
+            return;
+        }
+        mH.sendMessage(mH.obtainMessage(H.ENABLE_SCREEN));
+    }
+
+    public void performBootTimeout() {
+        synchronized(mWindowMap) {
+            if (mDisplayEnabled || mHeadless) {
+                return;
+            }
+            Slog.w(TAG, "***** BOOT TIMEOUT: forcing display enabled");
+            mForceDisplayEnabled = true;
+        }
+        performEnableScreen();
+    }
+
+    public void performEnableScreen() {
+        synchronized(mWindowMap) {
+            if (DEBUG_BOOT) {
+                RuntimeException here = new RuntimeException("here");
+                here.fillInStackTrace();
+                Slog.i(TAG, "performEnableScreen: mDisplayEnabled=" + mDisplayEnabled
+                        + " mForceDisplayEnabled=" + mForceDisplayEnabled
+                        + " mShowingBootMessages=" + mShowingBootMessages
+                        + " mSystemBooted=" + mSystemBooted
+                        + " mOnlyCore=" + mOnlyCore, here);
+            }
+            if (mDisplayEnabled) {
+                return;
+            }
+            if (!mSystemBooted && !mShowingBootMessages) {
+                return;
+            }
+
+            if (!mForceDisplayEnabled) {
+                // Don't enable the screen until all existing windows
+                // have been drawn.
+                boolean haveBootMsg = false;
+                boolean haveApp = false;
+                // if the wallpaper service is disabled on the device, we're never going to have
+                // wallpaper, don't bother waiting for it
+                boolean haveWallpaper = false;
+                boolean wallpaperEnabled = mContext.getResources().getBoolean(
+                        com.android.internal.R.bool.config_enableWallpaperService)
+                        && !mOnlyCore;
+                boolean haveKeyguard = true;
+                final int N = mWindows.size();
+                for (int i=0; i<N; i++) {
+                    WindowState w = mWindows.get(i);
+                    if (w.mAttrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD) {
+                        // Only if there is a keyguard attached to the window manager
+                        // will we consider ourselves as having a keyguard.  If it
+                        // isn't attached, we don't know if it wants to be shown or
+                        // hidden.  If it is attached, we will say we have a keyguard
+                        // if the window doesn't want to be visible, because in that
+                        // case it explicitly doesn't want to be shown so we should
+                        // not delay turning the screen on for it.
+                        boolean vis = w.mViewVisibility == View.VISIBLE
+                                && w.mPolicyVisibility;
+                        haveKeyguard = !vis;
+                    }
+                    if (w.isVisibleLw() && !w.mObscured && !w.isDrawnLw()) {
+                        return;
+                    }
+                    if (w.isDrawnLw()) {
+                        if (w.mAttrs.type == WindowManager.LayoutParams.TYPE_BOOT_PROGRESS) {
+                            haveBootMsg = true;
+                        } else if (w.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION) {
+                            haveApp = true;
+                        } else if (w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER) {
+                            haveWallpaper = true;
+                        } else if (w.mAttrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD) {
+                            haveKeyguard = true;
+                        }
+                    }
+                }
+
+                if (DEBUG_SCREEN_ON || DEBUG_BOOT) {
+                    Slog.i(TAG, "******** booted=" + mSystemBooted + " msg=" + mShowingBootMessages
+                            + " haveBoot=" + haveBootMsg + " haveApp=" + haveApp
+                            + " haveWall=" + haveWallpaper + " wallEnabled=" + wallpaperEnabled
+                            + " haveKeyguard=" + haveKeyguard);
+                }
+
+                // If we are turning on the screen to show the boot message,
+                // don't do it until the boot message is actually displayed.
+                if (!mSystemBooted && !haveBootMsg) {
+                    return;
+                }
+    
+                // If we are turning on the screen after the boot is completed
+                // normally, don't do so until we have the application and
+                // wallpaper.
+                if (mSystemBooted && ((!haveApp && !haveKeyguard) ||
+                        (wallpaperEnabled && !haveWallpaper))) {
+                    return;
+                }
+            }
+
+            mDisplayEnabled = true;
+            if (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG, "******************** ENABLING SCREEN!");
+            if (false) {
+                StringWriter sw = new StringWriter();
+                PrintWriter pw = new PrintWriter(sw);
+                this.dump(null, pw, null);
+                Slog.i(TAG, sw.toString());
+            }
+            try {
+                IBinder surfaceFlinger = ServiceManager.getService("SurfaceFlinger");
+                if (surfaceFlinger != null) {
+                    //Slog.i(TAG, "******* TELLING SURFACE FLINGER WE ARE BOOTED!");
+                    Parcel data = Parcel.obtain();
+                    data.writeInterfaceToken("android.ui.ISurfaceComposer");
+                    surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION, // BOOT_FINISHED
+                                            data, null, 0);
+                    data.recycle();
+                }
+            } catch (RemoteException ex) {
+                Slog.e(TAG, "Boot completed: SurfaceFlinger is dead!");
+            }
+
+            // Enable input dispatch.
+            mInputMonitor.setEventDispatchingLw(mEventDispatchingEnabled);
+        }
+
+        mPolicy.enableScreenAfterBoot();
+
+        // Make sure the last requested orientation has been applied.
+        updateRotationUnchecked(false, false);
+    }
+
+    public void showBootMessage(final CharSequence msg, final boolean always) {
+        boolean first = false;
+        synchronized(mWindowMap) {
+            if (DEBUG_BOOT) {
+                RuntimeException here = new RuntimeException("here");
+                here.fillInStackTrace();
+                Slog.i(TAG, "showBootMessage: msg=" + msg + " always=" + always
+                        + " mAllowBootMessages=" + mAllowBootMessages
+                        + " mShowingBootMessages=" + mShowingBootMessages
+                        + " mSystemBooted=" + mSystemBooted, here);
+            }
+            if (!mAllowBootMessages) {
+                return;
+            }
+            if (!mShowingBootMessages) {
+                if (!always) {
+                    return;
+                }
+                first = true;
+            }
+            if (mSystemBooted) {
+                return;
+            }
+            mShowingBootMessages = true;
+            mPolicy.showBootMessage(msg, always);
+        }
+        if (first) {
+            performEnableScreen();
+        }
+    }
+
+    public void hideBootMessagesLocked() {
+        if (DEBUG_BOOT) {
+            RuntimeException here = new RuntimeException("here");
+            here.fillInStackTrace();
+            Slog.i(TAG, "hideBootMessagesLocked: mDisplayEnabled=" + mDisplayEnabled
+                    + " mForceDisplayEnabled=" + mForceDisplayEnabled
+                    + " mShowingBootMessages=" + mShowingBootMessages
+                    + " mSystemBooted=" + mSystemBooted, here);
+        }
+        if (mShowingBootMessages) {
+            mShowingBootMessages = false;
+            mPolicy.hideBootMessages();
+        }
+    }
+
+    public void setInTouchMode(boolean mode) {
+        synchronized(mWindowMap) {
+            mInTouchMode = mode;
+        }
+    }
+
+    // TODO: more accounting of which pid(s) turned it on, keep count,
+    // only allow disables from pids which have count on, etc.
+    @Override
+    public void showStrictModeViolation(boolean on) {
+        if (mHeadless) return;
+        mH.sendMessage(mH.obtainMessage(H.SHOW_STRICT_MODE_VIOLATION, on ? 1 : 0, 0));
+    }
+
+    private void showStrictModeViolation(int arg) {
+        final boolean on = arg != 0;
+        int pid = Binder.getCallingPid();
+        synchronized(mWindowMap) {
+            // Ignoring requests to enable the red border from clients
+            // which aren't on screen.  (e.g. Broadcast Receivers in
+            // the background..)
+            if (on) {
+                boolean isVisible = false;
+                for (int i = mWindows.size() - 1; i >= 0; i--) {
+                    final WindowState ws = mWindows.get(i);
+                    if (ws.mSession.mPid == pid && ws.isVisibleLw()) {
+                        isVisible = true;
+                        break;
+                    }
+                }
+                if (!isVisible) {
+                    return;
+                }
+            }
+
+            if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG,
+                    ">>> OPEN TRANSACTION showStrictModeViolation");
+            Surface.openTransaction();
+            try {
+                if (mStrictModeFlash == null) {
+                    mStrictModeFlash = new StrictModeFlash(mDisplay, mFxSession);
+                }
+                mStrictModeFlash.setVisibility(on);
+            } finally {
+                Surface.closeTransaction();
+                if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG,
+                        "<<< CLOSE TRANSACTION showStrictModeViolation");
+            }
+        }
+    }
+
+    public void setStrictModeVisualIndicatorPreference(String value) {
+        SystemProperties.set(StrictMode.VISUAL_PROPERTY, value);
+    }
+
+    /**
+     * Takes a snapshot of the screen.  In landscape mode this grabs the whole screen.
+     * In portrait mode, it grabs the upper region of the screen based on the vertical dimension
+     * of the target image.
+     * 
+     * @param width the width of the target bitmap
+     * @param height the height of the target bitmap
+     */
+    public Bitmap screenshotApplications(IBinder appToken, int width, int height) {
+        if (!checkCallingPermission(android.Manifest.permission.READ_FRAME_BUFFER,
+                "screenshotApplications()")) {
+            throw new SecurityException("Requires READ_FRAME_BUFFER permission");
+        }
+
+        Bitmap rawss;
+
+        int maxLayer = 0;
+        final Rect frame = new Rect();
+
+        float scale;
+        int dw, dh;
+        int rot;
+
+        synchronized(mWindowMap) {
+            long ident = Binder.clearCallingIdentity();
+
+            dw = mCurDisplayWidth;
+            dh = mCurDisplayHeight;
+
+            int aboveAppLayer = mPolicy.windowTypeToLayerLw(
+                    WindowManager.LayoutParams.TYPE_APPLICATION) * TYPE_LAYER_MULTIPLIER
+                    + TYPE_LAYER_OFFSET;
+            aboveAppLayer += TYPE_LAYER_MULTIPLIER;
+
+            boolean isImeTarget = mInputMethodTarget != null
+                    && mInputMethodTarget.mAppToken != null
+                    && mInputMethodTarget.mAppToken.appToken != null
+                    && mInputMethodTarget.mAppToken.appToken.asBinder() == appToken;
+
+            // Figure out the part of the screen that is actually the app.
+            boolean including = false;
+            for (int i=mWindows.size()-1; i>=0; i--) {
+                WindowState ws = mWindows.get(i);
+                if (!ws.mHasSurface) {
+                    continue;
+                }
+                if (ws.mLayer >= aboveAppLayer) {
+                    continue;
+                }
+                // When we will skip windows: when we are not including
+                // ones behind a window we didn't skip, and we are actually
+                // taking a screenshot of a specific app.
+                if (!including && appToken != null) {
+                    // Also, we can possibly skip this window if it is not
+                    // an IME target or the application for the screenshot
+                    // is not the current IME target.
+                    if (!ws.mIsImWindow || !isImeTarget) {
+                        // And finally, this window is of no interest if it
+                        // is not associated with the screenshot app.
+                        if (ws.mAppToken == null || ws.mAppToken.token != appToken) {
+                            continue;
+                        }
+                    }
+                }
+
+                // We keep on including windows until we go past a full-screen
+                // window.
+                including = !ws.mIsImWindow && !ws.isFullscreen(dw, dh);
+
+                if (maxLayer < ws.mWinAnimator.mSurfaceLayer) {
+                    maxLayer = ws.mWinAnimator.mSurfaceLayer;
+                }
+                
+                // Don't include wallpaper in bounds calculation
+                if (!ws.mIsWallpaper) {
+                    final Rect wf = ws.mFrame;
+                    final Rect cr = ws.mContentInsets;
+                    int left = wf.left + cr.left;
+                    int top = wf.top + cr.top;
+                    int right = wf.right - cr.right;
+                    int bottom = wf.bottom - cr.bottom;
+                    frame.union(left, top, right, bottom);
+                }
+            }
+            Binder.restoreCallingIdentity(ident);
+
+            // Constrain frame to the screen size.
+            frame.intersect(0, 0, dw, dh);
+
+            if (frame.isEmpty() || maxLayer == 0) {
+                return null;
+            }
+
+            // The screenshot API does not apply the current screen rotation.
+            rot = mDisplay.getRotation();
+            int fw = frame.width();
+            int fh = frame.height();
+
+            // Constrain thumbnail to smaller of screen width or height. Assumes aspect
+            // of thumbnail is the same as the screen (in landscape) or square.
+            float targetWidthScale = width / (float) fw;
+            float targetHeightScale = height / (float) fh;
+            if (dw <= dh) {
+                scale = targetWidthScale;
+                // If aspect of thumbnail is the same as the screen (in landscape),
+                // select the slightly larger value so we fill the entire bitmap
+                if (targetHeightScale > scale && (int) (targetHeightScale * fw) == width) {
+                    scale = targetHeightScale;
+                }
+            } else {
+                scale = targetHeightScale;
+                // If aspect of thumbnail is the same as the screen (in landscape),
+                // select the slightly larger value so we fill the entire bitmap
+                if (targetWidthScale > scale && (int) (targetWidthScale * fh) == height) {
+                    scale = targetWidthScale;
+                }
+            }
+
+            // The screen shot will contain the entire screen.
+            dw = (int)(dw*scale);
+            dh = (int)(dh*scale);
+            if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
+                int tmp = dw;
+                dw = dh;
+                dh = tmp;
+                rot = (rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
+            }
+            if (DEBUG_SCREENSHOT) {
+                Slog.i(TAG, "Screenshot: " + dw + "x" + dh + " from 0 to " + maxLayer);
+                for (int i=0; i<mWindows.size(); i++) {
+                    Slog.i(TAG, mWindows.get(i) + ": " + mWindows.get(i).mLayer
+                            + " animLayer=" + mWindows.get(i).mWinAnimator.mAnimLayer
+                            + " surfaceLayer=" + mWindows.get(i).mWinAnimator.mSurfaceLayer);
+                }
+            }
+            rawss = Surface.screenshot(dw, dh, 0, maxLayer);
+        }
+
+        if (rawss == null) {
+            Slog.w(TAG, "Failure taking screenshot for (" + dw + "x" + dh
+                    + ") to layer " + maxLayer);
+            return null;
+        }
+
+        Bitmap bm = Bitmap.createBitmap(width, height, rawss.getConfig());
+        Matrix matrix = new Matrix();
+        ScreenRotationAnimation.createRotationMatrix(rot, dw, dh, matrix);
+        matrix.postTranslate(-FloatMath.ceil(frame.left*scale), -FloatMath.ceil(frame.top*scale));
+        Canvas canvas = new Canvas(bm);
+        canvas.drawBitmap(rawss, matrix, null);
+        canvas.setBitmap(null);
+
+        rawss.recycle();
+        return bm;
+    }
+
+    /**
+     * Freeze rotation changes.  (Enable "rotation lock".)
+     * Persists across reboots.
+     * @param rotation The desired rotation to freeze to, or -1 to use the
+     * current rotation.
+     */
+    public void freezeRotation(int rotation) {
+        if (!checkCallingPermission(android.Manifest.permission.SET_ORIENTATION,
+                "freezeRotation()")) {
+            throw new SecurityException("Requires SET_ORIENTATION permission");
+        }
+        if (rotation < -1 || rotation > Surface.ROTATION_270) {
+            throw new IllegalArgumentException("Rotation argument must be -1 or a valid "
+                    + "rotation constant.");
+        }
+
+        if (DEBUG_ORIENTATION) Slog.v(TAG, "freezeRotation: mRotation=" + mRotation);
+
+        mPolicy.setUserRotationMode(WindowManagerPolicy.USER_ROTATION_LOCKED,
+                rotation == -1 ? mRotation : rotation);
+        updateRotationUnchecked(false, false);
+    }
+
+    /**
+     * Thaw rotation changes.  (Disable "rotation lock".)
+     * Persists across reboots.
+     */
+    public void thawRotation() {
+        if (!checkCallingPermission(android.Manifest.permission.SET_ORIENTATION,
+                "thawRotation()")) {
+            throw new SecurityException("Requires SET_ORIENTATION permission");
+        }
+
+        if (DEBUG_ORIENTATION) Slog.v(TAG, "thawRotation: mRotation=" + mRotation);
+
+        mPolicy.setUserRotationMode(WindowManagerPolicy.USER_ROTATION_FREE, 777); // rot not used
+        updateRotationUnchecked(false, false);
+    }
+
+    /**
+     * Recalculate the current rotation.
+     *
+     * Called by the window manager policy whenever the state of the system changes
+     * such that the current rotation might need to be updated, such as when the
+     * device is docked or rotated into a new posture.
+     */
+    public void updateRotation(boolean alwaysSendConfiguration, boolean forceRelayout) {
+        updateRotationUnchecked(alwaysSendConfiguration, forceRelayout);
+    }
+
+    /**
+     * Temporarily pauses rotation changes until resumed.
+     *
+     * This can be used to prevent rotation changes from occurring while the user is
+     * performing certain operations, such as drag and drop.
+     *
+     * This call nests and must be matched by an equal number of calls to {@link #resumeRotation}.
+     */
+    void pauseRotationLocked() {
+        mDeferredRotationPauseCount += 1;
+    }
+
+    /**
+     * Resumes normal rotation changes after being paused.
+     */
+    void resumeRotationLocked() {
+        if (mDeferredRotationPauseCount > 0) {
+            mDeferredRotationPauseCount -= 1;
+            if (mDeferredRotationPauseCount == 0) {
+                boolean changed = updateRotationUncheckedLocked(false);
+                if (changed) {
+                    mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
+                }
+            }
+        }
+    }
+
+    public void updateRotationUnchecked(boolean alwaysSendConfiguration, boolean forceRelayout) {
+        if(DEBUG_ORIENTATION) Slog.v(TAG, "updateRotationUnchecked("
+                   + "alwaysSendConfiguration=" + alwaysSendConfiguration + ")");
+
+        long origId = Binder.clearCallingIdentity();
+        boolean changed;
+        synchronized(mWindowMap) {
+            changed = updateRotationUncheckedLocked(false);
+            if (!changed || forceRelayout) {
+                mLayoutNeeded = true;
+                performLayoutAndPlaceSurfacesLocked();
+            }
+        }
+
+        if (changed || alwaysSendConfiguration) {
+            sendNewConfiguration();
+        }
+
+        Binder.restoreCallingIdentity(origId);
+    }
+
+    /**
+     * Updates the current rotation.
+     *
+     * Returns true if the rotation has been changed.  In this case YOU
+     * MUST CALL sendNewConfiguration() TO UNFREEZE THE SCREEN.
+     */
+    public boolean updateRotationUncheckedLocked(boolean inTransaction) {
+        if (mDeferredRotationPauseCount > 0) {
+            // Rotation updates have been paused temporarily.  Defer the update until
+            // updates have been resumed.
+            if (DEBUG_ORIENTATION) Slog.v(TAG, "Deferring rotation, rotation is paused.");
+            return false;
+        }
+
+        if (mAnimator.mScreenRotationAnimation != null &&
+                mAnimator.mScreenRotationAnimation.isAnimating()) {
+            // Rotation updates cannot be performed while the previous rotation change
+            // animation is still in progress.  Skip this update.  We will try updating
+            // again after the animation is finished and the display is unfrozen.
+            if (DEBUG_ORIENTATION) Slog.v(TAG, "Deferring rotation, animation in progress.");
+            return false;
+        }
+
+        if (!mDisplayEnabled) {
+            // No point choosing a rotation if the display is not enabled.
+            if (DEBUG_ORIENTATION) Slog.v(TAG, "Deferring rotation, display is not enabled.");
+            return false;
+        }
+
+        // TODO: Implement forced rotation changes.
+        //       Set mAltOrientation to indicate that the application is receiving
+        //       an orientation that has different metrics than it expected.
+        //       eg. Portrait instead of Landscape.
+
+        int rotation = mPolicy.rotationForOrientationLw(mForcedAppOrientation, mRotation);
+        boolean altOrientation = !mPolicy.rotationHasCompatibleMetricsLw(
+                mForcedAppOrientation, rotation);
+
+        if (DEBUG_ORIENTATION) {
+            Slog.v(TAG, "Application requested orientation "
+                    + mForcedAppOrientation + ", got rotation " + rotation
+                    + " which has " + (altOrientation ? "incompatible" : "compatible")
+                    + " metrics");
+        }
+
+        if (mRotation == rotation && mAltOrientation == altOrientation) {
+            // No change.
+            return false;
+        }
+
+        if (DEBUG_ORIENTATION) {
+            Slog.v(TAG,
+                "Rotation changed to " + rotation + (altOrientation ? " (alt)" : "")
+                + " from " + mRotation + (mAltOrientation ? " (alt)" : "")
+                + ", forceApp=" + mForcedAppOrientation);
+        }
+
+        mRotation = rotation;
+        mAltOrientation = altOrientation;
+        mPolicy.setRotationLw(mRotation);
+
+        mWindowsFreezingScreen = true;
+        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
+        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT), 2000);
+        mWaitingForConfig = true;
+        mLayoutNeeded = true;
+        startFreezingDisplayLocked(inTransaction);
+        mInputManager.setDisplayOrientation(0, rotation,
+                mDisplay != null ? mDisplay.getExternalRotation() : Surface.ROTATION_0);
+
+        // We need to update our screen size information to match the new
+        // rotation.  Note that this is redundant with the later call to
+        // sendNewConfiguration() that must be called after this function
+        // returns...  however we need to do the screen size part of that
+        // before then so we have the correct size to use when initializiation
+        // the rotation animation for the new rotation.
+        computeScreenConfigurationLocked(null);
+
+        if (!inTransaction) {
+            if (SHOW_TRANSACTIONS)  Slog.i(TAG,
+                    ">>> OPEN TRANSACTION setRotationUnchecked");
+            Surface.openTransaction();
+        }
+        try {
+            // NOTE: We disable the rotation in the emulator because
+            //       it doesn't support hardware OpenGL emulation yet.
+            if (CUSTOM_SCREEN_ROTATION && mAnimator.mScreenRotationAnimation != null
+                    && mAnimator.mScreenRotationAnimation.hasScreenshot()) {
+                if (mAnimator.mScreenRotationAnimation.setRotation(rotation, mFxSession,
+                        MAX_ANIMATION_DURATION, mTransitionAnimationScale,
+                        mCurDisplayWidth, mCurDisplayHeight)) {
+                    scheduleAnimationLocked();
+                }
+            }
+            Surface.setOrientation(0, rotation);
+        } finally {
+            if (!inTransaction) {
+                Surface.closeTransaction();
+                if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG,
+                        "<<< CLOSE TRANSACTION setRotationUnchecked");
+            }
+        }
+
+        rebuildBlackFrame();
+
+        for (int i=mWindows.size()-1; i>=0; i--) {
+            WindowState w = mWindows.get(i);
+            if (w.mHasSurface) {
+                if (DEBUG_ORIENTATION) Slog.v(TAG, "Set mOrientationChanging of " + w);
+                w.mOrientationChanging = true;
+                mInnerFields.mOrientationChangeComplete = false;
+            }
+        }
+        for (int i=mRotationWatchers.size()-1; i>=0; i--) {
+            try {
+                mRotationWatchers.get(i).onRotationChanged(rotation);
+            } catch (RemoteException e) {
+            }
+        }
+        return true;
+    }
+
+    public int getRotation() {
+        return mRotation;
+    }
+
+    public int watchRotation(IRotationWatcher watcher) {
+        final IBinder watcherBinder = watcher.asBinder();
+        IBinder.DeathRecipient dr = new IBinder.DeathRecipient() {
+            public void binderDied() {
+                synchronized (mWindowMap) {
+                    for (int i=0; i<mRotationWatchers.size(); i++) {
+                        if (watcherBinder == mRotationWatchers.get(i).asBinder()) {
+                            IRotationWatcher removed = mRotationWatchers.remove(i);
+                            if (removed != null) {
+                                removed.asBinder().unlinkToDeath(this, 0);
+                            }
+                            i--;
+                        }
+                    }
+                }
+            }
+        };
+
+        synchronized (mWindowMap) {
+            try {
+                watcher.asBinder().linkToDeath(dr, 0);
+                mRotationWatchers.add(watcher);
+            } catch (RemoteException e) {
+                // Client died, no cleanup needed.
+            }
+
+            return mRotation;
+        }
+    }
+
+    /**
+     * Apps that use the compact menu panel (as controlled by the panelMenuIsCompact
+     * theme attribute) on devices that feature a physical options menu key attempt to position
+     * their menu panel window along the edge of the screen nearest the physical menu key.
+     * This lowers the travel distance between invoking the menu panel and selecting
+     * a menu option.
+     *
+     * This method helps control where that menu is placed. Its current implementation makes
+     * assumptions about the menu key and its relationship to the screen based on whether
+     * the device's natural orientation is portrait (width < height) or landscape.
+     *
+     * The menu key is assumed to be located along the bottom edge of natural-portrait
+     * devices and along the right edge of natural-landscape devices. If these assumptions
+     * do not hold for the target device, this method should be changed to reflect that.
+     *
+     * @return A {@link Gravity} value for placing the options menu window
+     */
+    public int getPreferredOptionsPanelGravity() {
+        synchronized (mWindowMap) {
+            final int rotation = getRotation();
+
+            if (mInitialDisplayWidth < mInitialDisplayHeight) {
+                // On devices with a natural orientation of portrait
+                switch (rotation) {
+                    default:
+                    case Surface.ROTATION_0:
+                        return Gravity.CENTER_HORIZONTAL | Gravity.BOTTOM;
+                    case Surface.ROTATION_90:
+                        return Gravity.RIGHT | Gravity.BOTTOM;
+                    case Surface.ROTATION_180:
+                        return Gravity.CENTER_HORIZONTAL | Gravity.BOTTOM;
+                    case Surface.ROTATION_270:
+                        return Gravity.LEFT | Gravity.BOTTOM;
+                }
+            } else {
+                // On devices with a natural orientation of landscape
+                switch (rotation) {
+                    default:
+                    case Surface.ROTATION_0:
+                        return Gravity.RIGHT | Gravity.BOTTOM;
+                    case Surface.ROTATION_90:
+                        return Gravity.CENTER_HORIZONTAL | Gravity.BOTTOM;
+                    case Surface.ROTATION_180:
+                        return Gravity.LEFT | Gravity.BOTTOM;
+                    case Surface.ROTATION_270:
+                        return Gravity.CENTER_HORIZONTAL | Gravity.BOTTOM;
+                }
+            }
+        }
+    }
+
+    /**
+     * Starts the view server on the specified port.
+     *
+     * @param port The port to listener to.
+     *
+     * @return True if the server was successfully started, false otherwise.
+     *
+     * @see com.android.server.wm.ViewServer
+     * @see com.android.server.wm.ViewServer#VIEW_SERVER_DEFAULT_PORT
+     */
+    public boolean startViewServer(int port) {
+        if (isSystemSecure()) {
+            return false;
+        }
+
+        if (!checkCallingPermission(Manifest.permission.DUMP, "startViewServer")) {
+            return false;
+        }
+
+        if (port < 1024) {
+            return false;
+        }
+
+        if (mViewServer != null) {
+            if (!mViewServer.isRunning()) {
+                try {
+                    return mViewServer.start();
+                } catch (IOException e) {
+                    Slog.w(TAG, "View server did not start");
+                }
+            }
+            return false;
+        }
+
+        try {
+            mViewServer = new ViewServer(this, port);
+            return mViewServer.start();
+        } catch (IOException e) {
+            Slog.w(TAG, "View server did not start");
+        }
+        return false;
+    }
+
+    private boolean isSystemSecure() {
+        return "1".equals(SystemProperties.get(SYSTEM_SECURE, "1")) &&
+                "0".equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0"));
+    }
+
+    /**
+     * Stops the view server if it exists.
+     *
+     * @return True if the server stopped, false if it wasn't started or
+     *         couldn't be stopped.
+     *
+     * @see com.android.server.wm.ViewServer
+     */
+    public boolean stopViewServer() {
+        if (isSystemSecure()) {
+            return false;
+        }
+
+        if (!checkCallingPermission(Manifest.permission.DUMP, "stopViewServer")) {
+            return false;
+        }
+
+        if (mViewServer != null) {
+            return mViewServer.stop();
+        }
+        return false;
+    }
+
+    /**
+     * Indicates whether the view server is running.
+     *
+     * @return True if the server is running, false otherwise.
+     *
+     * @see com.android.server.wm.ViewServer
+     */
+    public boolean isViewServerRunning() {
+        if (isSystemSecure()) {
+            return false;
+        }
+
+        if (!checkCallingPermission(Manifest.permission.DUMP, "isViewServerRunning")) {
+            return false;
+        }
+
+        return mViewServer != null && mViewServer.isRunning();
+    }
+
+    /**
+     * Lists all availble windows in the system. The listing is written in the
+     * specified Socket's output stream with the following syntax:
+     * windowHashCodeInHexadecimal windowName
+     * Each line of the ouput represents a different window.
+     *
+     * @param client The remote client to send the listing to.
+     * @return False if an error occured, true otherwise.
+     */
+    boolean viewServerListWindows(Socket client) {
+        if (isSystemSecure()) {
+            return false;
+        }
+
+        boolean result = true;
+
+        WindowState[] windows;
+        synchronized (mWindowMap) {
+            //noinspection unchecked
+            windows = mWindows.toArray(new WindowState[mWindows.size()]);
+        }
+
+        BufferedWriter out = null;
+
+        // Any uncaught exception will crash the system process
+        try {
+            OutputStream clientStream = client.getOutputStream();
+            out = new BufferedWriter(new OutputStreamWriter(clientStream), 8 * 1024);
+
+            final int count = windows.length;
+            for (int i = 0; i < count; i++) {
+                final WindowState w = windows[i];
+                out.write(Integer.toHexString(System.identityHashCode(w)));
+                out.write(' ');
+                out.append(w.mAttrs.getTitle());
+                out.write('\n');
+            }
+
+            out.write("DONE.\n");
+            out.flush();
+        } catch (Exception e) {
+            result = false;
+        } finally {
+            if (out != null) {
+                try {
+                    out.close();
+                } catch (IOException e) {
+                    result = false;
+                }
+            }
+        }
+
+        return result;
+    }
+
+    /**
+     * Returns the focused window in the following format:
+     * windowHashCodeInHexadecimal windowName
+     *
+     * @param client The remote client to send the listing to.
+     * @return False if an error occurred, true otherwise.
+     */
+    boolean viewServerGetFocusedWindow(Socket client) {
+        if (isSystemSecure()) {
+            return false;
+        }
+
+        boolean result = true;
+
+        WindowState focusedWindow = getFocusedWindow();
+
+        BufferedWriter out = null;
+
+        // Any uncaught exception will crash the system process
+        try {
+            OutputStream clientStream = client.getOutputStream();
+            out = new BufferedWriter(new OutputStreamWriter(clientStream), 8 * 1024);
+
+            if(focusedWindow != null) {
+                out.write(Integer.toHexString(System.identityHashCode(focusedWindow)));
+                out.write(' ');
+                out.append(focusedWindow.mAttrs.getTitle());
+            }
+            out.write('\n');
+            out.flush();
+        } catch (Exception e) {
+            result = false;
+        } finally {
+            if (out != null) {
+                try {
+                    out.close();
+                } catch (IOException e) {
+                    result = false;
+                }
+            }
+        }
+
+        return result;
+    }
+
+    /**
+     * Sends a command to a target window. The result of the command, if any, will be
+     * written in the output stream of the specified socket.
+     *
+     * The parameters must follow this syntax:
+     * windowHashcode extra
+     *
+     * Where XX is the length in characeters of the windowTitle.
+     *
+     * The first parameter is the target window. The window with the specified hashcode
+     * will be the target. If no target can be found, nothing happens. The extra parameters
+     * will be delivered to the target window and as parameters to the command itself.
+     *
+     * @param client The remote client to sent the result, if any, to.
+     * @param command The command to execute.
+     * @param parameters The command parameters.
+     *
+     * @return True if the command was successfully delivered, false otherwise. This does
+     *         not indicate whether the command itself was successful.
+     */
+    boolean viewServerWindowCommand(Socket client, String command, String parameters) {
+        if (isSystemSecure()) {
+            return false;
+        }
+
+        boolean success = true;
+        Parcel data = null;
+        Parcel reply = null;
+
+        BufferedWriter out = null;
+
+        // Any uncaught exception will crash the system process
+        try {
+            // Find the hashcode of the window
+            int index = parameters.indexOf(' ');
+            if (index == -1) {
+                index = parameters.length();
+            }
+            final String code = parameters.substring(0, index);
+            int hashCode = (int) Long.parseLong(code, 16);
+
+            // Extract the command's parameter after the window description
+            if (index < parameters.length()) {
+                parameters = parameters.substring(index + 1);
+            } else {
+                parameters = "";
+            }
+
+            final WindowState window = findWindow(hashCode);
+            if (window == null) {
+                return false;
+            }
+
+            data = Parcel.obtain();
+            data.writeInterfaceToken("android.view.IWindow");
+            data.writeString(command);
+            data.writeString(parameters);
+            data.writeInt(1);
+            ParcelFileDescriptor.fromSocket(client).writeToParcel(data, 0);
+
+            reply = Parcel.obtain();
+
+            final IBinder binder = window.mClient.asBinder();
+            // TODO: GET THE TRANSACTION CODE IN A SAFER MANNER
+            binder.transact(IBinder.FIRST_CALL_TRANSACTION, data, reply, 0);
+
+            reply.readException();
+
+            if (!client.isOutputShutdown()) {
+                out = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));
+                out.write("DONE\n");
+                out.flush();
+            }
+
+        } catch (Exception e) {
+            Slog.w(TAG, "Could not send command " + command + " with parameters " + parameters, e);
+            success = false;
+        } finally {
+            if (data != null) {
+                data.recycle();
+            }
+            if (reply != null) {
+                reply.recycle();
+            }
+            if (out != null) {
+                try {
+                    out.close();
+                } catch (IOException e) {
+
+                }
+            }
+        }
+
+        return success;
+    }
+
+    public void addWindowChangeListener(WindowChangeListener listener) {
+        synchronized(mWindowMap) {
+            mWindowChangeListeners.add(listener);
+        }
+    }
+
+    public void removeWindowChangeListener(WindowChangeListener listener) {
+        synchronized(mWindowMap) {
+            mWindowChangeListeners.remove(listener);
+        }
+    }
+
+    private void notifyWindowsChanged() {
+        WindowChangeListener[] windowChangeListeners;
+        synchronized(mWindowMap) {
+            if(mWindowChangeListeners.isEmpty()) {
+                return;
+            }
+            windowChangeListeners = new WindowChangeListener[mWindowChangeListeners.size()];
+            windowChangeListeners = mWindowChangeListeners.toArray(windowChangeListeners);
+        }
+        int N = windowChangeListeners.length;
+        for(int i = 0; i < N; i++) {
+            windowChangeListeners[i].windowsChanged();
+        }
+    }
+
+    private void notifyFocusChanged() {
+        WindowChangeListener[] windowChangeListeners;
+        synchronized(mWindowMap) {
+            if(mWindowChangeListeners.isEmpty()) {
+                return;
+            }
+            windowChangeListeners = new WindowChangeListener[mWindowChangeListeners.size()];
+            windowChangeListeners = mWindowChangeListeners.toArray(windowChangeListeners);
+        }
+        int N = windowChangeListeners.length;
+        for(int i = 0; i < N; i++) {
+            windowChangeListeners[i].focusChanged();
+        }
+    }
+
+    private WindowState findWindow(int hashCode) {
+        if (hashCode == -1) {
+            return getFocusedWindow();
+        }
+
+        synchronized (mWindowMap) {
+            final ArrayList<WindowState> windows = mWindows;
+            final int count = windows.size();
+
+            for (int i = 0; i < count; i++) {
+                WindowState w = windows.get(i);
+                if (System.identityHashCode(w) == hashCode) {
+                    return w;
+                }
+            }
+        }
+
+        return null;
+    }
+
+    /*
+     * Instruct the Activity Manager to fetch the current configuration and broadcast
+     * that to config-changed listeners if appropriate.
+     */
+    void sendNewConfiguration() {
+        try {
+            mActivityManager.updateConfiguration(null);
+        } catch (RemoteException e) {
+        }
+    }
+
+    public Configuration computeNewConfiguration() {
+        synchronized (mWindowMap) {
+            Configuration config = computeNewConfigurationLocked();
+            if (config == null && mWaitingForConfig) {
+                // Nothing changed but we are waiting for something... stop that!
+                mWaitingForConfig = false;
+                performLayoutAndPlaceSurfacesLocked();
+            }
+            return config;
+        }
+    }
+
+    Configuration computeNewConfigurationLocked() {
+        Configuration config = new Configuration();
+        config.fontScale = 0;
+        if (!computeScreenConfigurationLocked(config)) {
+            return null;
+        }
+        return config;
+    }
+
+    private void adjustDisplaySizeRanges(int rotation, int dw, int dh) {
+        final int width = mPolicy.getConfigDisplayWidth(dw, dh, rotation);
+        if (width < mSmallestDisplayWidth) {
+            mSmallestDisplayWidth = width;
+        }
+        if (width > mLargestDisplayWidth) {
+            mLargestDisplayWidth = width;
+        }
+        final int height = mPolicy.getConfigDisplayHeight(dw, dh, rotation);
+        if (height < mSmallestDisplayHeight) {
+            mSmallestDisplayHeight = height;
+        }
+        if (height > mLargestDisplayHeight) {
+            mLargestDisplayHeight = height;
+        }
+    }
+
+    private int reduceConfigLayout(int curLayout, int rotation, float density,
+            int dw, int dh) {
+        // Get the app screen size at this rotation.
+        int w = mPolicy.getNonDecorDisplayWidth(dw, dh, rotation);
+        int h = mPolicy.getNonDecorDisplayHeight(dw, dh, rotation);
+
+        // Compute the screen layout size class for this rotation.
+        int screenLayoutSize;
+        boolean screenLayoutLong;
+        boolean screenLayoutCompatNeeded;
+        int longSize = w;
+        int shortSize = h;
+        if (longSize < shortSize) {
+            int tmp = longSize;
+            longSize = shortSize;
+            shortSize = tmp;
+        }
+        longSize = (int)(longSize/density);
+        shortSize = (int)(shortSize/density);
+
+        // These semi-magic numbers define our compatibility modes for
+        // applications with different screens.  These are guarantees to
+        // app developers about the space they can expect for a particular
+        // configuration.  DO NOT CHANGE!
+        if (longSize < 470) {
+            // This is shorter than an HVGA normal density screen (which
+            // is 480 pixels on its long side).
+            screenLayoutSize = Configuration.SCREENLAYOUT_SIZE_SMALL;
+            screenLayoutLong = false;
+            screenLayoutCompatNeeded = false;
+        } else {
+            // What size is this screen screen?
+            if (longSize >= 960 && shortSize >= 720) {
+                // 1.5xVGA or larger screens at medium density are the point
+                // at which we consider it to be an extra large screen.
+                screenLayoutSize = Configuration.SCREENLAYOUT_SIZE_XLARGE;
+            } else if (longSize >= 640 && shortSize >= 480) {
+                // VGA or larger screens at medium density are the point
+                // at which we consider it to be a large screen.
+                screenLayoutSize = Configuration.SCREENLAYOUT_SIZE_LARGE;
+            } else {
+                screenLayoutSize = Configuration.SCREENLAYOUT_SIZE_NORMAL;
+            }
+
+            // If this screen is wider than normal HVGA, or taller
+            // than FWVGA, then for old apps we want to run in size
+            // compatibility mode.
+            if (shortSize > 321 || longSize > 570) {
+                screenLayoutCompatNeeded = true;
+            } else {
+                screenLayoutCompatNeeded = false;
+            }
+
+            // Is this a long screen?
+            if (((longSize*3)/5) >= (shortSize-1)) {
+                // Anything wider than WVGA (5:3) is considering to be long.
+                screenLayoutLong = true;
+            } else {
+                screenLayoutLong = false;
+            }
+        }
+
+        // Now reduce the last screenLayout to not be better than what we
+        // have found.
+        if (!screenLayoutLong) {
+            curLayout = (curLayout&~Configuration.SCREENLAYOUT_LONG_MASK)
+                    | Configuration.SCREENLAYOUT_LONG_NO;
+        }
+        if (screenLayoutCompatNeeded) {
+            curLayout |= Configuration.SCREENLAYOUT_COMPAT_NEEDED;
+        }
+        int curSize = curLayout&Configuration.SCREENLAYOUT_SIZE_MASK;
+        if (screenLayoutSize < curSize) {
+            curLayout = (curLayout&~Configuration.SCREENLAYOUT_SIZE_MASK)
+                    | screenLayoutSize;
+        }
+        return curLayout;
+    }
+
+    private void computeSizeRangesAndScreenLayout(boolean rotated, int dw, int dh,
+            float density, Configuration outConfig) {
+        // We need to determine the smallest width that will occur under normal
+        // operation.  To this, start with the base screen size and compute the
+        // width under the different possible rotations.  We need to un-rotate
+        // the current screen dimensions before doing this.
+        int unrotDw, unrotDh;
+        if (rotated) {
+            unrotDw = dh;
+            unrotDh = dw;
+        } else {
+            unrotDw = dw;
+            unrotDh = dh;
+        }
+        mSmallestDisplayWidth = 1<<30;
+        mSmallestDisplayHeight = 1<<30;
+        mLargestDisplayWidth = 0;
+        mLargestDisplayHeight = 0;
+        adjustDisplaySizeRanges(Surface.ROTATION_0, unrotDw, unrotDh);
+        adjustDisplaySizeRanges(Surface.ROTATION_90, unrotDh, unrotDw);
+        adjustDisplaySizeRanges(Surface.ROTATION_180, unrotDw, unrotDh);
+        adjustDisplaySizeRanges(Surface.ROTATION_270, unrotDh, unrotDw);
+        int sl = Configuration.SCREENLAYOUT_SIZE_XLARGE
+                | Configuration.SCREENLAYOUT_LONG_YES;
+        sl = reduceConfigLayout(sl, Surface.ROTATION_0, density, unrotDw, unrotDh);
+        sl = reduceConfigLayout(sl, Surface.ROTATION_90, density, unrotDh, unrotDw);
+        sl = reduceConfigLayout(sl, Surface.ROTATION_180, density, unrotDw, unrotDh);
+        sl = reduceConfigLayout(sl, Surface.ROTATION_270, density, unrotDh, unrotDw);
+        outConfig.smallestScreenWidthDp = (int)(mSmallestDisplayWidth / density);
+        outConfig.screenLayout = sl;
+    }
+
+    private int reduceCompatConfigWidthSize(int curSize, int rotation, DisplayMetrics dm,
+            int dw, int dh) {
+        dm.noncompatWidthPixels = mPolicy.getNonDecorDisplayWidth(dw, dh, rotation);
+        dm.noncompatHeightPixels = mPolicy.getNonDecorDisplayHeight(dw, dh, rotation);
+        float scale = CompatibilityInfo.computeCompatibleScaling(dm, null);
+        int size = (int)(((dm.noncompatWidthPixels / scale) / dm.density) + .5f);
+        if (curSize == 0 || size < curSize) {
+            curSize = size;
+        }
+        return curSize;
+    }
+
+    private int computeCompatSmallestWidth(boolean rotated, DisplayMetrics dm, int dw, int dh) {
+        mTmpDisplayMetrics.setTo(dm);
+        dm = mTmpDisplayMetrics;
+        int unrotDw, unrotDh;
+        if (rotated) {
+            unrotDw = dh;
+            unrotDh = dw;
+        } else {
+            unrotDw = dw;
+            unrotDh = dh;
+        }
+        int sw = reduceCompatConfigWidthSize(0, Surface.ROTATION_0, dm, unrotDw, unrotDh);
+        sw = reduceCompatConfigWidthSize(sw, Surface.ROTATION_90, dm, unrotDh, unrotDw);
+        sw = reduceCompatConfigWidthSize(sw, Surface.ROTATION_180, dm, unrotDw, unrotDh);
+        sw = reduceCompatConfigWidthSize(sw, Surface.ROTATION_270, dm, unrotDh, unrotDw);
+        return sw;
+    }
+
+    boolean computeScreenConfigurationLocked(Configuration config) {
+        if (mDisplay == null) {
+            return false;
+        }
+
+        // Use the effective "visual" dimensions based on current rotation
+        final boolean rotated = (mRotation == Surface.ROTATION_90
+                || mRotation == Surface.ROTATION_270);
+        final int realdw = rotated ? mBaseDisplayHeight : mBaseDisplayWidth;
+        final int realdh = rotated ? mBaseDisplayWidth : mBaseDisplayHeight;
+
+        synchronized(mDisplaySizeLock) {
+            if (mAltOrientation) {
+                mCurDisplayWidth = realdw;
+                mCurDisplayHeight = realdh;
+                if (realdw > realdh) {
+                    // Turn landscape into portrait.
+                    int maxw = (int)(realdh/1.3f);
+                    if (maxw < realdw) {
+                        mCurDisplayWidth = maxw;
+                    }
+                } else {
+                    // Turn portrait into landscape.
+                    int maxh = (int)(realdw/1.3f);
+                    if (maxh < realdh) {
+                        mCurDisplayHeight = maxh;
+                    }
+                }
+            } else {
+                mCurDisplayWidth = realdw;
+                mCurDisplayHeight = realdh;
+            }
+        }
+
+        final int dw = mCurDisplayWidth;
+        final int dh = mCurDisplayHeight;
+
+        if (config != null) {
+            int orientation = Configuration.ORIENTATION_SQUARE;
+            if (dw < dh) {
+                orientation = Configuration.ORIENTATION_PORTRAIT;
+            } else if (dw > dh) {
+                orientation = Configuration.ORIENTATION_LANDSCAPE;
+            }
+            config.orientation = orientation;
+        }
+
+        // Update real display metrics.
+        mDisplay.getMetricsWithSize(mRealDisplayMetrics, mCurDisplayWidth, mCurDisplayHeight);
+
+        // Update application display metrics.
+        final DisplayMetrics dm = mDisplayMetrics;
+        final int appWidth = mPolicy.getNonDecorDisplayWidth(dw, dh, mRotation);
+        final int appHeight = mPolicy.getNonDecorDisplayHeight(dw, dh, mRotation);
+        synchronized(mDisplaySizeLock) {
+            mAppDisplayWidth = appWidth;
+            mAppDisplayHeight = appHeight;
+            mAnimator.setDisplayDimensions(mCurDisplayWidth, mCurDisplayHeight,
+                    mAppDisplayWidth, mAppDisplayHeight);
+        }
+        if (false) {
+            Slog.i(TAG, "Set app display size: " + mAppDisplayWidth
+                    + " x " + mAppDisplayHeight);
+        }
+        mDisplay.getMetricsWithSize(dm, mAppDisplayWidth, mAppDisplayHeight);
+
+        mCompatibleScreenScale = CompatibilityInfo.computeCompatibleScaling(dm,
+                mCompatDisplayMetrics);
+
+        if (config != null) {
+            config.screenWidthDp = (int)(mPolicy.getConfigDisplayWidth(dw, dh, mRotation)
+                    / dm.density);
+            config.screenHeightDp = (int)(mPolicy.getConfigDisplayHeight(dw, dh, mRotation)
+                    / dm.density);
+            computeSizeRangesAndScreenLayout(rotated, dw, dh, dm.density, config);
+
+            config.compatScreenWidthDp = (int)(config.screenWidthDp / mCompatibleScreenScale);
+            config.compatScreenHeightDp = (int)(config.screenHeightDp / mCompatibleScreenScale);
+            config.compatSmallestScreenWidthDp = computeCompatSmallestWidth(rotated, dm, dw, dh);
+
+            // Update the configuration based on available input devices, lid switch,
+            // and platform configuration.
+            config.touchscreen = Configuration.TOUCHSCREEN_NOTOUCH;
+            config.keyboard = Configuration.KEYBOARD_NOKEYS;
+            config.navigation = Configuration.NAVIGATION_NONAV;
+
+            int keyboardPresence = 0;
+            int navigationPresence = 0;
+            final InputDevice[] devices = mInputManager.getInputDevices();
+            final int len = devices.length;
+            for (int i = 0; i < len; i++) {
+                InputDevice device = devices[i];
+                if (!device.isVirtual()) {
+                    final int sources = device.getSources();
+                    final int presenceFlag = device.isExternal() ?
+                            WindowManagerPolicy.PRESENCE_EXTERNAL :
+                                    WindowManagerPolicy.PRESENCE_INTERNAL;
+
+                    if (mIsTouchDevice) {
+                        if ((sources & InputDevice.SOURCE_TOUCHSCREEN) ==
+                                InputDevice.SOURCE_TOUCHSCREEN) {
+                            config.touchscreen = Configuration.TOUCHSCREEN_FINGER;
+                        }
+                    } else {
+                        config.touchscreen = Configuration.TOUCHSCREEN_NOTOUCH;
+                    }
+
+                    if ((sources & InputDevice.SOURCE_TRACKBALL) == InputDevice.SOURCE_TRACKBALL) {
+                        config.navigation = Configuration.NAVIGATION_TRACKBALL;
+                        navigationPresence |= presenceFlag;
+                    } else if ((sources & InputDevice.SOURCE_DPAD) == InputDevice.SOURCE_DPAD
+                            && config.navigation == Configuration.NAVIGATION_NONAV) {
+                        config.navigation = Configuration.NAVIGATION_DPAD;
+                        navigationPresence |= presenceFlag;
+                    }
+
+                    if (device.getKeyboardType() == InputDevice.KEYBOARD_TYPE_ALPHABETIC) {
+                        config.keyboard = Configuration.KEYBOARD_QWERTY;
+                        keyboardPresence |= presenceFlag;
+                    }
+                }
+            }
+
+            // Determine whether a hard keyboard is available and enabled.
+            boolean hardKeyboardAvailable = config.keyboard != Configuration.KEYBOARD_NOKEYS;
+            if (hardKeyboardAvailable != mHardKeyboardAvailable) {
+                mHardKeyboardAvailable = hardKeyboardAvailable;
+                mHardKeyboardEnabled = hardKeyboardAvailable;
+                mH.removeMessages(H.REPORT_HARD_KEYBOARD_STATUS_CHANGE);
+                mH.sendEmptyMessage(H.REPORT_HARD_KEYBOARD_STATUS_CHANGE);
+            }
+            if (!mHardKeyboardEnabled) {
+                config.keyboard = Configuration.KEYBOARD_NOKEYS;
+            }
+
+            // Let the policy update hidden states.
+            config.keyboardHidden = Configuration.KEYBOARDHIDDEN_NO;
+            config.hardKeyboardHidden = Configuration.HARDKEYBOARDHIDDEN_NO;
+            config.navigationHidden = Configuration.NAVIGATIONHIDDEN_NO;
+            mPolicy.adjustConfigurationLw(config, keyboardPresence, navigationPresence);
+        }
+
+        return true;
+    }
+
+    public boolean isHardKeyboardAvailable() {
+        synchronized (mWindowMap) {
+            return mHardKeyboardAvailable;
+        }
+    }
+
+    public boolean isHardKeyboardEnabled() {
+        synchronized (mWindowMap) {
+            return mHardKeyboardEnabled;
+        }
+    }
+
+    public void setHardKeyboardEnabled(boolean enabled) {
+        synchronized (mWindowMap) {
+            if (mHardKeyboardEnabled != enabled) {
+                mHardKeyboardEnabled = enabled;
+                mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
+            }
+        }
+    }
+
+    public void setOnHardKeyboardStatusChangeListener(
+            OnHardKeyboardStatusChangeListener listener) {
+        synchronized (mWindowMap) {
+            mHardKeyboardStatusChangeListener = listener;
+        }
+    }
+
+    void notifyHardKeyboardStatusChange() {
+        final boolean available, enabled;
+        final OnHardKeyboardStatusChangeListener listener;
+        synchronized (mWindowMap) {
+            listener = mHardKeyboardStatusChangeListener;
+            available = mHardKeyboardAvailable;
+            enabled = mHardKeyboardEnabled;
+        }
+        if (listener != null) {
+            listener.onHardKeyboardStatusChange(available, enabled);
+        }
+    }
+
+    // -------------------------------------------------------------
+    // Drag and drop
+    // -------------------------------------------------------------
+
+    IBinder prepareDragSurface(IWindow window, SurfaceSession session,
+            int flags, int width, int height, Surface outSurface) {
+        if (DEBUG_DRAG) {
+            Slog.d(TAG, "prepare drag surface: w=" + width + " h=" + height
+                    + " flags=" + Integer.toHexString(flags) + " win=" + window
+                    + " asbinder=" + window.asBinder());
+        }
+
+        final int callerPid = Binder.getCallingPid();
+        final long origId = Binder.clearCallingIdentity();
+        IBinder token = null;
+
+        try {
+            synchronized (mWindowMap) {
+                try {
+                    if (mDragState == null) {
+                        Surface surface = new Surface(session, callerPid, "drag surface", 0,
+                                width, height, PixelFormat.TRANSLUCENT, Surface.HIDDEN);
+                        if (SHOW_TRANSACTIONS) Slog.i(TAG, "  DRAG "
+                                + surface + ": CREATE");
+                        outSurface.copyFrom(surface);
+                        final IBinder winBinder = window.asBinder();
+                        token = new Binder();
+                        mDragState = new DragState(this, token, surface, /*flags*/ 0, winBinder);
+                        token = mDragState.mToken = new Binder();
+
+                        // 5 second timeout for this window to actually begin the drag
+                        mH.removeMessages(H.DRAG_START_TIMEOUT, winBinder);
+                        Message msg = mH.obtainMessage(H.DRAG_START_TIMEOUT, winBinder);
+                        mH.sendMessageDelayed(msg, 5000);
+                    } else {
+                        Slog.w(TAG, "Drag already in progress");
+                    }
+                } catch (Surface.OutOfResourcesException e) {
+                    Slog.e(TAG, "Can't allocate drag surface w=" + width + " h=" + height, e);
+                    if (mDragState != null) {
+                        mDragState.reset();
+                        mDragState = null;
+                    }
+                }
+            }
+        } finally {
+            Binder.restoreCallingIdentity(origId);
+        }
+
+        return token;
+    }
+
+    // -------------------------------------------------------------
+    // Input Events and Focus Management
+    // -------------------------------------------------------------
+    
+    final InputMonitor mInputMonitor = new InputMonitor(this);
+    private boolean mEventDispatchingEnabled;
+
+    public void pauseKeyDispatching(IBinder _token) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "pauseKeyDispatching()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        synchronized (mWindowMap) {
+            WindowToken token = mTokenMap.get(_token);
+            if (token != null) {
+                mInputMonitor.pauseDispatchingLw(token);
+            }
+        }
+    }
+
+    public void resumeKeyDispatching(IBinder _token) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "resumeKeyDispatching()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        synchronized (mWindowMap) {
+            WindowToken token = mTokenMap.get(_token);
+            if (token != null) {
+                mInputMonitor.resumeDispatchingLw(token);
+            }
+        }
+    }
+
+    public void setEventDispatching(boolean enabled) {
+        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
+                "setEventDispatching()")) {
+            throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
+        }
+
+        synchronized (mWindowMap) {
+            mEventDispatchingEnabled = enabled;
+            if (mDisplayEnabled) {
+                mInputMonitor.setEventDispatchingLw(enabled);
+            }
+            sendScreenStatusToClientsLocked();
+        }
+    }
+
+    // TODO: Put this on the IWindowManagerService and guard with a permission.
+    public IBinder getFocusedWindowClientToken() {
+        synchronized (mWindowMap) {
+            WindowState windowState = getFocusedWindowLocked();
+            if (windowState != null) {
+                return windowState.mClient.asBinder();
+            }
+            return null;
+        }
+    }
+
+    // TODO: This is a workaround - remove when 6623031 is fixed.
+    public boolean getWindowFrame(IBinder token, Rect outBounds) {
+        synchronized (mWindowMap) {
+            WindowState windowState = mWindowMap.get(token);
+            if (windowState != null) {
+                outBounds.set(windowState.getFrameLw());
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private WindowState getFocusedWindow() {
+        synchronized (mWindowMap) {
+            return getFocusedWindowLocked();
+        }
+    }
+
+    private WindowState getFocusedWindowLocked() {
+        return mCurrentFocus;
+    }
+
+    public boolean detectSafeMode() {
+        if (!mInputMonitor.waitForInputDevicesReady(
+                INPUT_DEVICES_READY_FOR_SAFE_MODE_DETECTION_TIMEOUT_MILLIS)) {
+            Slog.w(TAG, "Devices still not ready after waiting "
+                   + INPUT_DEVICES_READY_FOR_SAFE_MODE_DETECTION_TIMEOUT_MILLIS
+                   + " milliseconds before attempting to detect safe mode.");
+        }
+
+        int menuState = mInputManager.getKeyCodeState(-1, InputDevice.SOURCE_ANY,
+                KeyEvent.KEYCODE_MENU);
+        int sState = mInputManager.getKeyCodeState(-1, InputDevice.SOURCE_ANY, KeyEvent.KEYCODE_S);
+        int dpadState = mInputManager.getKeyCodeState(-1, InputDevice.SOURCE_DPAD,
+                KeyEvent.KEYCODE_DPAD_CENTER);
+        int trackballState = mInputManager.getScanCodeState(-1, InputDevice.SOURCE_TRACKBALL,
+                InputManagerService.BTN_MOUSE);
+        int volumeDownState = mInputManager.getKeyCodeState(-1, InputDevice.SOURCE_ANY,
+                KeyEvent.KEYCODE_VOLUME_DOWN);
+        mSafeMode = menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0
+                || volumeDownState > 0;
+        try {
+            if (SystemProperties.getInt(ShutdownThread.REBOOT_SAFEMODE_PROPERTY, 0) != 0) {
+                mSafeMode = true;
+                SystemProperties.set(ShutdownThread.REBOOT_SAFEMODE_PROPERTY, "");
+            }
+        } catch (IllegalArgumentException e) {
+        }
+        if (mSafeMode) {
+            Log.i(TAG, "SAFE MODE ENABLED (menu=" + menuState + " s=" + sState
+                    + " dpad=" + dpadState + " trackball=" + trackballState + ")");
+        } else {
+            Log.i(TAG, "SAFE MODE not enabled");
+        }
+        mPolicy.setSafeMode(mSafeMode);
+        return mSafeMode;
+    }
+
+    public void displayReady() {
+        synchronized(mWindowMap) {
+            if (mDisplay != null) {
+                throw new IllegalStateException("Display already initialized");
+            }
+            WindowManager wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
+            mDisplay = wm.getDefaultDisplay();
+            mIsTouchDevice = mContext.getPackageManager().hasSystemFeature(
+                    PackageManager.FEATURE_TOUCHSCREEN);
+            synchronized(mDisplaySizeLock) {
+                mInitialDisplayWidth = mDisplay.getRawWidth();
+                mInitialDisplayHeight = mDisplay.getRawHeight();
+                int rot = mDisplay.getRotation();
+                if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
+                    // If the screen is currently rotated, we need to swap the
+                    // initial width and height to get the true natural values.
+                    int tmp = mInitialDisplayWidth;
+                    mInitialDisplayWidth = mInitialDisplayHeight;
+                    mInitialDisplayHeight = tmp;
+                }
+                mBaseDisplayWidth = mCurDisplayWidth = mAppDisplayWidth = mInitialDisplayWidth;
+                mBaseDisplayHeight = mCurDisplayHeight = mAppDisplayHeight = mInitialDisplayHeight;
+                mAnimator.setDisplayDimensions(mCurDisplayWidth, mCurDisplayHeight,
+                        mAppDisplayWidth, mAppDisplayHeight);
+            }
+            mInputManager.setDisplaySize(Display.DEFAULT_DISPLAY,
+                    mDisplay.getRawWidth(), mDisplay.getRawHeight(),
+                    mDisplay.getRawExternalWidth(), mDisplay.getRawExternalHeight());
+            mInputManager.setDisplayOrientation(Display.DEFAULT_DISPLAY,
+                    mDisplay.getRotation(), mDisplay.getExternalRotation());
+            mPolicy.setInitialDisplaySize(mDisplay, mInitialDisplayWidth, mInitialDisplayHeight);
+        }
+
+        try {
+            mActivityManager.updateConfiguration(null);
+        } catch (RemoteException e) {
+        }
+        
+        synchronized (mWindowMap) {
+            readForcedDisplaySizeLocked();
+        }
+    }
+
+    public void systemReady() {
+        mPolicy.systemReady();
+    }
+
+    private void sendScreenStatusToClientsLocked() {
+        final ArrayList<WindowState> windows = mWindows;
+        final int count = windows.size();
+        boolean on = mPowerManager.isScreenOn();
+        for (int i = count - 1; i >= 0; i--) {
+            WindowState win = mWindows.get(i);
+            try {
+                win.mClient.dispatchScreenState(on);
+            } catch (RemoteException e) {
+                // Ignored
+            }
+        }
+    }
+
+    // -------------------------------------------------------------
+    // Async Handler
+    // -------------------------------------------------------------
+
+    final class H extends Handler {
+        public static final int REPORT_FOCUS_CHANGE = 2;
+        public static final int REPORT_LOSING_FOCUS = 3;
+        public static final int DO_TRAVERSAL = 4;
+        public static final int ADD_STARTING = 5;
+        public static final int REMOVE_STARTING = 6;
+        public static final int FINISHED_STARTING = 7;
+        public static final int REPORT_APPLICATION_TOKEN_WINDOWS = 8;
+        public static final int REPORT_APPLICATION_TOKEN_DRAWN = 9;
+        public static final int WINDOW_FREEZE_TIMEOUT = 11;
+        public static final int HOLD_SCREEN_CHANGED = 12;
+        public static final int APP_TRANSITION_TIMEOUT = 13;
+        public static final int PERSIST_ANIMATION_SCALE = 14;
+        public static final int FORCE_GC = 15;
+        public static final int ENABLE_SCREEN = 16;
+        public static final int APP_FREEZE_TIMEOUT = 17;
+        public static final int SEND_NEW_CONFIGURATION = 18;
+        public static final int REPORT_WINDOWS_CHANGE = 19;
+        public static final int DRAG_START_TIMEOUT = 20;
+        public static final int DRAG_END_TIMEOUT = 21;
+        public static final int REPORT_HARD_KEYBOARD_STATUS_CHANGE = 22;
+        public static final int BOOT_TIMEOUT = 23;
+        public static final int WAITING_FOR_DRAWN_TIMEOUT = 24;
+        public static final int BULK_UPDATE_PARAMETERS = 25;
+        public static final int SHOW_STRICT_MODE_VIOLATION = 26;
+        public static final int DO_ANIMATION_CALLBACK = 27;
+
+        public static final int ANIMATOR_WHAT_OFFSET = 100000;
+        public static final int SET_TRANSPARENT_REGION = ANIMATOR_WHAT_OFFSET + 1;
+        public static final int SET_WALLPAPER_OFFSET = ANIMATOR_WHAT_OFFSET + 2;
+        public static final int SET_DIM_PARAMETERS = ANIMATOR_WHAT_OFFSET + 3;
+        public static final int CLEAR_PENDING_ACTIONS = ANIMATOR_WHAT_OFFSET + 4;
+
+        private Session mLastReportedHold;
+
+        public H() {
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            if (DEBUG_WINDOW_TRACE) {
+                Slog.v(TAG, "handleMessage: entry what=" + msg.what);
+            }
+            switch (msg.what) {
+                case REPORT_FOCUS_CHANGE: {
+                    WindowState lastFocus;
+                    WindowState newFocus;
+
+                    synchronized(mWindowMap) {
+                        lastFocus = mLastFocus;
+                        newFocus = mCurrentFocus;
+                        if (lastFocus == newFocus) {
+                            // Focus is not changing, so nothing to do.
+                            return;
+                        }
+                        mLastFocus = newFocus;
+                        //Slog.i(TAG, "Focus moving from " + lastFocus
+                        //        + " to " + newFocus);
+                        if (newFocus != null && lastFocus != null
+                                && !newFocus.isDisplayedLw()) {
+                            //Slog.i(TAG, "Delaying loss of focus...");
+                            mLosingFocus.add(lastFocus);
+                            lastFocus = null;
+                        }
+                    }
+
+                    if (lastFocus != newFocus) {
+                        //System.out.println("Changing focus from " + lastFocus
+                        //                   + " to " + newFocus);
+                        if (newFocus != null) {
+                            try {
+                                //Slog.i(TAG, "Gaining focus: " + newFocus);
+                                newFocus.mClient.windowFocusChanged(true, mInTouchMode);
+                            } catch (RemoteException e) {
+                                // Ignore if process has died.
+                            }
+                            notifyFocusChanged();
+                        }
+
+                        if (lastFocus != null) {
+                            try {
+                                //Slog.i(TAG, "Losing focus: " + lastFocus);
+                                lastFocus.mClient.windowFocusChanged(false, mInTouchMode);
+                            } catch (RemoteException e) {
+                                // Ignore if process has died.
+                            }
+                        }
+                    }
+                } break;
+
+                case REPORT_LOSING_FOCUS: {
+                    ArrayList<WindowState> losers;
+
+                    synchronized(mWindowMap) {
+                        losers = mLosingFocus;
+                        mLosingFocus = new ArrayList<WindowState>();
+                    }
+
+                    final int N = losers.size();
+                    for (int i=0; i<N; i++) {
+                        try {
+                            //Slog.i(TAG, "Losing delayed focus: " + losers.get(i));
+                            losers.get(i).mClient.windowFocusChanged(false, mInTouchMode);
+                        } catch (RemoteException e) {
+                             // Ignore if process has died.
+                        }
+                    }
+                } break;
+
+                case DO_TRAVERSAL: {
+                    synchronized(mWindowMap) {
+                        mTraversalScheduled = false;
+                        performLayoutAndPlaceSurfacesLocked();
+                    }
+                } break;
+
+                case ADD_STARTING: {
+                    final AppWindowToken wtoken = (AppWindowToken)msg.obj;
+                    final StartingData sd = wtoken.startingData;
+
+                    if (sd == null) {
+                        // Animation has been canceled... do nothing.
+                        return;
+                    }
+
+                    if (DEBUG_STARTING_WINDOW) Slog.v(TAG, "Add starting "
+                            + wtoken + ": pkg=" + sd.pkg);
+
+                    View view = null;
+                    try {
+                        view = mPolicy.addStartingWindow(
+                            wtoken.token, sd.pkg, sd.theme, sd.compatInfo,
+                            sd.nonLocalizedLabel, sd.labelRes, sd.icon, sd.windowFlags);
+                    } catch (Exception e) {
+                        Slog.w(TAG, "Exception when adding starting window", e);
+                    }
+
+                    if (view != null) {
+                        boolean abort = false;
+
+                        synchronized(mWindowMap) {
+                            if (wtoken.removed || wtoken.startingData == null) {
+                                // If the window was successfully added, then
+                                // we need to remove it.
+                                if (wtoken.startingWindow != null) {
+                                    if (DEBUG_STARTING_WINDOW) Slog.v(TAG,
+                                            "Aborted starting " + wtoken
+                                            + ": removed=" + wtoken.removed
+                                            + " startingData=" + wtoken.startingData);
+                                    wtoken.startingWindow = null;
+                                    wtoken.startingData = null;
+                                    abort = true;
+                                }
+                            } else {
+                                wtoken.startingView = view;
+                            }
+                            if (DEBUG_STARTING_WINDOW && !abort) Slog.v(TAG,
+                                    "Added starting " + wtoken
+                                    + ": startingWindow="
+                                    + wtoken.startingWindow + " startingView="
+                                    + wtoken.startingView);
+                        }
+
+                        if (abort) {
+                            try {
+                                mPolicy.removeStartingWindow(wtoken.token, view);
+                            } catch (Exception e) {
+                                Slog.w(TAG, "Exception when removing starting window", e);
+                            }
+                        }
+                    }
+                } break;
+
+                case REMOVE_STARTING: {
+                    final AppWindowToken wtoken = (AppWindowToken)msg.obj;
+                    IBinder token = null;
+                    View view = null;
+                    synchronized (mWindowMap) {
+                        if (DEBUG_STARTING_WINDOW) Slog.v(TAG, "Remove starting "
+                                + wtoken + ": startingWindow="
+                                + wtoken.startingWindow + " startingView="
+                                + wtoken.startingView);
+                        if (wtoken.startingWindow != null) {
+                            view = wtoken.startingView;
+                            token = wtoken.token;
+                            wtoken.startingData = null;
+                            wtoken.startingView = null;
+                            wtoken.startingWindow = null;
+                            wtoken.startingDisplayed = false;
+                        }
+                    }
+                    if (view != null) {
+                        try {
+                            mPolicy.removeStartingWindow(token, view);
+                        } catch (Exception e) {
+                            Slog.w(TAG, "Exception when removing starting window", e);
+                        }
+                    }
+                } break;
+
+                case FINISHED_STARTING: {
+                    IBinder token = null;
+                    View view = null;
+                    while (true) {
+                        synchronized (mWindowMap) {
+                            final int N = mFinishedStarting.size();
+                            if (N <= 0) {
+                                break;
+                            }
+                            AppWindowToken wtoken = mFinishedStarting.remove(N-1);
+
+                            if (DEBUG_STARTING_WINDOW) Slog.v(TAG,
+                                    "Finished starting " + wtoken
+                                    + ": startingWindow=" + wtoken.startingWindow
+                                    + " startingView=" + wtoken.startingView);
+
+                            if (wtoken.startingWindow == null) {
+                                continue;
+                            }
+
+                            view = wtoken.startingView;
+                            token = wtoken.token;
+                            wtoken.startingData = null;
+                            wtoken.startingView = null;
+                            wtoken.startingWindow = null;
+                            wtoken.startingDisplayed = false;
+                        }
+
+                        try {
+                            mPolicy.removeStartingWindow(token, view);
+                        } catch (Exception e) {
+                            Slog.w(TAG, "Exception when removing starting window", e);
+                        }
+                    }
+                } break;
+
+                case REPORT_APPLICATION_TOKEN_DRAWN: {
+                    final AppWindowToken wtoken = (AppWindowToken)msg.obj;
+
+                    try {
+                        if (DEBUG_VISIBILITY) Slog.v(
+                                TAG, "Reporting drawn in " + wtoken);
+                        wtoken.appToken.windowsDrawn();
+                    } catch (RemoteException ex) {
+                    }
+                } break;
+
+                case REPORT_APPLICATION_TOKEN_WINDOWS: {
+                    final AppWindowToken wtoken = (AppWindowToken)msg.obj;
+
+                    boolean nowVisible = msg.arg1 != 0;
+                    boolean nowGone = msg.arg2 != 0;
+
+                    try {
+                        if (DEBUG_VISIBILITY) Slog.v(
+                                TAG, "Reporting visible in " + wtoken
+                                + " visible=" + nowVisible
+                                + " gone=" + nowGone);
+                        if (nowVisible) {
+                            wtoken.appToken.windowsVisible();
+                        } else {
+                            wtoken.appToken.windowsGone();
+                        }
+                    } catch (RemoteException ex) {
+                    }
+                } break;
+
+                case WINDOW_FREEZE_TIMEOUT: {
+                    synchronized (mWindowMap) {
+                        Slog.w(TAG, "Window freeze timeout expired.");
+                        int i = mWindows.size();
+                        while (i > 0) {
+                            i--;
+                            WindowState w = mWindows.get(i);
+                            if (w.mOrientationChanging) {
+                                w.mOrientationChanging = false;
+                                Slog.w(TAG, "Force clearing orientation change: " + w);
+                            }
+                        }
+                        performLayoutAndPlaceSurfacesLocked();
+                    }
+                    break;
+                }
+
+                case HOLD_SCREEN_CHANGED: {
+                    Session oldHold;
+                    Session newHold;
+                    synchronized (mWindowMap) {
+                        oldHold = mLastReportedHold;
+                        newHold = (Session)msg.obj;
+                        mLastReportedHold = newHold;
+                    }
+
+                    if (oldHold != newHold) {
+                        try {
+                            if (oldHold != null) {
+                                mBatteryStats.noteStopWakelock(oldHold.mUid, -1,
+                                        "window",
+                                        BatteryStats.WAKE_TYPE_WINDOW);
+                            }
+                            if (newHold != null) {
+                                mBatteryStats.noteStartWakelock(newHold.mUid, -1,
+                                        "window",
+                                        BatteryStats.WAKE_TYPE_WINDOW);
+                            }
+                        } catch (RemoteException e) {
+                        }
+                    }
+                    break;
+                }
+
+                case APP_TRANSITION_TIMEOUT: {
+                    synchronized (mWindowMap) {
+                        if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
+                            if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,
+                                    "*** APP TRANSITION TIMEOUT");
+                            mAppTransitionReady = true;
+                            mAppTransitionTimeout = true;
+                            mAnimatingAppTokens.clear();
+                            mAnimatingAppTokens.addAll(mAppTokens);
+                            performLayoutAndPlaceSurfacesLocked();
+                        }
+                    }
+                    break;
+                }
+
+                case PERSIST_ANIMATION_SCALE: {
+                    Settings.System.putFloat(mContext.getContentResolver(),
+                            Settings.System.WINDOW_ANIMATION_SCALE, mWindowAnimationScale);
+                    Settings.System.putFloat(mContext.getContentResolver(),
+                            Settings.System.TRANSITION_ANIMATION_SCALE, mTransitionAnimationScale);
+                    Settings.System.putFloat(mContext.getContentResolver(),
+                            Settings.System.ANIMATOR_DURATION_SCALE, mAnimatorDurationScale);
+                    break;
+                }
+
+                case FORCE_GC: {
+                    synchronized(mWindowMap) {
+                        if (mAnimationScheduled) {
+                            // If we are animating, don't do the gc now but
+                            // delay a bit so we don't interrupt the animation.
+                            mH.sendMessageDelayed(mH.obtainMessage(H.FORCE_GC),
+                                    2000);
+                            return;
+                        }
+                        // If we are currently rotating the display, it will
+                        // schedule a new message when done.
+                        if (mDisplayFrozen) {
+                            return;
+                        }
+                    }
+                    Runtime.getRuntime().gc();
+                    break;
+                }
+
+                case ENABLE_SCREEN: {
+                    performEnableScreen();
+                    break;
+                }
+
+                case APP_FREEZE_TIMEOUT: {
+                    synchronized (mWindowMap) {
+                        synchronized (mAnimator) {
+                            Slog.w(TAG, "App freeze timeout expired.");
+                            int i = mAppTokens.size();
+                            while (i > 0) {
+                                i--;
+                                AppWindowToken tok = mAppTokens.get(i);
+                                if (tok.mAppAnimator.freezingScreen) {
+                                    Slog.w(TAG, "Force clearing freeze: " + tok);
+                                    unsetAppFreezingScreenLocked(tok, true, true);
+                                }
+                            }
+                        }
+                    }
+                    break;
+                }
+
+                case SEND_NEW_CONFIGURATION: {
+                    removeMessages(SEND_NEW_CONFIGURATION);
+                    sendNewConfiguration();
+                    break;
+                }
+
+                case REPORT_WINDOWS_CHANGE: {
+                    if (mWindowsChanged) {
+                        synchronized (mWindowMap) {
+                            mWindowsChanged = false;
+                        }
+                        notifyWindowsChanged();
+                    }
+                    break;
+                }
+
+                case DRAG_START_TIMEOUT: {
+                    IBinder win = (IBinder)msg.obj;
+                    if (DEBUG_DRAG) {
+                        Slog.w(TAG, "Timeout starting drag by win " + win);
+                    }
+                    synchronized (mWindowMap) {
+                        // !!! TODO: ANR the app that has failed to start the drag in time
+                        if (mDragState != null) {
+                            mDragState.unregister();
+                            mInputMonitor.updateInputWindowsLw(true /*force*/);
+                            mDragState.reset();
+                            mDragState = null;
+                        }
+                    }
+                    break;
+                }
+
+                case DRAG_END_TIMEOUT: {
+                    IBinder win = (IBinder)msg.obj;
+                    if (DEBUG_DRAG) {
+                        Slog.w(TAG, "Timeout ending drag to win " + win);
+                    }
+                    synchronized (mWindowMap) {
+                        // !!! TODO: ANR the drag-receiving app
+                        if (mDragState != null) {
+                            mDragState.mDragResult = false;
+                            mDragState.endDragLw();
+                        }
+                    }
+                    break;
+                }
+
+                case REPORT_HARD_KEYBOARD_STATUS_CHANGE: {
+                    notifyHardKeyboardStatusChange();
+                    break;
+                }
+
+                case BOOT_TIMEOUT: {
+                    performBootTimeout();
+                    break;
+                }
+
+                case WAITING_FOR_DRAWN_TIMEOUT: {
+                    Pair<WindowState, IRemoteCallback> pair;
+                    synchronized (mWindowMap) {
+                        pair = (Pair<WindowState, IRemoteCallback>)msg.obj;
+                        Slog.w(TAG, "Timeout waiting for drawn: " + pair.first);
+                        if (!mWaitingForDrawn.remove(pair)) {
+                            return;
+                        }
+                    }
+                    try {
+                        pair.second.sendResult(null);
+                    } catch (RemoteException e) {
+                    }
+                    break;
+                }
+
+                case BULK_UPDATE_PARAMETERS: {
+                    // Used to send multiple changes from the animation side to the layout side.
+                    synchronized (mWindowMap) {
+                        boolean doRequest = false;
+                        // TODO(cmautner): As the number of bits grows, use masks of bit groups to
+                        //  eliminate unnecessary tests.
+                        if ((msg.arg1 & LayoutFields.SET_UPDATE_ROTATION) != 0) {
+                            mInnerFields.mUpdateRotation = true;
+                            doRequest = true;
+                        }
+                        if ((msg.arg1 & LayoutFields.SET_WALLPAPER_MAY_CHANGE) != 0) {
+                            mInnerFields.mWallpaperMayChange = true;
+                            doRequest = true;
+                        }
+                        if ((msg.arg1 & LayoutFields.SET_FORCE_HIDING_CHANGED) != 0) {
+                            mInnerFields.mWallpaperForceHidingChanged = true;
+                            doRequest = true;
+                        }
+                        if ((msg.arg1 & LayoutFields.CLEAR_ORIENTATION_CHANGE_COMPLETE) != 0) {
+                            mInnerFields.mOrientationChangeComplete = false;
+                        } else {
+                            mInnerFields.mOrientationChangeComplete = true;
+                            if (mWindowsFreezingScreen) {
+                                doRequest = true;
+                            }
+                        }
+                        if ((msg.arg1 & LayoutFields.SET_TURN_ON_SCREEN) != 0) {
+                            mTurnOnScreen = true;
+                        }
+
+                        mPendingLayoutChanges |= msg.arg2;
+                        if (mPendingLayoutChanges != 0) {
+                            doRequest = true;
+                        }
+
+                        if (doRequest) {
+                            mH.sendEmptyMessage(CLEAR_PENDING_ACTIONS);
+                            performLayoutAndPlaceSurfacesLocked();
+                        }
+                    }
+                    break;
+                }
+
+                case SHOW_STRICT_MODE_VIOLATION: {
+                    showStrictModeViolation(msg.arg1);
+                    break;
+                }
+
+                // Animation messages. Move to Window{State}Animator
+                case SET_TRANSPARENT_REGION: {
+                    Pair<WindowStateAnimator, Region> pair =
+                                (Pair<WindowStateAnimator, Region>) msg.obj;
+                    final WindowStateAnimator winAnimator = pair.first;
+                    winAnimator.setTransparentRegionHint(pair.second);
+                    break;
+                }
+
+                case SET_WALLPAPER_OFFSET: {
+                    final WindowStateAnimator winAnimator = (WindowStateAnimator) msg.obj;
+                    winAnimator.setWallpaperOffset(msg.arg1, msg.arg2);
+
+                    scheduleAnimationLocked();
+                    break;
+                }
+
+                case SET_DIM_PARAMETERS: {
+                    mAnimator.mDimParams = (DimAnimator.Parameters) msg.obj;
+
+                    scheduleAnimationLocked();
+                    break;
+                }
+
+                case CLEAR_PENDING_ACTIONS: {
+                    mAnimator.clearPendingActions();
+                    break;
+                }
+
+                case DO_ANIMATION_CALLBACK: {
+                    try {
+                        ((IRemoteCallback)msg.obj).sendResult(null);
+                    } catch (RemoteException e) {
+                    }
+                    break;
+                }
+            }
+            if (DEBUG_WINDOW_TRACE) {
+                Slog.v(TAG, "handleMessage: exit");
+            }
+        }
+    }
+
+    // -------------------------------------------------------------
+    // IWindowManager API
+    // -------------------------------------------------------------
+
+    @Override
+    public IWindowSession openSession(IInputMethodClient client,
+            IInputContext inputContext) {
+        if (client == null) throw new IllegalArgumentException("null client");
+        if (inputContext == null) throw new IllegalArgumentException("null inputContext");
+        Session session = new Session(this, client, inputContext);
+        return session;
+    }
+
+    @Override
+    public boolean inputMethodClientHasFocus(IInputMethodClient client) {
+        synchronized (mWindowMap) {
+            // The focus for the client is the window immediately below
+            // where we would place the input method window.
+            int idx = findDesiredInputMethodWindowIndexLocked(false);
+            WindowState imFocus;
+            if (idx > 0) {
+                imFocus = mWindows.get(idx-1);
+                if (DEBUG_INPUT_METHOD) {
+                    Slog.i(TAG, "Desired input method target: " + imFocus);
+                    Slog.i(TAG, "Current focus: " + this.mCurrentFocus);
+                    Slog.i(TAG, "Last focus: " + this.mLastFocus);
+                }
+                if (imFocus != null) {
+                    // This may be a starting window, in which case we still want
+                    // to count it as okay.
+                    if (imFocus.mAttrs.type == LayoutParams.TYPE_APPLICATION_STARTING
+                            && imFocus.mAppToken != null) {
+                        // The client has definitely started, so it really should
+                        // have a window in this app token.  Let's look for it.
+                        for (int i=0; i<imFocus.mAppToken.windows.size(); i++) {
+                            WindowState w = imFocus.mAppToken.windows.get(i);
+                            if (w != imFocus) {
+                                Log.i(TAG, "Switching to real app window: " + w);
+                                imFocus = w;
+                                break;
+                            }
+                        }
+                    }
+                    if (DEBUG_INPUT_METHOD) {
+                        Slog.i(TAG, "IM target client: " + imFocus.mSession.mClient);
+                        if (imFocus.mSession.mClient != null) {
+                            Slog.i(TAG, "IM target client binder: "
+                                    + imFocus.mSession.mClient.asBinder());
+                            Slog.i(TAG, "Requesting client binder: " + client.asBinder());
+                        }
+                    }
+                    if (imFocus.mSession.mClient != null &&
+                            imFocus.mSession.mClient.asBinder() == client.asBinder()) {
+                        return true;
+                    }
+                    
+                    // Okay, how about this...  what is the current focus?
+                    // It seems in some cases we may not have moved the IM
+                    // target window, such as when it was in a pop-up window,
+                    // so let's also look at the current focus.  (An example:
+                    // go to Gmail, start searching so the keyboard goes up,
+                    // press home.  Sometimes the IME won't go down.)
+                    // Would be nice to fix this more correctly, but it's
+                    // way at the end of a release, and this should be good enough.
+                    if (mCurrentFocus != null && mCurrentFocus.mSession.mClient != null &&
+                            mCurrentFocus.mSession.mClient.asBinder() == client.asBinder()) {
+                        return true;
+                    }
+                }
+            }
+        }
+        return false;
+    }
+
+    public void getDisplaySize(Point size) {
+        synchronized(mDisplaySizeLock) {
+            size.x = mAppDisplayWidth;
+            size.y = mAppDisplayHeight;
+        }
+    }
+
+    public void getRealDisplaySize(Point size) {
+        synchronized(mDisplaySizeLock) {
+            size.x = mCurDisplayWidth;
+            size.y = mCurDisplayHeight;
+        }
+    }
+
+    public void getInitialDisplaySize(Point size) {
+        synchronized(mDisplaySizeLock) {
+            size.x = mInitialDisplayWidth;
+            size.y = mInitialDisplayHeight;
+        }
+    }
+
+    public int getMaximumSizeDimension() {
+        synchronized(mDisplaySizeLock) {
+            // Do this based on the raw screen size, until we are smarter.
+            return mBaseDisplayWidth > mBaseDisplayHeight
+                    ? mBaseDisplayWidth : mBaseDisplayHeight;
+        }
+    }
+
+    public void getCurrentSizeRange(Point smallestSize, Point largestSize) {
+        synchronized(mDisplaySizeLock) {
+            smallestSize.x = mSmallestDisplayWidth;
+            smallestSize.y = mSmallestDisplayHeight;
+            largestSize.x = mLargestDisplayWidth;
+            largestSize.y = mLargestDisplayHeight;
+        }
+    }
+
+    public void setForcedDisplaySize(int longDimen, int shortDimen) {
+        synchronized(mWindowMap) {
+            int width, height;
+            if (mInitialDisplayWidth < mInitialDisplayHeight) {
+                width = shortDimen < mInitialDisplayWidth
+                        ? shortDimen : mInitialDisplayWidth;
+                height = longDimen < mInitialDisplayHeight
+                        ? longDimen : mInitialDisplayHeight;
+            } else {
+                width = longDimen < mInitialDisplayWidth
+                        ? longDimen : mInitialDisplayWidth;
+                height = shortDimen < mInitialDisplayHeight
+                        ? shortDimen : mInitialDisplayHeight;
+            }
+            setForcedDisplaySizeLocked(width, height);
+            Settings.Secure.putString(mContext.getContentResolver(),
+                    Settings.Secure.DISPLAY_SIZE_FORCED, width + "," + height);
+        }
+    }
+
+    private void rebuildBlackFrame() {
+        if (mBlackFrame != null) {
+            mBlackFrame.kill();
+            mBlackFrame = null;
+        }
+        if (mBaseDisplayWidth < mInitialDisplayWidth
+                || mBaseDisplayHeight < mInitialDisplayHeight) {
+            int initW, initH, baseW, baseH;
+            final boolean rotated = (mRotation == Surface.ROTATION_90
+                    || mRotation == Surface.ROTATION_270);
+            if (rotated) {
+                initW = mInitialDisplayHeight;
+                initH = mInitialDisplayWidth;
+                baseW = mBaseDisplayHeight;
+                baseH = mBaseDisplayWidth;
+            } else {
+                initW = mInitialDisplayWidth;
+                initH = mInitialDisplayHeight;
+                baseW = mBaseDisplayWidth;
+                baseH = mBaseDisplayHeight;
+            }
+            Rect outer = new Rect(0, 0, initW, initH);
+            Rect inner = new Rect(0, 0, baseW, baseH);
+            try {
+                mBlackFrame = new BlackFrame(mFxSession, outer, inner, MASK_LAYER);
+            } catch (Surface.OutOfResourcesException e) {
+            }
+        }
+    }
+
+    private void readForcedDisplaySizeLocked() {
+        final String str = Settings.Secure.getString(mContext.getContentResolver(),
+                Settings.Secure.DISPLAY_SIZE_FORCED);
+        if (str == null || str.length() == 0) {
+            return;
+        }
+        final int pos = str.indexOf(',');
+        if (pos <= 0 || str.lastIndexOf(',') != pos) {
+            return;
+        }
+        int width, height;
+        try {
+            width = Integer.parseInt(str.substring(0, pos));
+            height = Integer.parseInt(str.substring(pos+1));
+        } catch (NumberFormatException ex) {
+            return;
+        }
+        setForcedDisplaySizeLocked(width, height);
+    }
+
+    private void setForcedDisplaySizeLocked(int width, int height) {
+        Slog.i(TAG, "Using new display size: " + width + "x" + height);
+
+        synchronized(mDisplaySizeLock) {
+            mBaseDisplayWidth = width;
+            mBaseDisplayHeight = height;
+        }
+        mPolicy.setInitialDisplaySize(mDisplay, mBaseDisplayWidth, mBaseDisplayHeight);
+
+        mLayoutNeeded = true;
+
+        boolean configChanged = updateOrientationFromAppTokensLocked(false);
+        mTempConfiguration.setToDefaults();
+        mTempConfiguration.fontScale = mCurConfiguration.fontScale;
+        if (computeScreenConfigurationLocked(mTempConfiguration)) {
+            if (mCurConfiguration.diff(mTempConfiguration) != 0) {
+                configChanged = true;
+            }
+        }
+
+        if (configChanged) {
+            mWaitingForConfig = true;
+            startFreezingDisplayLocked(false);
+            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
+        }
+
+        rebuildBlackFrame();
+
+        performLayoutAndPlaceSurfacesLocked();
+    }
+
+    public void clearForcedDisplaySize() {
+        synchronized(mWindowMap) {
+            setForcedDisplaySizeLocked(mInitialDisplayWidth, mInitialDisplayHeight);
+            Settings.Secure.putString(mContext.getContentResolver(),
+                    Settings.Secure.DISPLAY_SIZE_FORCED, "");
+        }
+    }
+
+    public boolean hasSystemNavBar() {
+        return mPolicy.hasSystemNavBar();
+    }
+
+    // -------------------------------------------------------------
+    // Internals
+    // -------------------------------------------------------------
+
+    final WindowState windowForClientLocked(Session session, IWindow client,
+            boolean throwOnError) {
+        return windowForClientLocked(session, client.asBinder(), throwOnError);
+    }
+
+    final WindowState windowForClientLocked(Session session, IBinder client,
+            boolean throwOnError) {
+        WindowState win = mWindowMap.get(client);
+        if (localLOGV) Slog.v(
+            TAG, "Looking up client " + client + ": " + win);
+        if (win == null) {
+            RuntimeException ex = new IllegalArgumentException(
+                    "Requested window " + client + " does not exist");
+            if (throwOnError) {
+                throw ex;
+            }
+            Slog.w(TAG, "Failed looking up window", ex);
+            return null;
+        }
+        if (session != null && win.mSession != session) {
+            RuntimeException ex = new IllegalArgumentException(
+                    "Requested window " + client + " is in session " +
+                    win.mSession + ", not " + session);
+            if (throwOnError) {
+                throw ex;
+            }
+            Slog.w(TAG, "Failed looking up window", ex);
+            return null;
+        }
+
+        return win;
+    }
+
+    final void rebuildAppWindowListLocked() {
+        int NW = mWindows.size();
+        int i;
+        int lastWallpaper = -1;
+        int numRemoved = 0;
+
+        if (mRebuildTmp.length < NW) {
+            mRebuildTmp = new WindowState[NW+10];
+        }
+
+        // First remove all existing app windows.
+        i=0;
+        while (i < NW) {
+            WindowState w = mWindows.get(i);
+            if (w.mAppToken != null) {
+                WindowState win = mWindows.remove(i);
+                win.mRebuilding = true;
+                mRebuildTmp[numRemoved] = win;
+                mWindowsChanged = true;
+                if (DEBUG_WINDOW_MOVEMENT) Slog.v(TAG,
+                        "Rebuild removing window: " + win);
+                NW--;
+                numRemoved++;
+                continue;
+            } else if (w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER
+                    && lastWallpaper == i-1) {
+                lastWallpaper = i;
+            }
+            i++;
+        }
+
+        // The wallpaper window(s) typically live at the bottom of the stack,
+        // so skip them before adding app tokens.
+        lastWallpaper++;
+        i = lastWallpaper;
+
+        // First add all of the exiting app tokens...  these are no longer
+        // in the main app list, but still have windows shown.  We put them
+        // in the back because now that the animation is over we no longer
+        // will care about them.
+        int NT = mExitingAppTokens.size();
+        for (int j=0; j<NT; j++) {
+            i = reAddAppWindowsLocked(i, mExitingAppTokens.get(j));
+        }
+
+        // And add in the still active app tokens in Z order.
+        NT = mAnimatingAppTokens.size();
+        for (int j=0; j<NT; j++) {
+            i = reAddAppWindowsLocked(i, mAnimatingAppTokens.get(j));
+        }
+
+        i -= lastWallpaper;
+        if (i != numRemoved) {
+            Slog.w(TAG, "Rebuild removed " + numRemoved
+                    + " windows but added " + i);
+            for (i=0; i<numRemoved; i++) {
+                WindowState ws = mRebuildTmp[i];
+                if (ws.mRebuilding) {
+                    StringWriter sw = new StringWriter();
+                    PrintWriter pw = new PrintWriter(sw);
+                    ws.dump(pw, "", true);
+                    pw.flush();
+                    Slog.w(TAG, "This window was lost: " + ws);
+                    Slog.w(TAG, sw.toString());
+                    ws.mWinAnimator.destroySurfaceLocked();
+                }
+            }
+            Slog.w(TAG, "Current app token list:");
+            dumpAnimatingAppTokensLocked();
+            Slog.w(TAG, "Final window list:");
+            dumpWindowsLocked();
+        }
+    }
+
+    private final void assignLayersLocked() {
+        int N = mWindows.size();
+        int curBaseLayer = 0;
+        int curLayer = 0;
+        int i;
+
+        if (DEBUG_LAYERS) {
+            RuntimeException here = new RuntimeException("here");
+            here.fillInStackTrace();
+            Slog.v(TAG, "Assigning layers", here);
+        }
+
+        for (i=0; i<N; i++) {
+            final WindowState w = mWindows.get(i);
+            final WindowStateAnimator winAnimator = w.mWinAnimator;
+            boolean layerChanged = false;
+            int oldLayer = w.mLayer;
+            if (w.mBaseLayer == curBaseLayer || w.mIsImWindow
+                    || (i > 0 && w.mIsWallpaper)) {
+                curLayer += WINDOW_LAYER_MULTIPLIER;
+                w.mLayer = curLayer;
+            } else {
+                curBaseLayer = curLayer = w.mBaseLayer;
+                w.mLayer = curLayer;
+            }
+            if (w.mLayer != oldLayer) {
+                layerChanged = true;
+            }
+            oldLayer = winAnimator.mAnimLayer;
+            if (w.mTargetAppToken != null) {
+                winAnimator.mAnimLayer =
+                        w.mLayer + w.mTargetAppToken.mAppAnimator.animLayerAdjustment;
+            } else if (w.mAppToken != null) {
+                winAnimator.mAnimLayer =
+                        w.mLayer + w.mAppToken.mAppAnimator.animLayerAdjustment;
+            } else {
+                winAnimator.mAnimLayer = w.mLayer;
+            }
+            if (w.mIsImWindow) {
+                winAnimator.mAnimLayer += mInputMethodAnimLayerAdjustment;
+            } else if (w.mIsWallpaper) {
+                winAnimator.mAnimLayer += mWallpaperAnimLayerAdjustment;
+            }
+            if (winAnimator.mAnimLayer != oldLayer) {
+                layerChanged = true;
+            }
+            if (layerChanged && mAnimator.isDimming(winAnimator)) {
+                // Force an animation pass just to update the mDimAnimator layer.
+                scheduleAnimationLocked();
+            }
+            if (DEBUG_LAYERS) Slog.v(TAG, "Assign layer " + w + ": "
+                    + winAnimator.mAnimLayer);
+            //System.out.println(
+            //    "Assigned layer " + curLayer + " to " + w.mClient.asBinder());
+        }
+    }
+
+    private boolean mInLayout = false;
+    private final void performLayoutAndPlaceSurfacesLocked() {
+        if (mInLayout) {
+            if (DEBUG) {
+                throw new RuntimeException("Recursive call!");
+            }
+            Slog.w(TAG, "performLayoutAndPlaceSurfacesLocked called while in layout. Callers="
+                    + Debug.getCallers(3));
+            return;
+        }
+
+        if (mWaitingForConfig) {
+            // Our configuration has changed (most likely rotation), but we
+            // don't yet have the complete configuration to report to
+            // applications.  Don't do any window layout until we have it.
+            return;
+        }
+        
+        if (mDisplay == null) {
+            // Not yet initialized, nothing to do.
+            return;
+        }
+
+        Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, "wmLayout");
+        mInLayout = true;
+        boolean recoveringMemory = false;
+        
+        try {
+            if (mForceRemoves != null) {
+                recoveringMemory = true;
+                // Wait a little bit for things to settle down, and off we go.
+                for (int i=0; i<mForceRemoves.size(); i++) {
+                    WindowState ws = mForceRemoves.get(i);
+                    Slog.i(TAG, "Force removing: " + ws);
+                    removeWindowInnerLocked(ws.mSession, ws);
+                }
+                mForceRemoves = null;
+                Slog.w(TAG, "Due to memory failure, waiting a bit for next layout");
+                Object tmp = new Object();
+                synchronized (tmp) {
+                    try {
+                        tmp.wait(250);
+                    } catch (InterruptedException e) {
+                    }
+                }
+            }
+        } catch (RuntimeException e) {
+            Log.wtf(TAG, "Unhandled exception while force removing for memory", e);
+        }
+        
+        try {
+            performLayoutAndPlaceSurfacesLockedInner(recoveringMemory);
+
+            final int N = mPendingRemove.size();
+            if (N > 0) {
+                if (mPendingRemoveTmp.length < N) {
+                    mPendingRemoveTmp = new WindowState[N+10];
+                }
+                mPendingRemove.toArray(mPendingRemoveTmp);
+                mPendingRemove.clear();
+                for (int i=0; i<N; i++) {
+                    WindowState w = mPendingRemoveTmp[i];
+                    removeWindowInnerLocked(w.mSession, w);
+                }
+
+                mInLayout = false;
+                assignLayersLocked();
+                mLayoutNeeded = true;
+                // XXX this recursion seems broken!
+                Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);
+                performLayoutAndPlaceSurfacesLocked();
+                Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, "wmLayout");
+
+            } else {
+                mInLayout = false;
+            }
+
+            if (mLayoutNeeded) {
+                if (++mLayoutRepeatCount < 6) {
+                    requestTraversalLocked();
+                } else {
+                    Slog.e(TAG, "Performed 6 layouts in a row. Skipping");
+                    mLayoutRepeatCount = 0;
+                }
+            } else {
+                mLayoutRepeatCount = 0;
+            }
+
+            if (mWindowsChanged && !mWindowChangeListeners.isEmpty()) {
+                mH.removeMessages(H.REPORT_WINDOWS_CHANGE);
+                mH.sendMessage(mH.obtainMessage(H.REPORT_WINDOWS_CHANGE));
+            }
+        } catch (RuntimeException e) {
+            mInLayout = false;
+            Log.wtf(TAG, "Unhandled exception while laying out windows", e);
+        }
+
+        Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);
+    }
+
+    private final void performLayoutLockedInner(boolean initial, boolean updateInputWindows) {
+        if (!mLayoutNeeded) {
+            return;
+        }
+        
+        mLayoutNeeded = false;
+        
+        final int dw = mCurDisplayWidth;
+        final int dh = mCurDisplayHeight;
+
+        final int NFW = mFakeWindows.size();
+        for (int i=0; i<NFW; i++) {
+            mFakeWindows.get(i).layout(dw, dh);
+        }
+
+        final int N = mWindows.size();
+        int i;
+
+        if (DEBUG_LAYOUT) {
+            Slog.v(TAG, "-------------------------------------");
+            Slog.v(TAG, "performLayout: needed="
+                    + mLayoutNeeded + " dw=" + dw + " dh=" + dh);
+        }
+        
+        mPolicy.beginLayoutLw(dw, dh, mRotation);
+        mSystemDecorLayer = mPolicy.getSystemDecorRectLw(mSystemDecorRect);
+
+        int seq = mLayoutSeq+1;
+        if (seq < 0) seq = 0;
+        mLayoutSeq = seq;
+        
+        // First perform layout of any root windows (not attached
+        // to another window).
+        int topAttached = -1;
+        for (i = N-1; i >= 0; i--) {
+            final WindowState win = mWindows.get(i);
+
+            // Don't do layout of a window if it is not visible, or
+            // soon won't be visible, to avoid wasting time and funky
+            // changes while a window is animating away.
+            final boolean gone = win.isGoneForLayoutLw();
+
+            if (DEBUG_LAYOUT && !win.mLayoutAttached) {
+                Slog.v(TAG, "1ST PASS " + win
+                        + ": gone=" + gone + " mHaveFrame=" + win.mHaveFrame
+                        + " mLayoutAttached=" + win.mLayoutAttached);
+                final AppWindowToken atoken = win.mAppToken;
+                if (gone) Slog.v(TAG, "  GONE: mViewVisibility="
+                        + win.mViewVisibility + " mRelayoutCalled="
+                        + win.mRelayoutCalled + " hidden="
+                        + win.mRootToken.hidden + " hiddenRequested="
+                        + (atoken != null && atoken.hiddenRequested)
+                        + " mAttachedHidden=" + win.mAttachedHidden);
+                else Slog.v(TAG, "  VIS: mViewVisibility="
+                        + win.mViewVisibility + " mRelayoutCalled="
+                        + win.mRelayoutCalled + " hidden="
+                        + win.mRootToken.hidden + " hiddenRequested="
+                        + (atoken != null && atoken.hiddenRequested)
+                        + " mAttachedHidden=" + win.mAttachedHidden);
+            }
+            
+            // If this view is GONE, then skip it -- keep the current
+            // frame, and let the caller know so they can ignore it
+            // if they want.  (We do the normal layout for INVISIBLE
+            // windows, since that means "perform layout as normal,
+            // just don't display").
+            if (!gone || !win.mHaveFrame || win.mLayoutNeeded) {
+                if (!win.mLayoutAttached) {
+                    if (initial) {
+                        //Slog.i(TAG, "Window " + this + " clearing mContentChanged - initial");
+                        win.mContentChanged = false;
+                    }
+                    win.mLayoutNeeded = false;
+                    win.prelayout();
+                    mPolicy.layoutWindowLw(win, win.mAttrs, null);
+                    win.mLayoutSeq = seq;
+                    if (DEBUG_LAYOUT) Slog.v(TAG, "  LAYOUT: mFrame="
+                            + win.mFrame + " mContainingFrame="
+                            + win.mContainingFrame + " mDisplayFrame="
+                            + win.mDisplayFrame);
+                } else {
+                    if (topAttached < 0) topAttached = i;
+                }
+            }
+        }
+
+        // Now perform layout of attached windows, which usually
+        // depend on the position of the window they are attached to.
+        // XXX does not deal with windows that are attached to windows
+        // that are themselves attached.
+        for (i = topAttached; i >= 0; i--) {
+            final WindowState win = mWindows.get(i);
+
+            if (win.mLayoutAttached) {
+                if (DEBUG_LAYOUT) Slog.v(TAG, "2ND PASS " + win
+                        + " mHaveFrame=" + win.mHaveFrame
+                        + " mViewVisibility=" + win.mViewVisibility
+                        + " mRelayoutCalled=" + win.mRelayoutCalled);
+                // If this view is GONE, then skip it -- keep the current
+                // frame, and let the caller know so they can ignore it
+                // if they want.  (We do the normal layout for INVISIBLE
+                // windows, since that means "perform layout as normal,
+                // just don't display").
+                if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled)
+                        || !win.mHaveFrame || win.mLayoutNeeded) {
+                    if (initial) {
+                        //Slog.i(TAG, "Window " + this + " clearing mContentChanged - initial");
+                        win.mContentChanged = false;
+                    }
+                    win.mLayoutNeeded = false;
+                    win.prelayout();
+                    mPolicy.layoutWindowLw(win, win.mAttrs, win.mAttachedWindow);
+                    win.mLayoutSeq = seq;
+                    if (DEBUG_LAYOUT) Slog.v(TAG, "  LAYOUT: mFrame="
+                            + win.mFrame + " mContainingFrame="
+                            + win.mContainingFrame + " mDisplayFrame="
+                            + win.mDisplayFrame);
+                }
+            }
+        }
+        
+        // Window frames may have changed.  Tell the input dispatcher about it.
+        mInputMonitor.setUpdateInputWindowsNeededLw();
+        if (updateInputWindows) {
+            mInputMonitor.updateInputWindowsLw(false /*force*/);
+        }
+
+        mPolicy.finishLayoutLw();
+    }
+
+    void makeWindowFreezingScreenIfNeededLocked(WindowState w) {
+        // If the screen is currently frozen or off, then keep
+        // it frozen/off until this window draws at its new
+        // orientation.
+        if (!okToDisplay()) {
+            if (DEBUG_ORIENTATION) Slog.v(TAG,
+                    "Changing surface while display frozen: " + w);
+            w.mOrientationChanging = true;
+            mInnerFields.mOrientationChangeComplete = false;
+            if (!mWindowsFreezingScreen) {
+                mWindowsFreezingScreen = true;
+                // XXX should probably keep timeout from
+                // when we first froze the display.
+                mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
+                mH.sendMessageDelayed(mH.obtainMessage(
+                        H.WINDOW_FREEZE_TIMEOUT), 2000);
+            }
+        }
+    }
+
+    /**
+     * Extracted from {@link #performLayoutAndPlaceSurfacesLockedInner} to reduce size of method.
+     *
+     * @return bitmap indicating if another pass through layout must be made.
+     */
+    public int handleAppTransitionReadyLocked() {
+        int changes = 0;
+        int i;
+        int NN = mOpeningApps.size();
+        boolean goodToGo = true;
+        if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,
+                "Checking " + NN + " opening apps (frozen="
+                + mDisplayFrozen + " timeout="
+                + mAppTransitionTimeout + ")...");
+        if (!mDisplayFrozen && !mAppTransitionTimeout) {
+            // If the display isn't frozen, wait to do anything until
+            // all of the apps are ready.  Otherwise just go because
+            // we'll unfreeze the display when everyone is ready.
+            for (i=0; i<NN && goodToGo; i++) {
+                AppWindowToken wtoken = mOpeningApps.get(i);
+                if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,
+                        "Check opening app=" + wtoken + ": allDrawn="
+                        + wtoken.allDrawn + " startingDisplayed="
+                        + wtoken.startingDisplayed + " startingMoved="
+                        + wtoken.startingMoved);
+                if (!wtoken.allDrawn && !wtoken.startingDisplayed
+                        && !wtoken.startingMoved) {
+                    goodToGo = false;
+                }
+            }
+        }
+        if (goodToGo) {
+            if (DEBUG_APP_TRANSITIONS) Slog.v(TAG, "**** GOOD TO GO");
+            int transit = mNextAppTransition;
+            if (mSkipAppTransitionAnimation) {
+                transit = WindowManagerPolicy.TRANSIT_UNSET;
+            }
+            mNextAppTransition = WindowManagerPolicy.TRANSIT_UNSET;
+            mAppTransitionReady = false;
+            mAppTransitionRunning = true;
+            mAppTransitionTimeout = false;
+            mStartingIconInTransition = false;
+            mSkipAppTransitionAnimation = false;
+
+            mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
+
+            rebuildAppWindowListLocked();
+
+            // if wallpaper is animating in or out set oldWallpaper to null else to wallpaper
+            WindowState oldWallpaper =
+                    mWallpaperTarget != null && mWallpaperTarget.mWinAnimator.isAnimating()
+                        && !mWallpaperTarget.mWinAnimator.isDummyAnimation()
+                    ? null : mWallpaperTarget;
+
+            adjustWallpaperWindowsLocked();
+            mInnerFields.mWallpaperMayChange = false;
+
+            // The top-most window will supply the layout params,
+            // and we will determine it below.
+            LayoutParams animLp = null;
+            int bestAnimLayer = -1;
+            boolean fullscreenAnim = false;
+
+            if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,
+                    "New wallpaper target=" + mWallpaperTarget
+                    + ", oldWallpaper=" + oldWallpaper
+                    + ", lower target=" + mLowerWallpaperTarget
+                    + ", upper target=" + mUpperWallpaperTarget);
+            int foundWallpapers = 0;
+            // Do a first pass through the tokens for two
+            // things:
+            // (1) Determine if both the closing and opening
+            // app token sets are wallpaper targets, in which
+            // case special animations are needed
+            // (since the wallpaper needs to stay static
+            // behind them).
+            // (2) Find the layout params of the top-most
+            // application window in the tokens, which is
+            // what will control the animation theme.
+            final int NC = mClosingApps.size();
+            NN = NC + mOpeningApps.size();
+            for (i=0; i<NN; i++) {
+                AppWindowToken wtoken;
+                int mode;
+                if (i < NC) {
+                    wtoken = mClosingApps.get(i);
+                    mode = 1;
+                } else {
+                    wtoken = mOpeningApps.get(i-NC);
+                    mode = 2;
+                }
+                if (mLowerWallpaperTarget != null) {
+                    if (mLowerWallpaperTarget.mAppToken == wtoken
+                            || mUpperWallpaperTarget.mAppToken == wtoken) {
+                        foundWallpapers |= mode;
+                    }
+                }
+                if (wtoken.appFullscreen) {
+                    WindowState ws = wtoken.findMainWindow();
+                    if (ws != null) {
+                        animLp = ws.mAttrs;
+                        bestAnimLayer = ws.mLayer;
+                        fullscreenAnim = true;
+                    }
+                } else if (!fullscreenAnim) {
+                    WindowState ws = wtoken.findMainWindow();
+                    if (ws != null) {
+                        if (ws.mLayer > bestAnimLayer) {
+                            animLp = ws.mAttrs;
+                            bestAnimLayer = ws.mLayer;
+                        }
+                    }
+                }
+            }
+
+            if (foundWallpapers == 3) {
+                if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,
+                        "Wallpaper animation!");
+                switch (transit) {
+                    case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
+                    case WindowManagerPolicy.TRANSIT_TASK_OPEN:
+                    case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
+                        transit = WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
+                        break;
+                    case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
+                    case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
+                    case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
+                        transit = WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
+                        break;
+                }
+                if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,
+                        "New transit: " + transit);
+            } else if ((oldWallpaper != null) && !mOpeningApps.contains(oldWallpaper.mAppToken)) {
+                // We are transitioning from an activity with
+                // a wallpaper to one without.
+                transit = WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
+                if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,
+                        "New transit away from wallpaper: " + transit);
+            } else if (mWallpaperTarget != null) {
+                // We are transitioning from an activity without
+                // a wallpaper to now showing the wallpaper
+                transit = WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
+                if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,
+                        "New transit into wallpaper: " + transit);
+            }
+
+            // If all closing windows are obscured, then there is
+            // no need to do an animation.  This is the case, for
+            // example, when this transition is being done behind
+            // the lock screen.
+            if (!mPolicy.allowAppAnimationsLw()) {
+                animLp = null;
+            }
+
+            AppWindowToken topOpeningApp = null;
+            int topOpeningLayer = 0;
+
+            NN = mOpeningApps.size();
+            for (i=0; i<NN; i++) {
+                AppWindowToken wtoken = mOpeningApps.get(i);
+                if (DEBUG_APP_TRANSITIONS) Slog.v(TAG, "Now opening app" + wtoken);
+                wtoken.mAppAnimator.clearThumbnail();
+                wtoken.reportedVisible = false;
+                wtoken.inPendingTransaction = false;
+                wtoken.mAppAnimator.animation = null;
+                setTokenVisibilityLocked(wtoken, animLp, true, transit, false);
+                wtoken.updateReportedVisibilityLocked();
+                wtoken.waitingToShow = false;
+                mAnimator.mAnimating |= wtoken.mAppAnimator.showAllWindowsLocked();
+                if (animLp != null) {
+                    int layer = -1;
+                    for (int j=0; j<wtoken.windows.size(); j++) {
+                        WindowState win = wtoken.windows.get(j);
+                        if (win.mWinAnimator.mAnimLayer > layer) {
+                            layer = win.mWinAnimator.mAnimLayer;
+                        }
+                    }
+                    if (topOpeningApp == null || layer > topOpeningLayer) {
+                        topOpeningApp = wtoken;
+                        topOpeningLayer = layer;
+                    }
+                }
+            }
+            NN = mClosingApps.size();
+            for (i=0; i<NN; i++) {
+                AppWindowToken wtoken = mClosingApps.get(i);
+                if (DEBUG_APP_TRANSITIONS) Slog.v(TAG,
+                        "Now closing app" + wtoken);
+                wtoken.mAppAnimator.clearThumbnail();
+                wtoken.inPendingTransaction = false;
+                wtoken.mAppAnimator.animation = null;
+                setTokenVisibilityLocked(wtoken, animLp, false,
+                        transit, false);
+                wtoken.updateReportedVisibilityLocked();
+                wtoken.waitingToHide = false;
+                // Force the allDrawn flag, because we want to start
+                // this guy's animations regardless of whether it's
+                // gotten drawn.
+                wtoken.allDrawn = true;
+            }
+
+            if (mNextAppTransitionThumbnail != null && topOpeningApp != null
+                    && topOpeningApp.mAppAnimator.animation != null) {
+                // This thumbnail animation is very special, we need to have
+                // an extra surface with the thumbnail included with the animation.
+                Rect dirty = new Rect(0, 0, mNextAppTransitionThumbnail.getWidth(),
+                        mNextAppTransitionThumbnail.getHeight());
+                try {
+                    Surface surface = new Surface(mFxSession, Process.myPid(),
+                            "thumbnail anim", 0, dirty.width(), dirty.height(),
+                            PixelFormat.TRANSLUCENT, Surface.HIDDEN);
+                    topOpeningApp.mAppAnimator.thumbnail = surface;
+                    if (SHOW_TRANSACTIONS) Slog.i(TAG, "  THUMBNAIL "
+                            + surface + ": CREATE");
+                    Surface drawSurface = new Surface();
+                    drawSurface.copyFrom(surface);
+                    Canvas c = drawSurface.lockCanvas(dirty);
+                    c.drawBitmap(mNextAppTransitionThumbnail, 0, 0, null);
+                    drawSurface.unlockCanvasAndPost(c);
+                    drawSurface.release();
+                    topOpeningApp.mAppAnimator.thumbnailLayer = topOpeningLayer;
+                    Animation anim = createThumbnailAnimationLocked(
+                            transit, true, true, mNextAppTransitionDelayed);
+                    topOpeningApp.mAppAnimator.thumbnailAnimation = anim;
+                    anim.restrictDuration(MAX_ANIMATION_DURATION);
+                    anim.scaleCurrentDuration(mTransitionAnimationScale);
+                    topOpeningApp.mAppAnimator.thumbnailX = mNextAppTransitionStartX;
+                    topOpeningApp.mAppAnimator.thumbnailY = mNextAppTransitionStartY;
+                } catch (Surface.OutOfResourcesException e) {
+                    Slog.e(TAG, "Can't allocate thumbnail surface w=" + dirty.width()
+                            + " h=" + dirty.height(), e);
+                    topOpeningApp.mAppAnimator.clearThumbnail();
+                }
+            }
+
+            mNextAppTransitionType = ActivityOptions.ANIM_NONE;
+            mNextAppTransitionPackage = null;
+            mNextAppTransitionThumbnail = null;
+            scheduleAnimationCallback(mNextAppTransitionCallback);
+            mNextAppTransitionCallback = null;
+
+            mOpeningApps.clear();
+            mClosingApps.clear();
+
+            // This has changed the visibility of windows, so perform
+            // a new layout to get them all up-to-date.
+            changes |= PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT
+                    | WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG;
+            mLayoutNeeded = true;
+            if (!moveInputMethodWindowsIfNeededLocked(true)) {
+                assignLayersLocked();
+            }
+            updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,
+                    false /*updateInputWindows*/);
+            mFocusMayChange = false;
+        }
+
+        return changes;
+    }
+
+    /**
+     * Extracted from {@link #performLayoutAndPlaceSurfacesLockedInner} to reduce size of method.
+     *
+     * @return bitmap indicating if another pass through layout must be made.
+     */
+    private int handleAnimatingStoppedAndTransitionLocked() {
+        int changes = 0;
+
+        mAppTransitionRunning = false;
+        // Restore window app tokens to the ActivityManager views
+        for (int i = mAnimatingAppTokens.size() - 1; i >= 0; i--) {
+            mAnimatingAppTokens.get(i).sendingToBottom = false;
+        }
+        mAnimatingAppTokens.clear();
+        mAnimatingAppTokens.addAll(mAppTokens);
+        rebuildAppWindowListLocked();
+
+        changes |= PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
+        mInnerFields.mAdjResult |= ADJUST_WALLPAPER_LAYERS_CHANGED;
+        moveInputMethodWindowsIfNeededLocked(true);
+        mInnerFields.mWallpaperMayChange = true;
+        // Since the window list has been rebuilt, focus might
+        // have to be recomputed since the actual order of windows
+        // might have changed again.
+        mFocusMayChange = true;
+
+        return changes;
+    }
+
+    /**
+     * Extracted from {@link #performLayoutAndPlaceSurfacesLockedInner} to reduce size of method.
+     *
+     * @return bitmap indicating if another pass through layout must be made.
+     */
+    private int animateAwayWallpaperLocked() {
+        int changes = 0;
+        WindowState oldWallpaper = mWallpaperTarget;
+        if (mLowerWallpaperTarget != null
+                && mLowerWallpaperTarget.mAppToken != null) {
+            if (DEBUG_WALLPAPER) Slog.v(TAG,
+                    "wallpaperForceHiding changed with lower="
+                    + mLowerWallpaperTarget);
+            if (DEBUG_WALLPAPER) Slog.v(TAG,
+                    "hidden=" + mLowerWallpaperTarget.mAppToken.hidden +
+                    " hiddenRequested=" + mLowerWallpaperTarget.mAppToken.hiddenRequested);
+            if (mLowerWallpaperTarget.mAppToken.hidden) {
+                // The lower target has become hidden before we
+                // actually started the animation...  let's completely
+                // re-evaluate everything.
+                mLowerWallpaperTarget = mUpperWallpaperTarget = null;
+                changes |= PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
+            }
+        }
+        mInnerFields.mAdjResult |= adjustWallpaperWindowsLocked();
+        if (DEBUG_WALLPAPER) Slog.v(TAG, "****** OLD: " + oldWallpaper
+                + " NEW: " + mWallpaperTarget
+                + " LOWER: " + mLowerWallpaperTarget);
+        return changes;
+    }
+
+    private void updateResizingWindows(final WindowState w) {
+        final WindowStateAnimator winAnimator = w.mWinAnimator;
+        if (w.mHasSurface && !w.mAppFreezing && w.mLayoutSeq == mLayoutSeq) {
+            w.mContentInsetsChanged |=
+                    !w.mLastContentInsets.equals(w.mContentInsets);
+            w.mVisibleInsetsChanged |=
+                    !w.mLastVisibleInsets.equals(w.mVisibleInsets);
+            boolean configChanged =
+                w.mConfiguration != mCurConfiguration
+                && (w.mConfiguration == null
+                        || mCurConfiguration.diff(w.mConfiguration) != 0);
+            if (DEBUG_CONFIGURATION && configChanged) {
+                Slog.v(TAG, "Win " + w + " config changed: "
+                        + mCurConfiguration);
+            }
+            if (localLOGV) Slog.v(TAG, "Resizing " + w
+                    + ": configChanged=" + configChanged
+                    + " last=" + w.mLastFrame + " frame=" + w.mFrame);
+            w.mLastFrame.set(w.mFrame);
+            if (w.mContentInsetsChanged
+                    || w.mVisibleInsetsChanged
+                    || winAnimator.mSurfaceResized
+                    || configChanged) {
+                if (DEBUG_RESIZE || DEBUG_ORIENTATION) {
+                    Slog.v(TAG, "Resize reasons: "
+                            + " contentInsetsChanged=" + w.mContentInsetsChanged
+                            + " visibleInsetsChanged=" + w.mVisibleInsetsChanged
+                            + " surfaceResized=" + winAnimator.mSurfaceResized
+                            + " configChanged=" + configChanged);
+                }
+
+                w.mLastContentInsets.set(w.mContentInsets);
+                w.mLastVisibleInsets.set(w.mVisibleInsets);
+                makeWindowFreezingScreenIfNeededLocked(w);
+                // If the orientation is changing, then we need to
+                // hold off on unfreezing the display until this
+                // window has been redrawn; to do that, we need
+                // to go through the process of getting informed
+                // by the application when it has finished drawing.
+                if (w.mOrientationChanging) {
+                    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM || DEBUG_ORIENTATION) Slog.v(TAG,
+                            "Orientation start waiting for draw mDrawState=DRAW_PENDING in "
+                            + w + ", surface " + winAnimator.mSurface);
+                    winAnimator.mDrawState = WindowStateAnimator.DRAW_PENDING;
+                    if (w.mAppToken != null) {
+                        w.mAppToken.allDrawn = false;
+                    }
+                }
+                if (!mResizingWindows.contains(w)) {
+                    if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,
+                            "Resizing window " + w + " to " + winAnimator.mSurfaceW
+                            + "x" + winAnimator.mSurfaceH);
+                    mResizingWindows.add(w);
+                }
+            } else if (w.mOrientationChanging) {
+                if (w.isDrawnLw()) {
+                    if (DEBUG_ORIENTATION) Slog.v(TAG,
+                            "Orientation not waiting for draw in "
+                            + w + ", surface " + winAnimator.mSurface);
+                    w.mOrientationChanging = false;
+                }
+            }
+        }
+    }
+
+    /**
+     * Extracted from {@link #performLayoutAndPlaceSurfacesLockedInner} to reduce size of method.
+     *
+     * @param w WindowState this method is applied to.
+     * @param currentTime The time which animations use for calculating transitions.
+     * @param innerDw Width of app window.
+     * @param innerDh Height of app window.
+     */
+    private void handleNotObscuredLocked(final WindowState w, final long currentTime,
+                                         final int innerDw, final int innerDh) {
+        final WindowManager.LayoutParams attrs = w.mAttrs;
+        final int attrFlags = attrs.flags;
+        final boolean canBeSeen = w.isDisplayedLw();
+
+        if (w.mHasSurface) {
+            if ((attrFlags&FLAG_KEEP_SCREEN_ON) != 0) {
+                mInnerFields.mHoldScreen = w.mSession;
+            }
+            if (!mInnerFields.mSyswin && w.mAttrs.screenBrightness >= 0
+                    && mInnerFields.mScreenBrightness < 0) {
+                mInnerFields.mScreenBrightness = w.mAttrs.screenBrightness;
+            }
+            if (!mInnerFields.mSyswin && w.mAttrs.buttonBrightness >= 0
+                    && mInnerFields.mButtonBrightness < 0) {
+                mInnerFields.mButtonBrightness = w.mAttrs.buttonBrightness;
+            }
+            if (canBeSeen
+                    && (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG
+                     || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD
+                     || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)) {
+                mInnerFields.mSyswin = true;
+            }
+        }
+
+        boolean opaqueDrawn = canBeSeen && w.isOpaqueDrawn();
+        if (opaqueDrawn && w.isFullscreen(innerDw, innerDh)) {
+            // This window completely covers everything behind it,
+            // so we want to leave all of them as undimmed (for
+            // performance reasons).
+            mInnerFields.mObscured = true;
+        } else if (canBeSeen && (attrFlags & FLAG_DIM_BEHIND) != 0
+                && !(w.mAppToken != null && w.mAppToken.hiddenRequested)
+                && !w.mExiting) {
+            if (localLOGV) Slog.v(TAG, "Win " + w + " obscured=" + mInnerFields.mObscured);
+            if (!mInnerFields.mDimming) {
+                //Slog.i(TAG, "DIM BEHIND: " + w);
+                mInnerFields.mDimming = true;
+                final WindowStateAnimator winAnimator = w.mWinAnimator;
+                if (!mAnimator.isDimming(winAnimator)) {
+                    final int width, height;
+                    if (attrs.type == WindowManager.LayoutParams.TYPE_BOOT_PROGRESS) {
+                        width = mCurDisplayWidth;
+                        height = mCurDisplayHeight;
+                    } else {
+                        width = innerDw;
+                        height = innerDh;
+                    }
+                    mAnimator.startDimming(winAnimator, w.mExiting ? 0 : w.mAttrs.dimAmount,
+                            width, height);
+                }
+            }
+        }
+    }
+
+    private void updateAllDrawnLocked() {
+        // See if any windows have been drawn, so they (and others
+        // associated with them) can now be shown.
+        final ArrayList<AppWindowToken> appTokens = mAnimatingAppTokens;
+        final int NT = appTokens.size();
+        for (int i=0; i<NT; i++) {
+            AppWindowToken wtoken = appTokens.get(i);
+            if (!wtoken.allDrawn) {
+                int numInteresting = wtoken.numInterestingWindows;
+                if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
+                    if (WindowManagerService.DEBUG_VISIBILITY) Slog.v(TAG,
+                            "allDrawn: " + wtoken
+                            + " interesting=" + numInteresting
+                            + " drawn=" + wtoken.numDrawnWindows);
+                    wtoken.allDrawn = true;
+                }
+            }
+        }
+    }
+
+    // "Something has changed!  Let's make it correct now."
+    private final void performLayoutAndPlaceSurfacesLockedInner(
+            boolean recoveringMemory) {
+        if (DEBUG_WINDOW_TRACE) {
+            Slog.v(TAG, "performLayoutAndPlaceSurfacesLockedInner: entry. Called by "
+                    + Debug.getCallers(3));
+        }
+        if (mDisplay == null) {
+            Slog.i(TAG, "skipping performLayoutAndPlaceSurfacesLockedInner with no mDisplay");
+            return;
+        }
+
+        final long currentTime = SystemClock.uptimeMillis();
+        final int dw = mCurDisplayWidth;
+        final int dh = mCurDisplayHeight;
+        final int innerDw = mAppDisplayWidth;
+        final int innerDh = mAppDisplayHeight;
+
+        int i;
+
+        if (mFocusMayChange) {
+            mFocusMayChange = false;
+            updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,
+                    false /*updateInputWindows*/);
+        }
+
+        // Initialize state of exiting tokens.
+        for (i=mExitingTokens.size()-1; i>=0; i--) {
+            mExitingTokens.get(i).hasVisible = false;
+        }
+
+        // Initialize state of exiting applications.
+        for (i=mExitingAppTokens.size()-1; i>=0; i--) {
+            mExitingAppTokens.get(i).hasVisible = false;
+        }
+
+        mInnerFields.mHoldScreen = null;
+        mInnerFields.mScreenBrightness = -1;
+        mInnerFields.mButtonBrightness = -1;
+        mTransactionSequence++;
+
+        if (SHOW_LIGHT_TRANSACTIONS) Slog.i(TAG,
+                ">>> OPEN TRANSACTION performLayoutAndPlaceSurfaces");
+
+        Surface.openTransaction();
+
+        if (mWatermark != null) {
+            mWatermark.positionSurface(dw, dh);
+        }
+        if (mStrictModeFlash != null) {
+            mStrictModeFlash.positionSurface(dw, dh);
+        }
+
+        try {
+            int repeats = 0;
+
+            do {
+                repeats++;
+                if (repeats > 6) {
+                    Slog.w(TAG, "Animation repeat aborted after too many iterations");
+                    mLayoutNeeded = false;
+                    break;
+                }
+
+                if (DEBUG_LAYOUT_REPEATS) debugLayoutRepeats("On entry to LockedInner",
+                    mPendingLayoutChanges);
+
+                if ((mPendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
+                    if ((adjustWallpaperWindowsLocked()&ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
+                        assignLayersLocked();
+                        mLayoutNeeded = true;
+                    }
+                }
+
+                if ((mPendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
+                    if (DEBUG_LAYOUT) Slog.v(TAG, "Computing new config from layout");
+                    if (updateOrientationFromAppTokensLocked(true)) {
+                        mLayoutNeeded = true;
+                        mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
+                    }
+                }
+
+                if ((mPendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
+                    mLayoutNeeded = true;
+                }
+
+                // FIRST LOOP: Perform a layout, if needed.
+                if (repeats < 4) {
+                    performLayoutLockedInner(repeats == 1, false /*updateInputWindows*/);
+                } else {
+                    Slog.w(TAG, "Layout repeat skipped after too many iterations");
+                }
+
+                // FIRST AND ONE HALF LOOP: Make WindowManagerPolicy think
+                // it is animating.
+                mPendingLayoutChanges = 0;
+                if (DEBUG_LAYOUT_REPEATS)  debugLayoutRepeats("loop number " + mLayoutRepeatCount,
+                    mPendingLayoutChanges);
+                mPolicy.beginAnimationLw(dw, dh);
+                for (i = mWindows.size() - 1; i >= 0; i--) {
+                    WindowState w = mWindows.get(i);
+                    if (w.mHasSurface) {
+                        mPolicy.animatingWindowLw(w, w.mAttrs);
+                    }
+                }
+                mPendingLayoutChanges |= mPolicy.finishAnimationLw();
+                if (DEBUG_LAYOUT_REPEATS) debugLayoutRepeats("after finishAnimationLw",
+                    mPendingLayoutChanges);
+            } while (mPendingLayoutChanges != 0);
+
+            final boolean someoneLosingFocus = !mLosingFocus.isEmpty();
+
+            mInnerFields.mObscured = false;
+            mInnerFields.mDimming = false;
+            mInnerFields.mSyswin = false;
+
+            boolean focusDisplayed = false;
+            boolean updateAllDrawn = false;
+            final int N = mWindows.size();
+            for (i=N-1; i>=0; i--) {
+                WindowState w = mWindows.get(i);
+
+                final boolean obscuredChanged = w.mObscured != mInnerFields.mObscured;
+
+                // Update effect.
+                w.mObscured = mInnerFields.mObscured;
+                if (!mInnerFields.mObscured) {
+                    handleNotObscuredLocked(w, currentTime, innerDw, innerDh);
+                }
+
+                if (obscuredChanged && (mWallpaperTarget == w) && w.isVisibleLw()) {
+                    // This is the wallpaper target and its obscured state
+                    // changed... make sure the current wallaper's visibility
+                    // has been updated accordingly.
+                    updateWallpaperVisibilityLocked();
+                }
+
+                final WindowStateAnimator winAnimator = w.mWinAnimator;
+
+                // If the window has moved due to its containing
+                // content frame changing, then we'd like to animate
+                // it.
+                if (w.mHasSurface && w.shouldAnimateMove()) {
+                    // Frame has moved, containing content frame
+                    // has also moved, and we're not currently animating...
+                    // let's do something.
+                    Animation a = AnimationUtils.loadAnimation(mContext,
+                            com.android.internal.R.anim.window_move_from_decor);
+                    winAnimator.setAnimation(a);
+                    winAnimator.mAnimDw = w.mLastFrame.left - w.mFrame.left;
+                    winAnimator.mAnimDh = w.mLastFrame.top - w.mFrame.top;
+                }
+
+                //Slog.i(TAG, "Window " + this + " clearing mContentChanged - done placing");
+                w.mContentChanged = false;
+
+                // Moved from updateWindowsAndWallpaperLocked().
+                if (w.mHasSurface) {
+                    // Take care of the window being ready to display.
+                    if (winAnimator.commitFinishDrawingLocked(currentTime)) {
+                        if ((w.mAttrs.flags
+                                & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
+                            if (WindowManagerService.DEBUG_WALLPAPER) Slog.v(TAG,
+                                    "First draw done in potential wallpaper target " + w);
+                            mInnerFields.mWallpaperMayChange = true;
+                            mPendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
+                            if (WindowManagerService.DEBUG_LAYOUT_REPEATS) {
+                                debugLayoutRepeats("updateWindowsAndWallpaperLocked 1",
+                                    mPendingLayoutChanges);
+                            }
+                        }
+                    }
+
+                    winAnimator.setSurfaceBoundaries(recoveringMemory);
+
+                    final AppWindowToken atoken = w.mAppToken;
+                    if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
+                        Slog.d(TAG, "updateWindows: starting " + w + " isOnScreen="
+                            + w.isOnScreen() + " allDrawn=" + atoken.allDrawn
+                            + " freezingScreen=" + atoken.mAppAnimator.freezingScreen);
+                    }
+                    if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
+                        if (atoken.lastTransactionSequence != mTransactionSequence) {
+                            atoken.lastTransactionSequence = mTransactionSequence;
+                            atoken.numInterestingWindows = atoken.numDrawnWindows = 0;
+                            atoken.startingDisplayed = false;
+                        }
+                        if ((w.isOnScreen() || winAnimator.mAttrType
+                                == WindowManager.LayoutParams.TYPE_BASE_APPLICATION)
+                                && !w.mExiting && !w.mDestroying) {
+                            if (WindowManagerService.DEBUG_VISIBILITY ||
+                                    WindowManagerService.DEBUG_ORIENTATION) {
+                                Slog.v(TAG, "Eval win " + w + ": isDrawn=" + w.isDrawnLw()
+                                        + ", isAnimating=" + winAnimator.isAnimating());
+                                if (!w.isDrawnLw()) {
+                                    Slog.v(TAG, "Not displayed: s=" + winAnimator.mSurface
+                                            + " pv=" + w.mPolicyVisibility
+                                            + " mDrawState=" + winAnimator.mDrawState
+                                            + " ah=" + w.mAttachedHidden
+                                            + " th=" + atoken.hiddenRequested
+                                            + " a=" + winAnimator.mAnimating);
+                                }
+                            }
+                            if (w != atoken.startingWindow) {
+                                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
+                                    atoken.numInterestingWindows++;
+                                    if (w.isDrawnLw()) {
+                                        atoken.numDrawnWindows++;
+                                        if (WindowManagerService.DEBUG_VISIBILITY ||
+                                                WindowManagerService.DEBUG_ORIENTATION) Slog.v(TAG,
+                                                "tokenMayBeDrawn: " + atoken
+                                                + " freezingScreen=" + atoken.mAppAnimator.freezingScreen
+                                                + " mAppFreezing=" + w.mAppFreezing);
+                                        updateAllDrawn = true;
+                                    }
+                                }
+                            } else if (w.isDrawnLw()) {
+                                atoken.startingDisplayed = true;
+                            }
+                        }
+                    }
+                }
+
+                if (someoneLosingFocus && w == mCurrentFocus && w.isDisplayedLw()) {
+                    focusDisplayed = true;
+                }
+
+                updateResizingWindows(w);
+            }
+
+            if (updateAllDrawn) {
+                updateAllDrawnLocked();
+            }
+
+            if (focusDisplayed) {
+                mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
+            }
+
+            if (!mInnerFields.mDimming && mAnimator.isDimming()) {
+                mAnimator.stopDimming();
+            }
+        } catch (RuntimeException e) {
+            Log.wtf(TAG, "Unhandled exception in Window Manager", e);
+        } finally {
+            Surface.closeTransaction();
+        }
+
+        // If we are ready to perform an app transition, check through
+        // all of the app tokens to be shown and see if they are ready
+        // to go.
+        if (mAppTransitionReady) {
+            mPendingLayoutChanges |= handleAppTransitionReadyLocked();
+            if (DEBUG_LAYOUT_REPEATS) debugLayoutRepeats("after handleAppTransitionReadyLocked",
+                mPendingLayoutChanges);
+        }
+
+        mInnerFields.mAdjResult = 0;
+
+        if (!mAnimator.mAnimating && mAppTransitionRunning) {
+            // We have finished the animation of an app transition.  To do
+            // this, we have delayed a lot of operations like showing and
+            // hiding apps, moving apps in Z-order, etc.  The app token list
+            // reflects the correct Z-order, but the window list may now
+            // be out of sync with it.  So here we will just rebuild the
+            // entire app window list.  Fun!
+            mPendingLayoutChanges |= handleAnimatingStoppedAndTransitionLocked();
+            if (DEBUG_LAYOUT_REPEATS) debugLayoutRepeats("after handleAnimStopAndXitionLock",
+                mPendingLayoutChanges);
+        }
+
+        if (mInnerFields.mWallpaperForceHidingChanged && mPendingLayoutChanges == 0 &&
+                !mAppTransitionReady) {
+            // At this point, there was a window with a wallpaper that
+            // was force hiding other windows behind it, but now it
+            // is going away.  This may be simple -- just animate
+            // away the wallpaper and its window -- or it may be
+            // hard -- the wallpaper now needs to be shown behind
+            // something that was hidden.
+            mPendingLayoutChanges |= animateAwayWallpaperLocked();
+            if (DEBUG_LAYOUT_REPEATS) debugLayoutRepeats("after animateAwayWallpaperLocked",
+                mPendingLayoutChanges);
+        }
+        mInnerFields.mWallpaperForceHidingChanged = false;
+
+        if (mInnerFields.mWallpaperMayChange) {
+            if (WindowManagerService.DEBUG_WALLPAPER) Slog.v(TAG,
+                    "Wallpaper may change!  Adjusting");
+            mInnerFields.mAdjResult |= adjustWallpaperWindowsLocked();
+        }
+
+        if ((mInnerFields.mAdjResult&ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
+            if (DEBUG_WALLPAPER) Slog.v(TAG,
+                    "Wallpaper layer changed: assigning layers + relayout");
+            mPendingLayoutChanges |= PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
+            assignLayersLocked();
+        } else if ((mInnerFields.mAdjResult&ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
+            if (DEBUG_WALLPAPER) Slog.v(TAG,
+                    "Wallpaper visibility changed: relayout");
+            mPendingLayoutChanges |= PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
+        }
+
+        if (mFocusMayChange) {
+            mFocusMayChange = false;
+            if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES,
+                    false /*updateInputWindows*/)) {
+                mPendingLayoutChanges |= PhoneWindowManager.FINISH_LAYOUT_REDO_ANIM;
+                mInnerFields.mAdjResult = 0;
+            }
+        }
+
+        if (mLayoutNeeded) {
+            mPendingLayoutChanges |= PhoneWindowManager.FINISH_LAYOUT_REDO_LAYOUT;
+            if (DEBUG_LAYOUT_REPEATS) debugLayoutRepeats("mLayoutNeeded", mPendingLayoutChanges);
+        }
+
+        if (!mResizingWindows.isEmpty()) {
+            for (i = mResizingWindows.size() - 1; i >= 0; i--) {
+                WindowState win = mResizingWindows.get(i);
+                final WindowStateAnimator winAnimator = win.mWinAnimator;
+                try {
+                    if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,
+                            "Reporting new frame to " + win + ": " + win.mCompatFrame);
+                    int diff = 0;
+                    boolean configChanged =
+                        win.mConfiguration != mCurConfiguration
+                        && (win.mConfiguration == null
+                                || (diff=mCurConfiguration.diff(win.mConfiguration)) != 0);
+                    if ((DEBUG_RESIZE || DEBUG_ORIENTATION || DEBUG_CONFIGURATION)
+                            && configChanged) {
+                        Slog.i(TAG, "Sending new config to window " + win + ": "
+                                + winAnimator.mSurfaceW + "x" + winAnimator.mSurfaceH
+                                + " / " + mCurConfiguration + " / 0x"
+                                + Integer.toHexString(diff));
+                    }
+                    win.mConfiguration = mCurConfiguration;
+                    if (DEBUG_ORIENTATION &&
+                            winAnimator.mDrawState == WindowStateAnimator.DRAW_PENDING) Slog.i(
+                            TAG, "Resizing " + win + " WITH DRAW PENDING");
+                    win.mClient.resized((int)winAnimator.mSurfaceW,
+                            (int)winAnimator.mSurfaceH,
+                            win.mLastContentInsets, win.mLastVisibleInsets,
+                            winAnimator.mDrawState == WindowStateAnimator.DRAW_PENDING,
+                            configChanged ? win.mConfiguration : null);
+                    win.mContentInsetsChanged = false;
+                    win.mVisibleInsetsChanged = false;
+                    winAnimator.mSurfaceResized = false;
+                } catch (RemoteException e) {
+                    win.mOrientationChanging = false;
+                }
+            }
+            mResizingWindows.clear();
+        }
+
+        if (DEBUG_ORIENTATION && mDisplayFrozen) Slog.v(TAG,
+                "With display frozen, orientationChangeComplete="
+                + mInnerFields.mOrientationChangeComplete);
+        if (mInnerFields.mOrientationChangeComplete) {
+            if (mWindowsFreezingScreen) {
+                mWindowsFreezingScreen = false;
+                mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
+            }
+            stopFreezingDisplayLocked();
+        }
+
+        // Destroy the surface of any windows that are no longer visible.
+        boolean wallpaperDestroyed = false;
+        i = mDestroySurface.size();
+        if (i > 0) {
+            do {
+                i--;
+                WindowState win = mDestroySurface.get(i);
+                win.mDestroying = false;
+                if (mInputMethodWindow == win) {
+                    mInputMethodWindow = null;
+                }
+                if (win == mWallpaperTarget) {
+                    wallpaperDestroyed = true;
+                }
+                win.mWinAnimator.destroySurfaceLocked();
+            } while (i > 0);
+            mDestroySurface.clear();
+        }
+
+        // Time to remove any exiting tokens?
+        for (i=mExitingTokens.size()-1; i>=0; i--) {
+            WindowToken token = mExitingTokens.get(i);
+            if (!token.hasVisible) {
+                mExitingTokens.remove(i);
+                if (token.windowType == TYPE_WALLPAPER) {
+                    mWallpaperTokens.remove(token);
+                }
+            }
+        }
+
+        // Time to remove any exiting applications?
+        for (i=mExitingAppTokens.size()-1; i>=0; i--) {
+            AppWindowToken token = mExitingAppTokens.get(i);
+            if (!token.hasVisible && !mClosingApps.contains(token)) {
+                // Make sure there is no animation running on this token,
+                // so any windows associated with it will be removed as
+                // soon as their animations are complete
+                token.mAppAnimator.clearAnimation();
+                token.mAppAnimator.animating = false;
+                if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT) Slog.v(TAG,
+                        "performLayout: App token exiting now removed" + token);
+                mAppTokens.remove(token);
+                mAnimatingAppTokens.remove(token);
+                mExitingAppTokens.remove(i);
+            }
+        }
+
+        if (!mAnimator.mAnimating && mRelayoutWhileAnimating.size() > 0) {
+            for (int j=mRelayoutWhileAnimating.size()-1; j>=0; j--) {
+                try {
+                    mRelayoutWhileAnimating.get(j).mClient.doneAnimating();
+                } catch (RemoteException e) {
+                }
+            }
+            mRelayoutWhileAnimating.clear();
+        }
+
+        if (wallpaperDestroyed) {
+            mLayoutNeeded |= adjustWallpaperWindowsLocked() != 0;
+        }
+        if (mPendingLayoutChanges != 0) {
+            mLayoutNeeded = true;
+        }
+
+        // Finally update all input windows now that the window changes have stabilized.
+        mInputMonitor.updateInputWindowsLw(true /*force*/);
+
+        setHoldScreenLocked(mInnerFields.mHoldScreen != null);
+        if (!mDisplayFrozen) {
+            if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
+                mPowerManager.setScreenBrightnessOverride(-1);
+            } else {
+                mPowerManager.setScreenBrightnessOverride((int)
+                        (mInnerFields.mScreenBrightness * PowerManager.BRIGHTNESS_ON));
+            }
+            if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
+                mPowerManager.setButtonBrightnessOverride(-1);
+            } else {
+                mPowerManager.setButtonBrightnessOverride((int)
+                        (mInnerFields.mButtonBrightness * PowerManager.BRIGHTNESS_ON));
+            }
+        }
+        if (mInnerFields.mHoldScreen != mHoldingScreenOn) {
+            mHoldingScreenOn = mInnerFields.mHoldScreen;
+            Message m = mH.obtainMessage(H.HOLD_SCREEN_CHANGED, mInnerFields.mHoldScreen);
+            mH.sendMessage(m);
+        }
+
+        if (mTurnOnScreen) {
+            if (DEBUG_VISIBILITY) Slog.v(TAG, "Turning screen on after layout!");
+            mPowerManager.userActivity(SystemClock.uptimeMillis(), false,
+                    LocalPowerManager.BUTTON_EVENT, true);
+            mTurnOnScreen = false;
+        }
+
+        if (mInnerFields.mUpdateRotation) {
+            if (DEBUG_ORIENTATION) Slog.d(TAG, "Performing post-rotate rotation");
+            if (updateRotationUncheckedLocked(false)) {
+                mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
+            } else {
+                mInnerFields.mUpdateRotation = false;
+            }
+        }
+
+        if (mInnerFields.mOrientationChangeComplete && !mLayoutNeeded &&
+                !mInnerFields.mUpdateRotation) {
+            checkDrawnWindowsLocked();
+        }
+
+        // Check to see if we are now in a state where the screen should
+        // be enabled, because the window obscured flags have changed.
+        enableScreenIfNeededLocked();
+
+        scheduleAnimationLocked();
+
+        if (DEBUG_WINDOW_TRACE) {
+            Slog.e(TAG, "performLayoutAndPlaceSurfacesLockedInner exit: mPendingLayoutChanges="
+                + Integer.toHexString(mPendingLayoutChanges) + " mLayoutNeeded=" + mLayoutNeeded
+                + " animating=" + mAnimator.mAnimating);
+        }
+    }
+
+    void checkDrawnWindowsLocked() {
+        if (mWaitingForDrawn.size() > 0) {
+            for (int j=mWaitingForDrawn.size()-1; j>=0; j--) {
+                Pair<WindowState, IRemoteCallback> pair = mWaitingForDrawn.get(j);
+                WindowState win = pair.first;
+                //Slog.i(TAG, "Waiting for drawn " + win + ": removed="
+                //        + win.mRemoved + " visible=" + win.isVisibleLw()
+                //        + " shown=" + win.mSurfaceShown);
+                if (win.mRemoved || !win.isVisibleLw()) {
+                    // Window has been removed or made invisible; no draw
+                    // will now happen, so stop waiting.
+                    Slog.w(TAG, "Aborted waiting for drawn: " + pair.first);
+                    try {
+                        pair.second.sendResult(null);
+                    } catch (RemoteException e) {
+                    }
+                    mWaitingForDrawn.remove(pair);
+                    mH.removeMessages(H.WAITING_FOR_DRAWN_TIMEOUT, pair);
+                } else if (win.mWinAnimator.mSurfaceShown) {
+                    // Window is now drawn (and shown).
+                    try {
+                        pair.second.sendResult(null);
+                    } catch (RemoteException e) {
+                    }
+                    mWaitingForDrawn.remove(pair);
+                    mH.removeMessages(H.WAITING_FOR_DRAWN_TIMEOUT, pair);
+                }
+            }
+        }
+    }
+
+    public void waitForWindowDrawn(IBinder token, IRemoteCallback callback) {
+        synchronized (mWindowMap) {
+            WindowState win = windowForClientLocked(null, token, true);
+            if (win != null) {
+                Pair<WindowState, IRemoteCallback> pair =
+                        new Pair<WindowState, IRemoteCallback>(win, callback);
+                Message m = mH.obtainMessage(H.WAITING_FOR_DRAWN_TIMEOUT, pair);
+                mH.sendMessageDelayed(m, 2000);
+                mWaitingForDrawn.add(pair);
+                checkDrawnWindowsLocked();
+            }
+        }
+    }
+
+    /**
+     * Must be called with the main window manager lock held.
+     */
+    void setHoldScreenLocked(boolean holding) {
+        boolean state = mHoldingScreenWakeLock.isHeld();
+        if (holding != state) {
+            if (holding) {
+                mPolicy.screenOnStartedLw();
+                mHoldingScreenWakeLock.acquire();
+            } else {
+                mPolicy.screenOnStoppedLw();
+                mHoldingScreenWakeLock.release();
+            }
+        }
+    }
+
+    void requestTraversalLocked() {
+        if (!mTraversalScheduled) {
+            mTraversalScheduled = true;
+            mH.sendEmptyMessage(H.DO_TRAVERSAL);
+        }
+    }
+
+    void scheduleAnimationLocked() {
+        if (!mAnimationScheduled) {
+            mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, mAnimationRunnable, null);
+            mAnimationScheduled = true;
+        }
+    }
+
+    boolean reclaimSomeSurfaceMemoryLocked(WindowStateAnimator winAnimator, String operation,
+                                           boolean secure) {
+        final Surface surface = winAnimator.mSurface;
+        boolean leakedSurface = false;
+        boolean killedApps = false;
+
+        EventLog.writeEvent(EventLogTags.WM_NO_SURFACE_MEMORY, winAnimator.mWin.toString(),
+                winAnimator.mSession.mPid, operation);
+
+        if (mForceRemoves == null) {
+            mForceRemoves = new ArrayList<WindowState>();
+        }
+
+        long callingIdentity = Binder.clearCallingIdentity();
+        try {
+            // There was some problem...   first, do a sanity check of the
+            // window list to make sure we haven't left any dangling surfaces
+            // around.
+            int N = mWindows.size();
+            Slog.i(TAG, "Out of memory for surface!  Looking for leaks...");
+            for (int i=0; i<N; i++) {
+                WindowState ws = mWindows.get(i);
+                WindowStateAnimator wsa = ws.mWinAnimator;
+                if (wsa.mSurface != null) {
+                    if (!mSessions.contains(wsa.mSession)) {
+                        Slog.w(TAG, "LEAKED SURFACE (session doesn't exist): "
+                                + ws + " surface=" + wsa.mSurface
+                                + " token=" + ws.mToken
+                                + " pid=" + ws.mSession.mPid
+                                + " uid=" + ws.mSession.mUid);
+                        if (SHOW_TRANSACTIONS) logSurface(ws, "LEAK DESTROY", null);
+                        wsa.mSurface.destroy();
+                        wsa.mSurfaceShown = false;
+                        wsa.mSurface = null;
+                        ws.mHasSurface = false;
+                        mForceRemoves.add(ws);
+                        i--;
+                        N--;
+                        leakedSurface = true;
+                    } else if (ws.mAppToken != null && ws.mAppToken.clientHidden) {
+                        Slog.w(TAG, "LEAKED SURFACE (app token hidden): "
+                                + ws + " surface=" + wsa.mSurface
+                                + " token=" + ws.mAppToken);
+                        if (SHOW_TRANSACTIONS) logSurface(ws, "LEAK DESTROY", null);
+                        wsa.mSurface.destroy();
+                        wsa.mSurfaceShown = false;
+                        wsa.mSurface = null;
+                        ws.mHasSurface = false;
+                        leakedSurface = true;
+                    }
+                }
+            }
+
+            if (!leakedSurface) {
+                Slog.w(TAG, "No leaked surfaces; killing applicatons!");
+                SparseIntArray pidCandidates = new SparseIntArray();
+                for (int i=0; i<N; i++) {
+                    WindowStateAnimator wsa = mWindows.get(i).mWinAnimator;
+                    if (wsa.mSurface != null) {
+                        pidCandidates.append(wsa.mSession.mPid, wsa.mSession.mPid);
+                    }
+                }
+                if (pidCandidates.size() > 0) {
+                    int[] pids = new int[pidCandidates.size()];
+                    for (int i=0; i<pids.length; i++) {
+                        pids[i] = pidCandidates.keyAt(i);
+                    }
+                    try {
+                        if (mActivityManager.killPids(pids, "Free memory", secure)) {
+                            killedApps = true;
+                        }
+                    } catch (RemoteException e) {
+                    }
+                }
+            }
+
+            if (leakedSurface || killedApps) {
+                // We managed to reclaim some memory, so get rid of the trouble
+                // surface and ask the app to request another one.
+                Slog.w(TAG, "Looks like we have reclaimed some memory, clearing surface for retry.");
+                if (surface != null) {
+                    if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC) logSurface(winAnimator.mWin,
+                            "RECOVER DESTROY", null);
+                    surface.destroy();
+                    winAnimator.mSurfaceShown = false;
+                    winAnimator.mSurface = null;
+                    winAnimator.mWin.mHasSurface = false;
+                }
+
+                try {
+                    winAnimator.mWin.mClient.dispatchGetNewSurface();
+                } catch (RemoteException e) {
+                }
+            }
+        } finally {
+            Binder.restoreCallingIdentity(callingIdentity);
+        }
+
+        return leakedSurface || killedApps;
+    }
+
+    private boolean updateFocusedWindowLocked(int mode, boolean updateInputWindows) {
+        WindowState newFocus = computeFocusedWindowLocked();
+        if (mCurrentFocus != newFocus) {
+            Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, "wmUpdateFocus");
+            // This check makes sure that we don't already have the focus
+            // change message pending.
+            mH.removeMessages(H.REPORT_FOCUS_CHANGE);
+            mH.sendEmptyMessage(H.REPORT_FOCUS_CHANGE);
+            if (localLOGV) Slog.v(
+                TAG, "Changing focus from " + mCurrentFocus + " to " + newFocus);
+            final WindowState oldFocus = mCurrentFocus;
+            mCurrentFocus = newFocus;
+            mAnimator.setCurrentFocus(newFocus);
+            mLosingFocus.remove(newFocus);
+            int focusChanged = mPolicy.focusChangedLw(oldFocus, newFocus);
+
+            final WindowState imWindow = mInputMethodWindow;
+            if (newFocus != imWindow && oldFocus != imWindow) {
+                if (moveInputMethodWindowsIfNeededLocked(
+                        mode != UPDATE_FOCUS_WILL_ASSIGN_LAYERS &&
+                        mode != UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
+                    mLayoutNeeded = true;
+                }
+                if (mode == UPDATE_FOCUS_PLACING_SURFACES) {
+                    performLayoutLockedInner(true /*initial*/, updateInputWindows);
+                    focusChanged &= ~WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
+                } else if (mode == UPDATE_FOCUS_WILL_PLACE_SURFACES) {
+                    // Client will do the layout, but we need to assign layers
+                    // for handleNewWindowLocked() below.
+                    assignLayersLocked();
+                }
+            }
+
+            if ((focusChanged&WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
+                // The change in focus caused us to need to do a layout.  Okay.
+                mLayoutNeeded = true;
+                if (mode == UPDATE_FOCUS_PLACING_SURFACES) {
+                    performLayoutLockedInner(true /*initial*/, updateInputWindows);
+                }
+            }
+
+            if (mode != UPDATE_FOCUS_WILL_ASSIGN_LAYERS) {
+                // If we defer assigning layers, then the caller is responsible for
+                // doing this part.
+                finishUpdateFocusedWindowAfterAssignLayersLocked(updateInputWindows);
+            }
+
+            Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);
+            return true;
+        }
+        return false;
+    }
+    
+    private void finishUpdateFocusedWindowAfterAssignLayersLocked(boolean updateInputWindows) {
+        mInputMonitor.setInputFocusLw(mCurrentFocus, updateInputWindows);
+    }
+
+    private WindowState computeFocusedWindowLocked() {
+        WindowState result = null;
+        WindowState win;
+
+        int nextAppIndex = mAppTokens.size()-1;
+        WindowToken nextApp = nextAppIndex >= 0
+            ? mAppTokens.get(nextAppIndex) : null;
+
+        for (int i = mWindows.size() - 1; i >= 0; i--) {
+            win = mWindows.get(i);
+
+            if (localLOGV || DEBUG_FOCUS) Slog.v(
+                TAG, "Looking for focus: " + i
+                + " = " + win
+                + ", flags=" + win.mAttrs.flags
+                + ", canReceive=" + win.canReceiveKeys());
+
+            AppWindowToken thisApp = win.mAppToken;
+
+            // If this window's application has been removed, just skip it.
+            if (thisApp != null && (thisApp.removed || thisApp.sendingToBottom)) {
+                if (DEBUG_FOCUS) Slog.v(TAG, "Skipping app because " + (thisApp.removed
+                        ? "removed" : "sendingToBottom"));
+                continue;
+            }
+
+            // If there is a focused app, don't allow focus to go to any
+            // windows below it.  If this is an application window, step
+            // through the app tokens until we find its app.
+            if (thisApp != null && nextApp != null && thisApp != nextApp
+                    && win.mAttrs.type != TYPE_APPLICATION_STARTING) {
+                int origAppIndex = nextAppIndex;
+                while (nextAppIndex > 0) {
+                    if (nextApp == mFocusedApp) {
+                        // Whoops, we are below the focused app...  no focus
+                        // for you!
+                        if (localLOGV || DEBUG_FOCUS) Slog.v(
+                            TAG, "Reached focused app: " + mFocusedApp);
+                        return null;
+                    }
+                    nextAppIndex--;
+                    nextApp = mAppTokens.get(nextAppIndex);
+                    if (nextApp == thisApp) {
+                        break;
+                    }
+                }
+                if (thisApp != nextApp) {
+                    // Uh oh, the app token doesn't exist!  This shouldn't
+                    // happen, but if it does we can get totally hosed...
+                    // so restart at the original app.
+                    nextAppIndex = origAppIndex;
+                    nextApp = mAppTokens.get(nextAppIndex);
+                }
+            }
+
+            // Dispatch to this window if it is wants key events.
+            if (win.canReceiveKeys()) {
+                if (DEBUG_FOCUS) Slog.v(
+                        TAG, "Found focus @ " + i + " = " + win);
+                result = win;
+                break;
+            }
+        }
+
+        return result;
+    }
+
+    private void startFreezingDisplayLocked(boolean inTransaction) {
+        if (mDisplayFrozen) {
+            return;
+        }
+
+        if (mDisplay == null || !mPolicy.isScreenOnFully()) {
+            // No need to freeze the screen before the system is ready or if
+            // the screen is off.
+            return;
+        }
+
+        mScreenFrozenLock.acquire();
+
+        mDisplayFrozen = true;
+
+        mInputMonitor.freezeInputDispatchingLw();
+
+        if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
+            mNextAppTransition = WindowManagerPolicy.TRANSIT_UNSET;
+            mNextAppTransitionType = ActivityOptions.ANIM_NONE;
+            mNextAppTransitionPackage = null;
+            mNextAppTransitionThumbnail = null;
+            mAppTransitionReady = true;
+        }
+
+        if (PROFILE_ORIENTATION) {
+            File file = new File("/data/system/frozen");
+            Debug.startMethodTracing(file.toString(), 8 * 1024 * 1024);
+        }
+
+        if (CUSTOM_SCREEN_ROTATION) {
+            if (mAnimator.mScreenRotationAnimation != null) {
+                mAnimator.mScreenRotationAnimation.kill();
+                mAnimator.mScreenRotationAnimation = null;
+            }
+
+            mAnimator.mScreenRotationAnimation = new ScreenRotationAnimation(mContext,
+                    mFxSession, inTransaction, mCurDisplayWidth, mCurDisplayHeight,
+                    mDisplay.getRotation());
+
+            if (!mAnimator.mScreenRotationAnimation.hasScreenshot()) {
+                Surface.freezeDisplay(0);
+            }
+        } else {
+            Surface.freezeDisplay(0);
+        }
+    }
+
+    private void stopFreezingDisplayLocked() {
+        if (!mDisplayFrozen) {
+            return;
+        }
+
+        if (mWaitingForConfig || mAppsFreezingScreen > 0 || mWindowsFreezingScreen) {
+            if (DEBUG_ORIENTATION) Slog.d(TAG,
+                "stopFreezingDisplayLocked: Returning mWaitingForConfig=" + mWaitingForConfig
+                + ", mAppsFreezingScreen=" + mAppsFreezingScreen
+                + ", mWindowsFreezingScreen=" + mWindowsFreezingScreen);
+            return;
+        }
+        
+        mDisplayFrozen = false;
+        mH.removeMessages(H.APP_FREEZE_TIMEOUT);
+        if (PROFILE_ORIENTATION) {
+            Debug.stopMethodTracing();
+        }
+
+        boolean updateRotation = false;
+        
+        if (CUSTOM_SCREEN_ROTATION && mAnimator.mScreenRotationAnimation != null
+                && mAnimator.mScreenRotationAnimation.hasScreenshot()) {
+            if (DEBUG_ORIENTATION) Slog.i(TAG, "**** Dismissing screen rotation animation");
+            if (mAnimator.mScreenRotationAnimation.dismiss(mFxSession, MAX_ANIMATION_DURATION,
+                    mTransitionAnimationScale, mCurDisplayWidth, mCurDisplayHeight)) {
+                scheduleAnimationLocked();
+            } else {
+                mAnimator.mScreenRotationAnimation.kill();
+                mAnimator.mScreenRotationAnimation = null;
+                updateRotation = true;
+            }
+        } else {
+            if (mAnimator.mScreenRotationAnimation != null) {
+                mAnimator.mScreenRotationAnimation.kill();
+                mAnimator.mScreenRotationAnimation = null;
+            }
+            updateRotation = true;
+        }
+        Surface.unfreezeDisplay(0);
+
+        mInputMonitor.thawInputDispatchingLw();
+
+        boolean configChanged;
+        
+        // While the display is frozen we don't re-compute the orientation
+        // to avoid inconsistent states.  However, something interesting
+        // could have actually changed during that time so re-evaluate it
+        // now to catch that.
+        configChanged = updateOrientationFromAppTokensLocked(false);
+
+        // A little kludge: a lot could have happened while the
+        // display was frozen, so now that we are coming back we
+        // do a gc so that any remote references the system
+        // processes holds on others can be released if they are
+        // no longer needed.
+        mH.removeMessages(H.FORCE_GC);
+        mH.sendMessageDelayed(mH.obtainMessage(H.FORCE_GC),
+                2000);
+
+        mScreenFrozenLock.release();
+        
+        if (updateRotation) {
+            if (DEBUG_ORIENTATION) Slog.d(TAG, "Performing post-rotate rotation");
+            configChanged |= updateRotationUncheckedLocked(false);
+        }
+        
+        if (configChanged) {
+            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
+        }
+    }
+
+    static int getPropertyInt(String[] tokens, int index, int defUnits, int defDps,
+            DisplayMetrics dm) {
+        if (index < tokens.length) {
+            String str = tokens[index];
+            if (str != null && str.length() > 0) {
+                try {
+                    int val = Integer.parseInt(str);
+                    return val;
+                } catch (Exception e) {
+                }
+            }
+        }
+        if (defUnits == TypedValue.COMPLEX_UNIT_PX) {
+            return defDps;
+        }
+        int val = (int)TypedValue.applyDimension(defUnits, defDps, dm);
+        return val;
+    }
+
+    void createWatermark() {
+        if (mWatermark != null) {
+            return;
+        }
+
+        File file = new File("/system/etc/setup.conf");
+        FileInputStream in = null;
+        try {
+            in = new FileInputStream(file);
+            DataInputStream ind = new DataInputStream(in);
+            String line = ind.readLine();
+            if (line != null) {
+                String[] toks = line.split("%");
+                if (toks != null && toks.length > 0) {
+                    mWatermark = new Watermark(mRealDisplayMetrics, mFxSession, toks);
+                }
+            }
+        } catch (FileNotFoundException e) {
+        } catch (IOException e) {
+        } finally {
+            if (in != null) {
+                try {
+                    in.close();
+                } catch (IOException e) {
+                }
+            }
+        }
+    }
+
+    @Override
+    public void statusBarVisibilityChanged(int visibility) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Caller does not hold permission "
+                    + android.Manifest.permission.STATUS_BAR);
+        }
+
+        synchronized (mWindowMap) {
+            mLastStatusBarVisibility = visibility;
+            visibility = mPolicy.adjustSystemUiVisibilityLw(visibility);
+            updateStatusBarVisibilityLocked(visibility);
+        }
+    }
+
+    void updateStatusBarVisibilityLocked(int visibility) {
+        mInputManager.setSystemUiVisibility(visibility);
+        final int N = mWindows.size();
+        for (int i = 0; i < N; i++) {
+            WindowState ws = mWindows.get(i);
+            try {
+                int curValue = ws.mSystemUiVisibility;
+                int diff = curValue ^ visibility;
+                // We are only interested in differences of one of the
+                // clearable flags...
+                diff &= View.SYSTEM_UI_CLEARABLE_FLAGS;
+                // ...if it has actually been cleared.
+                diff &= ~visibility;
+                int newValue = (curValue&~diff) | (visibility&diff);
+                if (newValue != curValue) {
+                    ws.mSeq++;
+                    ws.mSystemUiVisibility = newValue;
+                }
+                if (newValue != curValue || ws.mAttrs.hasSystemUiListeners) {
+                    ws.mClient.dispatchSystemUiVisibilityChanged(ws.mSeq,
+                            visibility, newValue, diff);
+                }
+            } catch (RemoteException e) {
+                // so sorry
+            }
+        }
+    }
+ 
+    @Override
+    public void reevaluateStatusBarVisibility() {
+        synchronized (mWindowMap) {
+            int visibility = mPolicy.adjustSystemUiVisibilityLw(mLastStatusBarVisibility);
+            updateStatusBarVisibilityLocked(visibility);
+            performLayoutAndPlaceSurfacesLocked();
+        }
+    }
+
+    @Override
+    public FakeWindow addFakeWindow(Looper looper,
+            InputEventReceiver.Factory inputEventReceiverFactory,
+            String name, int windowType, int layoutParamsFlags, boolean canReceiveKeys,
+            boolean hasFocus, boolean touchFullscreen) {
+        synchronized (mWindowMap) {
+            FakeWindowImpl fw = new FakeWindowImpl(this, looper, inputEventReceiverFactory,
+                    name, windowType,
+                    layoutParamsFlags, canReceiveKeys, hasFocus, touchFullscreen);
+            int i=0;
+            while (i<mFakeWindows.size()) {
+                if (mFakeWindows.get(i).mWindowLayer <= fw.mWindowLayer) {
+                    break;
+                }
+            }
+            mFakeWindows.add(i, fw);
+            mInputMonitor.updateInputWindowsLw(true);
+            return fw;
+        }
+    }
+
+    boolean removeFakeWindowLocked(FakeWindow window) {
+        synchronized (mWindowMap) {
+            if (mFakeWindows.remove(window)) {
+                mInputMonitor.updateInputWindowsLw(true);
+                return true;
+            }
+            return false;
+        }
+    }
+
+    // It is assumed that this method is called only by InputMethodManagerService.
+    public void saveLastInputMethodWindowForTransition() {
+        synchronized (mWindowMap) {
+            if (mInputMethodWindow != null) {
+                mPolicy.setLastInputMethodWindowLw(mInputMethodWindow, mInputMethodTarget);
+            }
+        }
+    }
+
+    @Override
+    public boolean hasNavigationBar() {
+        return mPolicy.hasNavigationBar();
+    }
+
+    public void lockNow() {
+        mPolicy.lockNow();
+    }
+
+    void dumpPolicyLocked(PrintWriter pw, String[] args, boolean dumpAll) {
+        pw.println("WINDOW MANAGER POLICY STATE (dumpsys window policy)");
+        mPolicy.dump("    ", pw, args);
+    }
+
+    void dumpTokensLocked(PrintWriter pw, boolean dumpAll) {
+        pw.println("WINDOW MANAGER TOKENS (dumpsys window tokens)");
+        if (mTokenMap.size() > 0) {
+            pw.println("  All tokens:");
+            Iterator<WindowToken> it = mTokenMap.values().iterator();
+            while (it.hasNext()) {
+                WindowToken token = it.next();
+                pw.print("  Token "); pw.print(token.token);
+                if (dumpAll) {
+                    pw.println(':');
+                    token.dump(pw, "    ");
+                } else {
+                    pw.println();
+                }
+            }
+        }
+        if (mWallpaperTokens.size() > 0) {
+            pw.println();
+            pw.println("  Wallpaper tokens:");
+            for (int i=mWallpaperTokens.size()-1; i>=0; i--) {
+                WindowToken token = mWallpaperTokens.get(i);
+                pw.print("  Wallpaper #"); pw.print(i);
+                        pw.print(' '); pw.print(token);
+                if (dumpAll) {
+                    pw.println(':');
+                    token.dump(pw, "    ");
+                } else {
+                    pw.println();
+                }
+            }
+        }
+        if (mAppTokens.size() > 0) {
+            pw.println();
+            pw.println("  Application tokens in Z order:");
+            for (int i=mAppTokens.size()-1; i>=0; i--) {
+                pw.print("  App #"); pw.print(i); pw.println(": ");
+                        mAppTokens.get(i).dump(pw, "    ");
+            }
+        }
+        if (mFinishedStarting.size() > 0) {
+            pw.println();
+            pw.println("  Finishing start of application tokens:");
+            for (int i=mFinishedStarting.size()-1; i>=0; i--) {
+                WindowToken token = mFinishedStarting.get(i);
+                pw.print("  Finished Starting #"); pw.print(i);
+                        pw.print(' '); pw.print(token);
+                if (dumpAll) {
+                    pw.println(':');
+                    token.dump(pw, "    ");
+                } else {
+                    pw.println();
+                }
+            }
+        }
+        if (mExitingTokens.size() > 0) {
+            pw.println();
+            pw.println("  Exiting tokens:");
+            for (int i=mExitingTokens.size()-1; i>=0; i--) {
+                WindowToken token = mExitingTokens.get(i);
+                pw.print("  Exiting #"); pw.print(i);
+                        pw.print(' '); pw.print(token);
+                if (dumpAll) {
+                    pw.println(':');
+                    token.dump(pw, "    ");
+                } else {
+                    pw.println();
+                }
+            }
+        }
+        if (mExitingAppTokens.size() > 0) {
+            pw.println();
+            pw.println("  Exiting application tokens:");
+            for (int i=mExitingAppTokens.size()-1; i>=0; i--) {
+                WindowToken token = mExitingAppTokens.get(i);
+                pw.print("  Exiting App #"); pw.print(i);
+                        pw.print(' '); pw.print(token);
+                if (dumpAll) {
+                    pw.println(':');
+                    token.dump(pw, "    ");
+                } else {
+                    pw.println();
+                }
+            }
+        }
+        if (mAppTransitionRunning && mAnimatingAppTokens.size() > 0) {
+            pw.println();
+            pw.println("  Application tokens during animation:");
+            for (int i=mAnimatingAppTokens.size()-1; i>=0; i--) {
+                WindowToken token = mAnimatingAppTokens.get(i);
+                pw.print("  App moving to bottom #"); pw.print(i);
+                        pw.print(' '); pw.print(token);
+                if (dumpAll) {
+                    pw.println(':');
+                    token.dump(pw, "    ");
+                } else {
+                    pw.println();
+                }
+            }
+        }
+        if (mOpeningApps.size() > 0 || mClosingApps.size() > 0) {
+            pw.println();
+            if (mOpeningApps.size() > 0) {
+                pw.print("  mOpeningApps="); pw.println(mOpeningApps);
+            }
+            if (mClosingApps.size() > 0) {
+                pw.print("  mClosingApps="); pw.println(mClosingApps);
+            }
+        }
+    }
+
+    void dumpSessionsLocked(PrintWriter pw, boolean dumpAll) {
+        pw.println("WINDOW MANAGER SESSIONS (dumpsys window sessions)");
+        if (mSessions.size() > 0) {
+            Iterator<Session> it = mSessions.iterator();
+            while (it.hasNext()) {
+                Session s = it.next();
+                pw.print("  Session "); pw.print(s); pw.println(':');
+                s.dump(pw, "    ");
+            }
+        }
+    }
+
+    void dumpWindowsLocked(PrintWriter pw, boolean dumpAll,
+            ArrayList<WindowState> windows) {
+        pw.println("WINDOW MANAGER WINDOWS (dumpsys window windows)");
+        dumpWindowsNoHeaderLocked(pw, dumpAll, windows);
+    }
+
+    void dumpWindowsNoHeaderLocked(PrintWriter pw, boolean dumpAll,
+            ArrayList<WindowState> windows) {
+        for (int i=mWindows.size()-1; i>=0; i--) {
+            WindowState w = mWindows.get(i);
+            if (windows == null || windows.contains(w)) {
+                pw.print("  Window #"); pw.print(i); pw.print(' ');
+                        pw.print(w); pw.println(":");
+                w.dump(pw, "    ", dumpAll || windows != null);
+            }
+        }
+        if (mInputMethodDialogs.size() > 0) {
+            pw.println();
+            pw.println("  Input method dialogs:");
+            for (int i=mInputMethodDialogs.size()-1; i>=0; i--) {
+                WindowState w = mInputMethodDialogs.get(i);
+                if (windows == null || windows.contains(w)) {
+                    pw.print("  IM Dialog #"); pw.print(i); pw.print(": "); pw.println(w);
+                }
+            }
+        }
+        if (mPendingRemove.size() > 0) {
+            pw.println();
+            pw.println("  Remove pending for:");
+            for (int i=mPendingRemove.size()-1; i>=0; i--) {
+                WindowState w = mPendingRemove.get(i);
+                if (windows == null || windows.contains(w)) {
+                    pw.print("  Remove #"); pw.print(i); pw.print(' ');
+                            pw.print(w);
+                    if (dumpAll) {
+                        pw.println(":");
+                        w.dump(pw, "    ", true);
+                    } else {
+                        pw.println();
+                    }
+                }
+            }
+        }
+        if (mForceRemoves != null && mForceRemoves.size() > 0) {
+            pw.println();
+            pw.println("  Windows force removing:");
+            for (int i=mForceRemoves.size()-1; i>=0; i--) {
+                WindowState w = mForceRemoves.get(i);
+                pw.print("  Removing #"); pw.print(i); pw.print(' ');
+                        pw.print(w);
+                if (dumpAll) {
+                    pw.println(":");
+                    w.dump(pw, "    ", true);
+                } else {
+                    pw.println();
+                }
+            }
+        }
+        if (mDestroySurface.size() > 0) {
+            pw.println();
+            pw.println("  Windows waiting to destroy their surface:");
+            for (int i=mDestroySurface.size()-1; i>=0; i--) {
+                WindowState w = mDestroySurface.get(i);
+                if (windows == null || windows.contains(w)) {
+                    pw.print("  Destroy #"); pw.print(i); pw.print(' ');
+                            pw.print(w);
+                    if (dumpAll) {
+                        pw.println(":");
+                        w.dump(pw, "    ", true);
+                    } else {
+                        pw.println();
+                    }
+                }
+            }
+        }
+        if (mLosingFocus.size() > 0) {
+            pw.println();
+            pw.println("  Windows losing focus:");
+            for (int i=mLosingFocus.size()-1; i>=0; i--) {
+                WindowState w = mLosingFocus.get(i);
+                if (windows == null || windows.contains(w)) {
+                    pw.print("  Losing #"); pw.print(i); pw.print(' ');
+                            pw.print(w);
+                    if (dumpAll) {
+                        pw.println(":");
+                        w.dump(pw, "    ", true);
+                    } else {
+                        pw.println();
+                    }
+                }
+            }
+        }
+        if (mResizingWindows.size() > 0) {
+            pw.println();
+            pw.println("  Windows waiting to resize:");
+            for (int i=mResizingWindows.size()-1; i>=0; i--) {
+                WindowState w = mResizingWindows.get(i);
+                if (windows == null || windows.contains(w)) {
+                    pw.print("  Resizing #"); pw.print(i); pw.print(' ');
+                            pw.print(w);
+                    if (dumpAll) {
+                        pw.println(":");
+                        w.dump(pw, "    ", true);
+                    } else {
+                        pw.println();
+                    }
+                }
+            }
+        }
+        if (mWaitingForDrawn.size() > 0) {
+            pw.println();
+            pw.println("  Clients waiting for these windows to be drawn:");
+            for (int i=mWaitingForDrawn.size()-1; i>=0; i--) {
+                Pair<WindowState, IRemoteCallback> pair = mWaitingForDrawn.get(i);
+                pw.print("  Waiting #"); pw.print(i); pw.print(' '); pw.print(pair.first);
+                        pw.print(": "); pw.println(pair.second);
+            }
+        }
+        pw.println();
+        if (mDisplay != null) {
+            pw.print("  Display: init="); pw.print(mInitialDisplayWidth); pw.print("x");
+                    pw.print(mInitialDisplayHeight);
+                    if (mInitialDisplayWidth != mBaseDisplayWidth
+                            || mInitialDisplayHeight != mBaseDisplayHeight) {
+                        pw.print(" base=");
+                        pw.print(mBaseDisplayWidth); pw.print("x"); pw.print(mBaseDisplayHeight);
+                    }
+                    final int rawWidth = mDisplay.getRawWidth();
+                    final int rawHeight = mDisplay.getRawHeight();
+                    if (rawWidth != mCurDisplayWidth || rawHeight != mCurDisplayHeight) {
+                        pw.print(" raw="); pw.print(rawWidth); pw.print("x"); pw.print(rawHeight);
+                    }
+                    pw.print(" cur=");
+                    pw.print(mCurDisplayWidth); pw.print("x"); pw.print(mCurDisplayHeight);
+                    pw.print(" app=");
+                    pw.print(mAppDisplayWidth); pw.print("x"); pw.print(mAppDisplayHeight);
+                    pw.print(" rng="); pw.print(mSmallestDisplayWidth);
+                    pw.print("x"); pw.print(mSmallestDisplayHeight);
+                    pw.print("-"); pw.print(mLargestDisplayWidth);
+                    pw.print("x"); pw.println(mLargestDisplayHeight);
+        } else {
+            pw.println("  NO DISPLAY");
+        }
+        pw.print("  mCurConfiguration="); pw.println(this.mCurConfiguration);
+        pw.print("  mCurrentFocus="); pw.println(mCurrentFocus);
+        if (mLastFocus != mCurrentFocus) {
+            pw.print("  mLastFocus="); pw.println(mLastFocus);
+        }
+        pw.print("  mFocusedApp="); pw.println(mFocusedApp);
+        if (mInputMethodTarget != null) {
+            pw.print("  mInputMethodTarget="); pw.println(mInputMethodTarget);
+        }
+        pw.print("  mInTouchMode="); pw.print(mInTouchMode);
+                pw.print(" mLayoutSeq="); pw.println(mLayoutSeq);
+        if (dumpAll) {
+            pw.print("  mSystemDecorRect="); pw.print(mSystemDecorRect.toShortString());
+                    pw.print(" mSystemDecorLayer="); pw.println(mSystemDecorLayer);
+            if (mLastStatusBarVisibility != 0) {
+                pw.print("  mLastStatusBarVisibility=0x");
+                        pw.println(Integer.toHexString(mLastStatusBarVisibility));
+            }
+            if (mInputMethodWindow != null) {
+                pw.print("  mInputMethodWindow="); pw.println(mInputMethodWindow);
+            }
+            pw.print("  mWallpaperTarget="); pw.println(mWallpaperTarget);
+            if (mLowerWallpaperTarget != null && mUpperWallpaperTarget != null) {
+                pw.print("  mLowerWallpaperTarget="); pw.println(mLowerWallpaperTarget);
+                pw.print("  mUpperWallpaperTarget="); pw.println(mUpperWallpaperTarget);
+            }
+            pw.print("  mLastWallpaperX="); pw.print(mLastWallpaperX);
+                    pw.print(" mLastWallpaperY="); pw.println(mLastWallpaperY);
+            if (mInputMethodAnimLayerAdjustment != 0 ||
+                    mWallpaperAnimLayerAdjustment != 0) {
+                pw.print("  mInputMethodAnimLayerAdjustment=");
+                        pw.print(mInputMethodAnimLayerAdjustment);
+                        pw.print("  mWallpaperAnimLayerAdjustment=");
+                        pw.println(mWallpaperAnimLayerAdjustment);
+            }
+            pw.print("  mSystemBooted="); pw.print(mSystemBooted);
+                    pw.print(" mDisplayEnabled="); pw.println(mDisplayEnabled);
+            pw.print("  mLayoutNeeded="); pw.print(mLayoutNeeded);
+                    pw.print("mTransactionSequence="); pw.println(mTransactionSequence);
+            pw.print("  mDisplayFrozen="); pw.print(mDisplayFrozen);
+                    pw.print(" mWindowsFreezingScreen="); pw.print(mWindowsFreezingScreen);
+                    pw.print(" mAppsFreezingScreen="); pw.print(mAppsFreezingScreen);
+                    pw.print(" mWaitingForConfig="); pw.println(mWaitingForConfig);
+            pw.print("  mRotation="); pw.print(mRotation);
+                    pw.print(" mAltOrientation="); pw.println(mAltOrientation);
+            pw.print("  mLastWindowForcedOrientation="); pw.print(mLastWindowForcedOrientation);
+                    pw.print(" mForcedAppOrientation="); pw.println(mForcedAppOrientation);
+            pw.print("  mDeferredRotationPauseCount="); pw.println(mDeferredRotationPauseCount);
+            if (mAnimator.mScreenRotationAnimation != null) {
+                pw.println("  mScreenRotationAnimation:");
+                mAnimator.mScreenRotationAnimation.printTo("    ", pw);
+            }
+            pw.print("  mWindowAnimationScale="); pw.print(mWindowAnimationScale);
+                    pw.print(" mTransitionWindowAnimationScale="); pw.print(mTransitionAnimationScale);
+                    pw.print(" mAnimatorDurationScale="); pw.println(mAnimatorDurationScale);
+            pw.print("  mTraversalScheduled="); pw.print(mTraversalScheduled);
+                    pw.print(" mNextAppTransition=0x");
+                    pw.print(Integer.toHexString(mNextAppTransition));
+                    pw.print(" mAppTransitionReady="); pw.println(mAppTransitionReady);
+            pw.print("  mAppTransitionRunning="); pw.print(mAppTransitionRunning);
+                    pw.print(" mAppTransitionTimeout="); pw.println(mAppTransitionTimeout);
+            if (mNextAppTransitionType != ActivityOptions.ANIM_NONE) {
+                pw.print("  mNextAppTransitionType="); pw.println(mNextAppTransitionType);
+            }
+            switch (mNextAppTransitionType) {
+                case ActivityOptions.ANIM_CUSTOM:
+                    pw.print("  mNextAppTransitionPackage=");
+                            pw.println(mNextAppTransitionPackage);
+                    pw.print("  mNextAppTransitionEnter=0x");
+                            pw.print(Integer.toHexString(mNextAppTransitionEnter));
+                            pw.print(" mNextAppTransitionExit=0x");
+                            pw.println(Integer.toHexString(mNextAppTransitionExit));
+                    break;
+                case ActivityOptions.ANIM_SCALE_UP:
+                    pw.print("  mNextAppTransitionStartX="); pw.print(mNextAppTransitionStartX);
+                            pw.print(" mNextAppTransitionStartY=");
+                            pw.println(mNextAppTransitionStartY);
+                    pw.print("  mNextAppTransitionStartWidth=");
+                            pw.print(mNextAppTransitionStartWidth);
+                            pw.print(" mNextAppTransitionStartHeight=");
+                            pw.println(mNextAppTransitionStartHeight);
+                    break;
+                case ActivityOptions.ANIM_THUMBNAIL:
+                case ActivityOptions.ANIM_THUMBNAIL_DELAYED:
+                    pw.print("  mNextAppTransitionThumbnail=");
+                            pw.print(mNextAppTransitionThumbnail);
+                            pw.print(" mNextAppTransitionStartX=");
+                            pw.print(mNextAppTransitionStartX);
+                            pw.print(" mNextAppTransitionStartY=");
+                            pw.println(mNextAppTransitionStartY);
+                    pw.print("  mNextAppTransitionDelayed="); pw.println(mNextAppTransitionDelayed);
+                    break;
+            }
+            if (mNextAppTransitionCallback != null) {
+                pw.print("  mNextAppTransitionCallback=");
+                        pw.println(mNextAppTransitionCallback);
+            }
+            pw.print("  mStartingIconInTransition="); pw.print(mStartingIconInTransition);
+                    pw.print(" mSkipAppTransitionAnimation="); pw.println(mSkipAppTransitionAnimation);
+            pw.println("  Window Animator:");
+            mAnimator.dump(pw, "    ", dumpAll);
+        }
+    }
+
+    boolean dumpWindows(PrintWriter pw, String name, String[] args,
+            int opti, boolean dumpAll) {
+        ArrayList<WindowState> windows = new ArrayList<WindowState>();
+        if ("visible".equals(name)) {
+            synchronized(mWindowMap) {
+                for (int i=mWindows.size()-1; i>=0; i--) {
+                    WindowState w = mWindows.get(i);
+                    if (w.mWinAnimator.mSurfaceShown) {
+                        windows.add(w);
+                    }
+                }
+            }
+        } else {
+            int objectId = 0;
+            // See if this is an object ID.
+            try {
+                objectId = Integer.parseInt(name, 16);
+                name = null;
+            } catch (RuntimeException e) {
+            }
+            synchronized(mWindowMap) {
+                for (int i=mWindows.size()-1; i>=0; i--) {
+                    WindowState w = mWindows.get(i);
+                    if (name != null) {
+                        if (w.mAttrs.getTitle().toString().contains(name)) {
+                            windows.add(w);
+                        }
+                    } else if (System.identityHashCode(w) == objectId) {
+                        windows.add(w);
+                    }
+                }
+            }
+        }
+
+        if (windows.size() <= 0) {
+            return false;
+        }
+
+        synchronized(mWindowMap) {
+            dumpWindowsLocked(pw, dumpAll, windows);
+        }
+        return true;
+    }
+
+    void dumpLastANRLocked(PrintWriter pw) {
+        pw.println("WINDOW MANAGER LAST ANR (dumpsys window lastanr)");
+        if (mLastANRState == null) {
+            pw.println("  <no ANR has occurred since boot>");
+        } else {
+            pw.println(mLastANRState);
+        }
+    }
+
+    /**
+     * Saves information about the state of the window manager at
+     * the time an ANR occurred before anything else in the system changes
+     * in response.
+     *
+     * @param appWindowToken The application that ANR'd, may be null.
+     * @param windowState The window that ANR'd, may be null.
+     */
+    public void saveANRStateLocked(AppWindowToken appWindowToken, WindowState windowState) {
+        StringWriter sw = new StringWriter();
+        PrintWriter pw = new PrintWriter(sw);
+        pw.println("  ANR time: " + DateFormat.getInstance().format(new Date()));
+        if (appWindowToken != null) {
+            pw.println("  Application at fault: " + appWindowToken.stringName);
+        }
+        if (windowState != null) {
+            pw.println("  Window at fault: " + windowState.mAttrs.getTitle());
+        }
+        pw.println();
+        dumpWindowsNoHeaderLocked(pw, true, null);
+        pw.close();
+        mLastANRState = sw.toString();
+    }
+
+    @Override
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        if (mContext.checkCallingOrSelfPermission("android.permission.DUMP")
+                != PackageManager.PERMISSION_GRANTED) {
+            pw.println("Permission Denial: can't dump WindowManager from from pid="
+                    + Binder.getCallingPid()
+                    + ", uid=" + Binder.getCallingUid());
+            return;
+        }
+
+        boolean dumpAll = false;
+
+        int opti = 0;
+        while (opti < args.length) {
+            String opt = args[opti];
+            if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
+                break;
+            }
+            opti++;
+            if ("-a".equals(opt)) {
+                dumpAll = true;
+            } else if ("-h".equals(opt)) {
+                pw.println("Window manager dump options:");
+                pw.println("  [-a] [-h] [cmd] ...");
+                pw.println("  cmd may be one of:");
+                pw.println("    l[astanr]: last ANR information");
+                pw.println("    p[policy]: policy state");
+                pw.println("    s[essions]: active sessions");
+                pw.println("    t[okens]: token list");
+                pw.println("    w[indows]: window list");
+                pw.println("  cmd may also be a NAME to dump windows.  NAME may");
+                pw.println("    be a partial substring in a window name, a");
+                pw.println("    Window hex object identifier, or");
+                pw.println("    \"all\" for all windows, or");
+                pw.println("    \"visible\" for the visible windows.");
+                pw.println("  -a: include all available server state.");
+                return;
+            } else {
+                pw.println("Unknown argument: " + opt + "; use -h for help");
+            }
+        }
+
+        // Is the caller requesting to dump a particular piece of data?
+        if (opti < args.length) {
+            String cmd = args[opti];
+            opti++;
+            if ("lastanr".equals(cmd) || "l".equals(cmd)) {
+                synchronized(mWindowMap) {
+                    dumpLastANRLocked(pw);
+                }
+                return;
+            } else if ("policy".equals(cmd) || "p".equals(cmd)) {
+                synchronized(mWindowMap) {
+                    dumpPolicyLocked(pw, args, true);
+                }
+                return;
+            } else if ("sessions".equals(cmd) || "s".equals(cmd)) {
+                synchronized(mWindowMap) {
+                    dumpSessionsLocked(pw, true);
+                }
+                return;
+            } else if ("tokens".equals(cmd) || "t".equals(cmd)) {
+                synchronized(mWindowMap) {
+                    dumpTokensLocked(pw, true);
+                }
+                return;
+            } else if ("windows".equals(cmd) || "w".equals(cmd)) {
+                synchronized(mWindowMap) {
+                    dumpWindowsLocked(pw, true, null);
+                }
+                return;
+            } else if ("all".equals(cmd) || "a".equals(cmd)) {
+                synchronized(mWindowMap) {
+                    dumpWindowsLocked(pw, true, null);
+                }
+                return;
+            } else {
+                // Dumping a single name?
+                if (!dumpWindows(pw, cmd, args, opti, dumpAll)) {
+                    pw.println("Bad window command, or no windows match: " + cmd);
+                    pw.println("Use -h for help.");
+                }
+                return;
+            }
+        }
+
+        synchronized(mWindowMap) {
+            pw.println();
+            if (dumpAll) {
+                pw.println("-------------------------------------------------------------------------------");
+            }
+            dumpLastANRLocked(pw);
+            pw.println();
+            if (dumpAll) {
+                pw.println("-------------------------------------------------------------------------------");
+            }
+            dumpPolicyLocked(pw, args, dumpAll);
+            pw.println();
+            if (dumpAll) {
+                pw.println("-------------------------------------------------------------------------------");
+            }
+            dumpSessionsLocked(pw, dumpAll);
+            pw.println();
+            if (dumpAll) {
+                pw.println("-------------------------------------------------------------------------------");
+            }
+            dumpTokensLocked(pw, dumpAll);
+            pw.println();
+            if (dumpAll) {
+                pw.println("-------------------------------------------------------------------------------");
+            }
+            dumpWindowsLocked(pw, dumpAll, null);
+        }
+    }
+
+    // Called by the heartbeat to ensure locks are not held indefnitely (for deadlock detection).
+    public void monitor() {
+        synchronized (mWindowMap) { }
+        synchronized (mKeyguardTokenWatcher) { }
+    }
+
+    public interface OnHardKeyboardStatusChangeListener {
+        public void onHardKeyboardStatusChange(boolean available, boolean enabled);
+    }
+
+    void debugLayoutRepeats(final String msg, int pendingLayoutChanges) {
+        if (mLayoutRepeatCount >= LAYOUT_REPEAT_THRESHOLD) {
+            Slog.v(TAG, "Layouts looping: " + msg + ", mPendingLayoutChanges = 0x" +
+                    Integer.toHexString(pendingLayoutChanges));
+        }
+    }
+
+    void bulkSetParameters(final int bulkUpdateParams, int pendingLayoutChanges) {
+        mH.sendMessage(mH.obtainMessage(H.BULK_UPDATE_PARAMETERS, bulkUpdateParams,
+                pendingLayoutChanges));
+    }
+}
-- 
1.7.9.5

